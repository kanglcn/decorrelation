[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Decorrelation",
    "section": "",
    "text": "A simple, stupid InSAR postprocessing tool in big data era\nThis package provide functions for InSAR post-processing which refers as processing after SAR images co-registration and geocoding. The functions include PS/DS identification, coherence matrix estimation, phase linking etc.",
    "crumbs": [
      "Decorrelation"
    ]
  },
  {
    "objectID": "index.html#principle1",
    "href": "index.html#principle1",
    "title": "Decorrelation",
    "section": "Principle1",
    "text": "Principle1\n\nSimplicity\nThere is no perfect workflow that always generate satisfactory InSAR result, mostly due to decorrelation, strong atmospheric artifact and high deformation gradient. Different methods implemented in different packages need to be tried which is frustrating especially when the packages are over-encapsulated and no detailed documentations are provided. Furthermore, it brings more dirty work when users need to save intermediate data from one software and prepared them in a designated format and structure required by another software.\nDecorrelation defines simplicity as without complex data structure and over-encapsulation. Most data in Decorrelation is just the basic multi-dimentional array, i.e., NumPy array or CuPy array in memory, or Zarr on disk. Instead of providing a standard workflow as StamPS and MintPy, Decorrelation is designed as a collection of functions that implement specific InSAR processing techniques and data manipulation infrastructure.\n\n\nModernity\nDecorrelation strives to implement state-of-art InSAR techniques, including advanced PS/DS identification, phase linking and deep-learning-based methods.\nDecorrelation also emphasizes performance. Most Decorrelation functions are implemented with well-optimized GPU code or OpenMP code. Furthermore, with the support of Dask, Decorrelation can be runed on multi-GPUs to further accelerate the processing and get rid of the limitation of memory.\n\n\nPragmatism\nDecorrelation is a pragmatic library rather than an ideological workflow. The large number of functions in Decorrelation offer free and open source implementation for many InSAR techniques. Ultimately, workflow designs are made on a case-by-case basis by the user. We provide the necessary infrastructure and your role is to be innovative!\n\n\nUser centrality\nWhereas many InSAR packages attempt to be more user-friendly, Decorrelation has always been, and shall always remain user-centric. This package is intended to fill the needs of those contributing to it, rather than trying to appeal to as many users as possible. It is targeted at the proficient InSAR user, or anyone with a do-it-yourself attitude who is willing to read the documentation, and solve their own problems.\nAll users are encouraged to participate and contribute to this package. Reporting bugs and requesting new features by raising a Github issue is highly valued and bugs fixing, documentation improving and features implementation by make a Github pull request are very appreciated. Users can also freely ask questions, provide technical assistance to others or just exchange opinions in the discussions.",
    "crumbs": [
      "Decorrelation"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "Decorrelation",
    "section": "Install",
    "text": "Install\nBecause of GPU driver and CUDA Version Compatibility, there is no simple solution for CUDA related packages installation. Users need to successfully install cupy and dask_cuda first.\nHere is some tips for installing them. Generally, the cuda driver is alrealy installed and maintained by the system administrator. Users only need to determine the right cudatoolkit version. Frist run\nnvidia-smi\nIt will prints something like:\n...\n+-----------------------------------------------------------------------------+\n| NVIDIA-SMI 525.105.17   Driver Version: 525.105.17   CUDA Version: 12.0     |\n|-------------------------------+----------------------+----------------------+\n...\nThe CUDA Version is the maxminum cudatoolkit version that supported by the current CUDA driver. Here we use version 11.8 as an example. Then you can install the needed cudatoolkit, cupy, dask_cuda by:\nconda install -c \"nvidia/label/cuda-11.8.0\" cuda-toolkit\nconda install -c conda-forge cupy cuda-version=11.8\nconda install -c rapidsai -c conda-forge -c nvidia dask-cuda cuda-version=11.8\nThen\nWith conda:\nconda install -c conda-forge decorrelation\nOr with pip:\npip install decorrelation\nIn development mode:\ngit clone git@github.com:kanglcn/decorrelation.git ./decorrelation\ncd ./decorrelation\npip install -e '.[dev]'",
    "crumbs": [
      "Decorrelation"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "Decorrelation",
    "section": "How to use",
    "text": "How to use\nRead the software architecture for an overview of the software design. Refer to Tutorials for the examples. Refer to API and CLI for the detailed usage of every functions.",
    "crumbs": [
      "Decorrelation"
    ]
  },
  {
    "objectID": "index.html#contact-us",
    "href": "index.html#contact-us",
    "title": "Decorrelation",
    "section": "Contact us",
    "text": "Contact us\n\nMost discussion happens on GitHub. Feel free to open an issue or comment on any open issue or pull request.\nuse github discussions to ask questions or leave comments.",
    "crumbs": [
      "Decorrelation"
    ]
  },
  {
    "objectID": "index.html#general-guidelines-for-making-a-pull-request-pr2",
    "href": "index.html#general-guidelines-for-making-a-pull-request-pr2",
    "title": "Decorrelation",
    "section": "General Guidelines for Making a Pull Request (PR)2",
    "text": "General Guidelines for Making a Pull Request (PR)2\nWe follow the git pull request workflow to make changes to our codebase.\nBefore you make a PR, have a quick look at the titles of all the existing issues first. If there is already an issue that matches your PR, leave a comment there to let us know what you plan to do. Otherwise, open an issue describing what you want to do.\nWhat should be included in a PR\n\nEach pull request should consist of a small and logical collection of changes; larger changes should be broken down into smaller parts and integrated separately.\nBug fixes should be submitted in separate PRs.\n\nHow to write and submit a PR\n\nThis package is developed with the nbdev, a notebook-driven development platform. Developers should write or edit the notebooks rather than the .py files. After than, run nbdev_export to export the code in the notebooks to .py files and run nbdev_clean to clean the notebooks.\nThe github bot to generate docs do not support GPU, so all GPU related packages (dask_cuda) should be prevented in import cells and export cells. cupy v13 now allow import cupy on a cpu-only machine. So it can be used now.\nDescribe what your PR changes and why this is a good thing. Be as specific as you can. The PR description is how we keep track of the changes made to the project over time.\nDo not commit changes to files that are irrelevant to your feature or bugfix (e.g.: .gitignore, IDE project files, etc).\nWrite descriptive commit messages. Chris Beams has written a guide on how to write good commit messages.\n\nPR review\nBe willing to accept criticism and work on improving your code; we don’t want to break other users’ code, so care must be taken not to introduce bugs.\nBe aware that the pull request review process is not immediate, and is generally proportional to the size of the pull request.\n\nimport cupy as cp\n\n\ncp.array\n\n&lt;function cupy._creation.from_data.array(obj, dtype=None, copy=True, order='K', subok=False, ndmin=0, *, blocking=False)&gt;",
    "crumbs": [
      "Decorrelation"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Decorrelation",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe pronciples are modified from the principle of Arch Linux.↩︎\nthis is modified from the Contributers Guide of PyGMT.↩︎",
    "crumbs": [
      "Decorrelation"
    ]
  },
  {
    "objectID": "CLI/math.html",
    "href": "CLI/math.html",
    "title": "math",
    "section": "",
    "text": "import zarr\nimport numpy as np\nfrom decorrelation.cli.utils.logging import get_logger\n\n\nsource\n\nde_math\n\n de_math (output:str, operation:str, **data)\n\nBasic math manipulation. Only elementwise operations are supported. Only one output is supported.\n\n\n\n\nType\nDetails\n\n\n\n\noutput\nstr\npath to output\n\n\noperation\nstr\noperation\n\n\ndata\n\n\n\n\n\nThis function is based on Numexpr. All operators and functions supported inNumexpr are supported except reduction operations.\nUsage:\n\na = np.random.rand(100,100).astype(np.float32)\nb = np.random.rand(100,100).astype(np.float32)\na_zarr = zarr.open('./math/a.zarr','w',shape=a.shape,dtype=a.dtype,chunks=(10,10))\nb_zarr = zarr.open('./math/b.zarr','w',shape=b.shape,dtype=b.dtype,chunks=(10,10))\na_zarr[:] = a; b_zarr[:] = b\n\n\nlogger = get_logger()\n\n\nde_math('./math/c.zarr','sin(a)*exp(b)/2',a='./math/a.zarr',b = './math/b.zarr')\n\n2023-11-01 18:01:47 - logging_args - INFO - fetching args:\n2023-11-01 18:01:47 - logging_args - INFO - output = './math/c.zarr'\n2023-11-01 18:01:47 - logging_args - INFO - operation = 'sin(a)*exp(b)/2'\n2023-11-01 18:01:47 - logging_args - INFO - data = {'a': './math/a.zarr', 'b': './math/b.zarr'}\n2023-11-01 18:01:47 - logging_args - INFO - fetching args done.\n2023-11-01 18:01:47 - zarr_info - INFO - a zarray shape: (100, 100)\n2023-11-01 18:01:47 - zarr_info - INFO - a zarray chunks: (10, 10)\n2023-11-01 18:01:47 - zarr_info - INFO - a zarray dtype: float32\n2023-11-01 18:01:47 - zarr_info - INFO - b zarray shape: (100, 100)\n2023-11-01 18:01:47 - zarr_info - INFO - b zarray chunks: (10, 10)\n2023-11-01 18:01:47 - zarr_info - INFO - b zarray dtype: float32\n2023-11-01 18:01:47 - de_math - INFO - starting dask local cluster.\n2023-11-01 18:01:52 - de_math - INFO - dask local cluster started.\n2023-11-01 18:01:52 - darr_info - INFO - a dask array shape: (100, 100)\n2023-11-01 18:01:52 - darr_info - INFO - a dask array chunksize: (10, 10)\n2023-11-01 18:01:52 - darr_info - INFO - a dask array dtype: float32\n2023-11-01 18:01:52 - darr_info - INFO - b dask array shape: (100, 100)\n2023-11-01 18:01:52 - darr_info - INFO - b dask array chunksize: (10, 10)\n2023-11-01 18:01:52 - darr_info - INFO - b dask array dtype: float32\n2023-11-01 18:01:52 - de_math - INFO - computing graph setted. doing all the computing.\n2023-11-01 18:01:53 - de_math - INFO - computing finished.d |  1.2s\n2023-11-01 18:01:54 - de_math - INFO - dask cluster closed.\n\n\n\nc = zarr.open('./math/c.zarr','r')[:]\nnp.testing.assert_array_almost_equal(c,np.sin(a)*np.exp(b)/2)"
  },
  {
    "objectID": "CLI/utils/transform.html",
    "href": "CLI/utils/transform.html",
    "title": "transform",
    "section": "",
    "text": "import numpy as np\nfrom matplotlib import pyplot as plt\nfrom decorrelation.cli.utils.logging import get_logger\n\n\nsource\n\ntransform\n\n transform (xx_in, yy_in, epsg_in=4326, epsg_out=3857, n_worker=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nxx_in\n\n\ninput x coordinate\n\n\nyy_in\n\n\ninput y coordinate\n\n\nepsg_in\nint\n4326\ninput epsg\n\n\nepsg_out\nint\n3857\noutput epsg\n\n\nn_worker\nNoneType\nNone\nnumber of worker, all cpus by default\n\n\n\n\nsource\n\n\nde_transform\n\n de_transform (xx_in, yy_in, xx_out, yy_out, epsg_in=4326, epsg_out=3857)\n\nCoordinate transformation. By default, the input should be longitude (xx_in) and latitude (yy_in) (in degree) and outputs are x (east) and y (south) coordinate in web mercator projection (for plot with google earth map). The chunks, shape and dtype of output are same as xx_in.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nxx_in\n\n\ninput x coordinate\n\n\nyy_in\n\n\ninput y coordinate\n\n\nxx_out\n\n\noutput x coordinate\n\n\nyy_out\n\n\noutput y coordinate\n\n\nepsg_in\nint\n4326\ninput epsg\n\n\nepsg_out\nint\n3857\noutput epsg\n\n\n\nUsage:\n\nlon_ = './transform/lon.zarr/'; lat_ = './transform/lat.zarr/'\ne_ = './transform/e.zarr'; n_ = './transform/n.zarr'\nlogger = get_logger()\n\n\nde_transform(lon_,lat_,e_,n_)\n\n2023-11-05 23:31:51 - logging_args - INFO - running function: de_transform\n2023-11-05 23:31:51 - logging_args - INFO - fetching args:\n2023-11-05 23:31:51 - logging_args - INFO - xx_in = './transform/lon.zarr/'\n2023-11-05 23:31:51 - logging_args - INFO - yy_in = './transform/lat.zarr/'\n2023-11-05 23:31:51 - logging_args - INFO - xx_out = './transform/e.zarr'\n2023-11-05 23:31:51 - logging_args - INFO - yy_out = './transform/n.zarr'\n2023-11-05 23:31:51 - logging_args - INFO - epsg_in = 4326\n2023-11-05 23:31:51 - logging_args - INFO - epsg_out = 3857\n2023-11-05 23:31:51 - logging_args - INFO - fetching args done.\n2023-11-05 23:31:51 - de_transform - INFO - input EPSG: 4326.\n2023-11-05 23:31:51 - zarr_info - INFO - xx_in zarray shape: (2500, 1834)\n2023-11-05 23:31:51 - zarr_info - INFO - xx_in zarray chunks: (1000, 1834)\n2023-11-05 23:31:51 - zarr_info - INFO - xx_in zarray dtype: float64\n2023-11-05 23:31:51 - zarr_info - INFO - yy_in zarray shape: (2500, 1834)\n2023-11-05 23:31:51 - zarr_info - INFO - yy_in zarray chunks: (1000, 1834)\n2023-11-05 23:31:51 - zarr_info - INFO - yy_in zarray dtype: float64\n2023-11-05 23:31:51 - de_transform - INFO - output EPSG: 3857.\n2023-11-05 23:31:51 - de_transform - INFO - do the transformation.\n2023-11-05 23:31:52 - de_transform - INFO - write output.\n2023-11-05 23:31:52 - de_transform - INFO - write done.\n\n\n\nlon = zarr.open(lon_,mode='r')[:]\nlat = zarr.open(lat_,mode='r')[:]\nlon[lon==0] = np.nan\nlat[lat==0] = np.nan\n\n\nfig,axes = plt.subplots(1,2,figsize=(11,5))\nim0 = axes[0].imshow(lon)\naxes[0].set_title('Longitude')\nfig.colorbar(im0, ax=axes[0])\nim1 = axes[1].imshow(lat)\naxes[1].set_title('Latitude')\nfig.colorbar(im1, ax=axes[1])\nfig.show()\n\n\n\n\n\n\n\n\n\ne = zarr.open(e_,mode='r')[:]\nn = zarr.open(n_,mode='r')[:]\ne[e==0] = np.nan\nn[n==0] = np.nan\n\n\nfig,axes = plt.subplots(1,2,figsize=(11,5))\nim0 = axes[0].imshow(e)\naxes[0].set_title('E')\nfig.colorbar(im0, ax=axes[0])\nim1 = axes[1].imshow(n)\naxes[1].set_title('N')\nfig.colorbar(im1, ax=axes[1])\nfig.show()"
  },
  {
    "objectID": "CLI/utils/dask.html",
    "href": "CLI/utils/dask.html",
    "title": "dask",
    "section": "",
    "text": "source\n\npad_internal\n\n pad_internal (arr:&lt;function array&gt;, depth:dict=None)\n\nPad zero between block boundaries, currently only pad zero are supported\n\nsource\n\n\nget_cuda_cluster_arg\n\n get_cuda_cluster_arg ()"
  },
  {
    "objectID": "CLI/co.html",
    "href": "CLI/co.html",
    "title": "co",
    "section": "",
    "text": "from matplotlib import pyplot as plt\nimport zarr\nimport colorcet\nfrom decorrelation.cli.utils.logging import get_logger\n\n\nsource\n\nde_emperical_co_pc\n\n de_emperical_co_pc (rslc:str, is_shp:str, idx:str, coh:str, coh_ave:str,\n                     az_chunk_size:int=None, n_pc_chunk:int=None,\n                     pc_chunk_size:int=None)\n\nestimate emperical coherence matrix on point cloud data. Due to the data locality problem. r_chunk_size for the processing have to be one. Only one of n_pc_chunk and pc_chunk_size needs to be setted. The other one is automatically determined. If all of them are not setted, the n_pc_chunk will be setted as the number of azimuth chunks.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc\nstr\n\ninput: rslc stack\n\n\nis_shp\nstr\n\ninput: bool array indicating the SHPs of pc\n\n\nidx\nstr\n\ninput: bool array indicating pc\n\n\ncoh\nstr\n\noutput: complex coherence matrix for pc\n\n\ncoh_ave\nstr\n\noutput: average value of coherence matrix magnitude\n\n\naz_chunk_size\nint\nNone\nprocessing azimuth chunk size, optional. Default: the azimuth chunk size in rslc stack\n\n\nn_pc_chunk\nint\nNone\nnumber of point chunk, optional.\n\n\npc_chunk_size\nint\nNone\nchunk size of output zarr dataset, optional. Default: same as is_shp\n\n\n\n\nrslc = './raw/rslc.zarr'\nds_can_is_shp = './shp/ds_can_is_shp.zarr'\nds_can_idx = './shp/ds_can_idx.zarr'\nds_can_coh = './co/ds_can_coh.zarr'\nds_can_coh_ave = './co/ds_can_coh_ave.zarr'\naz_chunk_size = 1000\nr_chunk_size = 1000\n\n\nlogger = get_logger()\n\n\nde_emperical_co_pc(rslc,ds_can_is_shp,ds_can_idx,ds_can_coh,ds_can_coh_ave)\n\n2023-11-05 03:12:04 - logging_args - INFO - running function: de_emperical_co_pc\n2023-11-05 03:12:04 - logging_args - INFO - fetching args:\n2023-11-05 03:12:04 - logging_args - INFO - rslc = './raw/rslc.zarr'\n2023-11-05 03:12:04 - logging_args - INFO - is_shp = './shp/ds_can_is_shp.zarr'\n2023-11-05 03:12:04 - logging_args - INFO - idx = './shp/ds_can_idx.zarr'\n2023-11-05 03:12:04 - logging_args - INFO - coh = './co/ds_can_coh.zarr'\n2023-11-05 03:12:04 - logging_args - INFO - coh_ave = './co/ds_can_coh_ave.zarr'\n2023-11-05 03:12:04 - logging_args - INFO - az_chunk_size = None\n2023-11-05 03:12:04 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 03:12:04 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 03:12:04 - logging_args - INFO - fetching args done.\n2023-11-05 03:12:04 - zarr_info - INFO - ./raw/rslc.zarr zarray shape: (2500, 1834, 17)\n2023-11-05 03:12:04 - zarr_info - INFO - ./raw/rslc.zarr zarray chunks: (1000, 1000, 1)\n2023-11-05 03:12:04 - zarr_info - INFO - ./raw/rslc.zarr zarray dtype: complex64\n2023-11-05 03:12:04 - zarr_info - INFO - ./shp/ds_can_is_shp.zarr zarray shape: (740397, 11, 11)\n2023-11-05 03:12:04 - zarr_info - INFO - ./shp/ds_can_is_shp.zarr zarray chunks: (123400, 1, 1)\n2023-11-05 03:12:04 - zarr_info - INFO - ./shp/ds_can_is_shp.zarr zarray dtype: bool\n2023-11-05 03:12:04 - zarr_info - INFO - ./shp/ds_can_idx.zarr zarray shape: (2, 740397)\n2023-11-05 03:12:04 - zarr_info - INFO - ./shp/ds_can_idx.zarr zarray chunks: (2, 123400)\n2023-11-05 03:12:04 - zarr_info - INFO - ./shp/ds_can_idx.zarr zarray dtype: int32\n2023-11-05 03:12:04 - de_emperical_co_pc - INFO - loading idx into memory.\n2023-11-05 03:12:04 - de_emperical_co_pc - INFO - got azimuth window size and half azimuth window size\n    from is_shp shape: 11, 5\n2023-11-05 03:12:04 - de_emperical_co_pc - INFO - got range window size and half range window size\n    from is_shp shape: 11, 5\n2023-11-05 03:12:04 - de_emperical_co_pc - INFO - parallel processing azimuth chunk size: 1000\n2023-11-05 03:12:04 - de_emperical_co_pc - INFO - parallel processing range chunk size: 1.\n2023-11-05 03:12:04 - de_emperical_co_pc - INFO - number of point in each chunk: (346329, 274921, 119147)\n2023-11-05 03:12:04 - de_emperical_co_pc - INFO - starting dask CUDA local cluster.\n2023-11-05 03:12:11 - de_emperical_co_pc - INFO - dask local CUDA cluster started.\n2023-11-05 03:12:11 - darr_info - INFO - is_shp dask array shape: (740397, 11, 11)\n2023-11-05 03:12:11 - darr_info - INFO - is_shp dask array chunksize: (346329, 11, 11)\n2023-11-05 03:12:11 - darr_info - INFO - is_shp dask array dtype: bool\n2023-11-05 03:12:11 - darr_info - INFO - rslc dask array shape: (2500, 1834, 17)\n2023-11-05 03:12:11 - darr_info - INFO - rslc dask array chunksize: (1000, 1834, 17)\n2023-11-05 03:12:11 - darr_info - INFO - rslc dask array dtype: complex64\n2023-11-05 03:12:11 - de_emperical_co_pc - INFO - setting shared boundaries between rlsc chunks.\n2023-11-05 03:12:11 - darr_info - INFO - rslc_overlap dask array shape: (2520, 1834, 17)\n2023-11-05 03:12:11 - darr_info - INFO - rslc_overlap dask array chunksize: (1010, 1834, 17)\n2023-11-05 03:12:11 - darr_info - INFO - rslc_overlap dask array dtype: complex64\n2023-11-05 03:12:11 - de_emperical_co_pc - INFO - estimating coherence matrix.\n2023-11-05 03:12:11 - de_emperical_co_pc - INFO - get coherence matrix.\n2023-11-05 03:12:11 - darr_info - INFO - coh dask array shape: (740397, 17, 17)\n2023-11-05 03:12:11 - darr_info - INFO - coh dask array chunksize: (346329, 17, 17)\n2023-11-05 03:12:11 - darr_info - INFO - coh dask array dtype: complex64\n2023-11-05 03:12:11 - get_pc_chunk_size_from_pc_chunk_size - INFO - automatically determine pc_chunk_size from\n            pc_chunk_size of is_pc.\n2023-11-05 03:12:11 - get_pc_chunk_size_from_pc_chunk_size - INFO - pc_chunk_size for coh: 123400\n2023-11-05 03:12:11 - de_emperical_co_pc - INFO - rechunking coh to chunk size (for saving with zarr): (123400, 1, 1)\n2023-11-05 03:12:11 - darr_info - INFO - coh dask array shape: (740397, 17, 17)\n2023-11-05 03:12:11 - darr_info - INFO - coh dask array chunksize: (123400, 1, 1)\n2023-11-05 03:12:11 - darr_info - INFO - coh dask array dtype: complex64\n2023-11-05 03:12:11 - de_emperical_co_pc - INFO - get average coherence matrix magnitude.\n2023-11-05 03:12:11 - darr_info - INFO - coh_ave dask array shape: (17, 17)\n2023-11-05 03:12:11 - darr_info - INFO - coh_ave dask array chunksize: (17, 17)\n2023-11-05 03:12:11 - darr_info - INFO - coh_ave dask array dtype: float32\n2023-11-05 03:12:11 - de_emperical_co_pc - INFO - saving coh and coh_ave.\n2023-11-05 03:12:12 - de_emperical_co_pc - INFO - computing graph setted. doing all the computing.\n2023-11-05 03:12:24 - de_emperical_co_pc - INFO - computing finished.2K\n2023-11-05 03:12:26 - de_emperical_co_pc - INFO - dask cluster closed.\nCPU times: user 5.32 s, sys: 2.12 s, total: 7.44 s\nWall time: 21.3 s\n\n\n\nds_can_coh_ave_zarr = zarr.open(ds_can_coh_ave,'r')\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(ds_can_coh_ave_zarr[:],cmap=colorcet.cm.fire)\nax.set(title='Average coherence matrix',xlabel='Image Index',ylabel='Image Index')\nfig.colorbar(pcm)\nfig.show()",
    "crumbs": [
      "CLI",
      "co"
    ]
  },
  {
    "objectID": "CLI/pc.html",
    "href": "CLI/pc.html",
    "title": "pc",
    "section": "",
    "text": "import zarr\nimport numpy as np\nfrom decorrelation.cli.utils.logging import get_logger\n\n\nsource\n\nde_idx2bool\n\n de_idx2bool (idx:str, is_pc:str, shape:tuple, az_chunk_size:int=None,\n              n_az_chunk:int=None, r_chunk_size:int=None,\n              n_r_chunk:int=None)\n\nConvert pc index to bool 2d array\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx\nstr\n\npoint cloud index\n\n\nis_pc\nstr\n\noutput, output bool array\n\n\nshape\ntuple\n\nshape of one image (nlines,width)\n\n\naz_chunk_size\nint\nNone\noutput azimuth chunk size,\n\n\nn_az_chunk\nint\nNone\n# output number of azimuth chunks\n\n\nr_chunk_size\nint\nNone\noutput range chunk size\n\n\nn_r_chunk\nint\nNone\noutput number of range chunks\n\n\n\n\nsource\n\n\nde_bool2idx\n\n de_bool2idx (is_pc:str, idx:str, pc_chunk_size:int=None,\n              n_pc_chunk:int=None)\n\nConvert bool 2d array to integer index\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nis_pc\nstr\n\ninput bool array\n\n\nidx\nstr\n\noutput, point cloud index\n\n\npc_chunk_size\nint\nNone\noutput point chunk size\n\n\nn_pc_chunk\nint\nNone\noutput number of chunk\n\n\n\n\nsource\n\n\nde_ras2pc\n\n de_ras2pc (idx:str, ras:str|list, pc:str|list, pc_chunk_size:int=None,\n            n_pc_chunk:int=None, hd_chunk_size:tuple|list=None)\n\nConvert raster data to point cloud data\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx\nstr\n\npoint cloud index\n\n\nras\nstr | list\n\npath (in string) or list of path for raster data\n\n\npc\nstr | list\n\noutput, path (in string) or list of path for point cloud data\n\n\npc_chunk_size\nint\nNone\noutput point chunk size\n\n\nn_pc_chunk\nint\nNone\noutput number of chunk\n\n\nhd_chunk_size\ntuple | list\nNone\noutput high dimension chunk size, tuple or list of tuple, same as input raster data by default\n\n\n\nUsage:\n\nlogger = get_logger()\n\n\nras_data1 = np.random.rand(100,100).astype(np.float32)\nras_data2 = np.random.rand(100,100,3).astype(np.float32)+1j*np.random.rand(100,100,3).astype(np.float32)\n\nidx = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\nidx.sort()\nidx = np.stack(np.unravel_index(idx,shape=(100,100))).astype(np.int32)\n\npc_data1 = ras_data1[idx[0],idx[1]]\npc_data2 = ras_data2[idx[0],idx[1]]\n\nidx_zarr = zarr.open('pc/idx.zarr','w',shape=idx.shape,dtype=idx.dtype,chunks=(2,200))\nras_zarr1 = zarr.open('pc/ras1.zarr','w',shape=ras_data1.shape,dtype=ras_data1.dtype,chunks=(20,100))\nras_zarr2 = zarr.open('pc/ras2.zarr','w',shape=ras_data2.shape,dtype=ras_data2.dtype,chunks=(20,100,1))\nidx_zarr[:] = idx\nras_zarr1[:] = ras_data1\nras_zarr2[:] = ras_data2\n\n\nde_ras2pc('pc/idx.zarr','pc/ras1.zarr','pc/pc1.zarr')\npc_zarr1 = zarr.open('pc/pc1.zarr','r')\nnp.testing.assert_array_equal(pc_data1,pc_zarr1[:])\n\nde_ras2pc('pc/idx.zarr',ras=['pc/ras1.zarr','pc/ras2.zarr'],pc=['pc/pc1.zarr','pc/pc2.zarr'],hd_chunk_size=[(),(1,)])\npc_zarr1 = zarr.open('pc/pc1.zarr','r')\npc_zarr2 = zarr.open('pc/pc2.zarr','r')\nnp.testing.assert_array_equal(pc_data1,pc_zarr1[:])\nnp.testing.assert_array_equal(pc_data2,pc_zarr2[:])\n\n2023-11-05 02:45:19 - logging_args - INFO - running function: de_ras2pc\n2023-11-05 02:45:19 - logging_args - INFO - fetching args:\n2023-11-05 02:45:19 - logging_args - INFO - idx = 'pc/idx.zarr'\n2023-11-05 02:45:19 - logging_args - INFO - ras = 'pc/ras1.zarr'\n2023-11-05 02:45:19 - logging_args - INFO - pc = 'pc/pc1.zarr'\n2023-11-05 02:45:19 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 02:45:19 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 02:45:19 - logging_args - INFO - hd_chunk_size = None\n2023-11-05 02:45:19 - logging_args - INFO - fetching args done.\n2023-11-05 02:45:19 - zarr_info - INFO - pc/idx.zarr zarray shape: (2, 1000)\n2023-11-05 02:45:19 - zarr_info - INFO - pc/idx.zarr zarray chunks: (2, 200)\n2023-11-05 02:45:19 - zarr_info - INFO - pc/idx.zarr zarray dtype: int32\n2023-11-05 02:45:19 - get_pc_chunk_size_from_pc_chunk_size - INFO - automatically determine pc_chunk_size from\n            pc_chunk_size of idx.\n2023-11-05 02:45:19 - get_pc_chunk_size_from_pc_chunk_size - INFO - pc_chunk_size for pc: 200\n2023-11-05 02:45:19 - de_ras2pc - INFO - loading idx into memory.\n2023-11-05 02:45:19 - de_ras2pc - INFO - starting dask local cluster.\n2023-11-05 02:45:24 - de_ras2pc - INFO - dask local cluster started.\n2023-11-05 02:45:24 - de_ras2pc - INFO - start to slice on pc/ras1.zarr\n2023-11-05 02:45:24 - zarr_info - INFO - pc/ras1.zarr zarray shape: (100, 100)\n2023-11-05 02:45:24 - zarr_info - INFO - pc/ras1.zarr zarray chunks: (20, 100)\n2023-11-05 02:45:24 - zarr_info - INFO - pc/ras1.zarr zarray dtype: float32\n2023-11-05 02:45:24 - de_ras2pc - INFO - hd_chunk_size not setted. Use the one from pc/ras1.zarr.\n2023-11-05 02:45:24 - de_ras2pc - INFO - hd_chunk_size: ().\n2023-11-05 02:45:24 - darr_info - INFO - ras dask array shape: (100, 100)\n2023-11-05 02:45:24 - darr_info - INFO - ras dask array chunksize: (20, 100)\n2023-11-05 02:45:24 - darr_info - INFO - ras dask array dtype: float32\n2023-11-05 02:45:24 - darr_info - INFO - pc dask array shape: (1000,)\n2023-11-05 02:45:24 - darr_info - INFO - pc dask array chunksize: (223,)\n2023-11-05 02:45:24 - darr_info - INFO - pc dask array dtype: float32\n2023-11-05 02:45:24 - de_ras2pc - INFO - rechunk pc data:\n2023-11-05 02:45:24 - darr_info - INFO - pc dask array shape: (1000,)\n2023-11-05 02:45:24 - darr_info - INFO - pc dask array chunksize: (200,)\n2023-11-05 02:45:24 - darr_info - INFO - pc dask array dtype: float32\n2023-11-05 02:45:24 - de_ras2pc - INFO - saving to pc/pc1.zarr.\n2023-11-05 02:45:24 - de_ras2pc - INFO - computing graph setted. doing all the computing.\n2023-11-05 02:45:24 - de_ras2pc - INFO - computing finished.|  0.6s\n2023-11-05 02:45:25 - de_ras2pc - INFO - dask cluster closed.\n2023-11-05 02:45:25 - logging_args - INFO - running function: de_ras2pc\n2023-11-05 02:45:25 - logging_args - INFO - fetching args:\n2023-11-05 02:45:25 - logging_args - INFO - idx = 'pc/idx.zarr'\n2023-11-05 02:45:25 - logging_args - INFO - ras = ['pc/ras1.zarr', 'pc/ras2.zarr']\n2023-11-05 02:45:25 - logging_args - INFO - pc = ['pc/pc1.zarr', 'pc/pc2.zarr']\n2023-11-05 02:45:25 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 02:45:25 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 02:45:25 - logging_args - INFO - hd_chunk_size = [(), (1,)]\n2023-11-05 02:45:25 - logging_args - INFO - fetching args done.\n2023-11-05 02:45:25 - zarr_info - INFO - pc/idx.zarr zarray shape: (2, 1000)\n2023-11-05 02:45:25 - zarr_info - INFO - pc/idx.zarr zarray chunks: (2, 200)\n2023-11-05 02:45:25 - zarr_info - INFO - pc/idx.zarr zarray dtype: int32\n2023-11-05 02:45:25 - get_pc_chunk_size_from_pc_chunk_size - INFO - automatically determine pc_chunk_size from\n            pc_chunk_size of idx.\n2023-11-05 02:45:25 - get_pc_chunk_size_from_pc_chunk_size - INFO - pc_chunk_size for pc: 200\n2023-11-05 02:45:25 - de_ras2pc - INFO - loading idx into memory.\n2023-11-05 02:45:25 - de_ras2pc - INFO - starting dask local cluster.\n2023-11-05 02:45:29 - de_ras2pc - INFO - dask local cluster started.\n2023-11-05 02:45:29 - de_ras2pc - INFO - start to slice on pc/ras1.zarr\n2023-11-05 02:45:29 - zarr_info - INFO - pc/ras1.zarr zarray shape: (100, 100)\n2023-11-05 02:45:29 - zarr_info - INFO - pc/ras1.zarr zarray chunks: (20, 100)\n2023-11-05 02:45:29 - zarr_info - INFO - pc/ras1.zarr zarray dtype: float32\n2023-11-05 02:45:29 - de_ras2pc - INFO - hd_chunk_size: ().\n2023-11-05 02:45:29 - darr_info - INFO - ras dask array shape: (100, 100)\n2023-11-05 02:45:29 - darr_info - INFO - ras dask array chunksize: (20, 100)\n2023-11-05 02:45:29 - darr_info - INFO - ras dask array dtype: float32\n2023-11-05 02:45:29 - darr_info - INFO - pc dask array shape: (1000,)\n2023-11-05 02:45:29 - darr_info - INFO - pc dask array chunksize: (223,)\n2023-11-05 02:45:29 - darr_info - INFO - pc dask array dtype: float32\n2023-11-05 02:45:29 - de_ras2pc - INFO - rechunk pc data:\n2023-11-05 02:45:29 - darr_info - INFO - pc dask array shape: (1000,)\n2023-11-05 02:45:29 - darr_info - INFO - pc dask array chunksize: (200,)\n2023-11-05 02:45:29 - darr_info - INFO - pc dask array dtype: float32\n2023-11-05 02:45:29 - de_ras2pc - INFO - saving to pc/pc1.zarr.\n2023-11-05 02:45:29 - de_ras2pc - INFO - start to slice on pc/ras2.zarr\n2023-11-05 02:45:29 - zarr_info - INFO - pc/ras2.zarr zarray shape: (100, 100, 3)\n2023-11-05 02:45:29 - zarr_info - INFO - pc/ras2.zarr zarray chunks: (20, 100, 1)\n2023-11-05 02:45:29 - zarr_info - INFO - pc/ras2.zarr zarray dtype: complex64\n2023-11-05 02:45:29 - de_ras2pc - INFO - hd_chunk_size: (1,).\n2023-11-05 02:45:29 - darr_info - INFO - ras dask array shape: (100, 100, 3)\n2023-11-05 02:45:29 - darr_info - INFO - ras dask array chunksize: (20, 100, 1)\n2023-11-05 02:45:29 - darr_info - INFO - ras dask array dtype: complex64\n2023-11-05 02:45:29 - darr_info - INFO - pc dask array shape: (1000, 3)\n2023-11-05 02:45:29 - darr_info - INFO - pc dask array chunksize: (223, 1)\n2023-11-05 02:45:29 - darr_info - INFO - pc dask array dtype: complex64\n2023-11-05 02:45:29 - de_ras2pc - INFO - rechunk pc data:\n2023-11-05 02:45:29 - darr_info - INFO - pc dask array shape: (1000, 3)\n2023-11-05 02:45:29 - darr_info - INFO - pc dask array chunksize: (200, 1)\n2023-11-05 02:45:29 - darr_info - INFO - pc dask array dtype: complex64\n2023-11-05 02:45:29 - de_ras2pc - INFO - saving to pc/pc2.zarr.\n2023-11-05 02:45:29 - de_ras2pc - INFO - computing graph setted. doing all the computing.\n2023-11-05 02:45:30 - de_ras2pc - INFO - computing finished.|  1.1s\n2023-11-05 02:45:30 - de_ras2pc - INFO - dask cluster closed.\n\n\n\nsource\n\n\nde_pc2ras\n\n de_pc2ras (idx:str, pc:str|list, ras:str|list, shape:tuple,\n            az_chunk_size:int=None, n_az_chunk:int=None,\n            r_chunk_size:int=None, n_r_chunk:int=None)\n\nConvert point cloud data to raster data, filled with nan\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx\nstr\n\npoint cloud index\n\n\npc\nstr | list\n\npath (in string) or list of path for point cloud data\n\n\nras\nstr | list\n\noutput, path (in string) or list of path for raster data\n\n\nshape\ntuple\n\nshape of one image (nlines,width)\n\n\naz_chunk_size\nint\nNone\noutput azimuth chunk size,\n\n\nn_az_chunk\nint\nNone\n# output number of azimuth chunks\n\n\nr_chunk_size\nint\nNone\noutput range chunk size\n\n\nn_r_chunk\nint\nNone\noutput number of range chunks\n\n\n\nUsage:\n\npc_data1 = np.random.rand(1000).astype(np.float32)\npc_data2 = np.random.rand(1000,3).astype(np.float32)+1j*np.random.rand(1000,3).astype(np.float32)\n\nidx = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\nidx.sort()\nidx = np.stack(np.unravel_index(idx,shape=(100,100))).astype(np.int32)\n\nras_data1 = np.zeros((100,100),dtype=np.float32)\nras_data2 = np.zeros((100,100,3),dtype=np.complex64)\nras_data1[:] = np.nan\nras_data2[:] = np.nan\n\nras_data1[idx[0],idx[1]] = pc_data1\nras_data2[idx[0],idx[1]] = pc_data2\n\nidx_zarr = zarr.open('pc/idx.zarr','w',shape=idx.shape,dtype=idx.dtype,chunks=(2,200))\npc_zarr1 = zarr.open('pc/pc1.zarr','w',shape=pc_data1.shape,dtype=pc_data1.dtype,chunks=(200,))\npc_zarr2 = zarr.open('pc/pc2.zarr','w',shape=pc_data2.shape,dtype=pc_data2.dtype,chunks=(200,1))\nidx_zarr[:] = idx\npc_zarr1[:] = pc_data1\npc_zarr2[:] = pc_data2\n\n\nde_pc2ras('pc/idx.zarr','pc/pc1.zarr','pc/ras1.zarr',shape=(100,100),az_chunk_size=20)\nras_zarr1 = zarr.open('pc/ras1.zarr','r')\nnp.testing.assert_array_equal(ras_data1,ras_zarr1[:])\n\nde_pc2ras('pc/idx.zarr',['pc/pc1.zarr','pc/pc2.zarr'],['pc/ras1.zarr','pc/ras2.zarr'],shape=(100,100),az_chunk_size=20)\nras_zarr1 = zarr.open('pc/ras1.zarr','r')\nras_zarr2 = zarr.open('pc/ras2.zarr','r')\nnp.testing.assert_array_equal(ras_data1,ras_zarr1[:])\nnp.testing.assert_array_equal(ras_data2,ras_zarr2[:])\n\n2023-11-05 02:45:32 - logging_args - INFO - running function: de_pc2ras\n2023-11-05 02:45:32 - logging_args - INFO - fetching args:\n2023-11-05 02:45:32 - logging_args - INFO - idx = 'pc/idx.zarr'\n2023-11-05 02:45:32 - logging_args - INFO - pc = 'pc/pc1.zarr'\n2023-11-05 02:45:32 - logging_args - INFO - ras = 'pc/ras1.zarr'\n2023-11-05 02:45:32 - logging_args - INFO - shape = (100, 100)\n2023-11-05 02:45:32 - logging_args - INFO - az_chunk_size = 20\n2023-11-05 02:45:32 - logging_args - INFO - n_az_chunk = None\n2023-11-05 02:45:32 - logging_args - INFO - r_chunk_size = None\n2023-11-05 02:45:32 - logging_args - INFO - n_r_chunk = None\n2023-11-05 02:45:32 - logging_args - INFO - fetching args done.\n2023-11-05 02:45:32 - zarr_info - INFO - idx zarray shape: (2, 1000)\n2023-11-05 02:45:32 - zarr_info - INFO - idx zarray chunks: (2, 200)\n2023-11-05 02:45:32 - zarr_info - INFO - idx zarray dtype: int32\n2023-11-05 02:45:32 - get_ras_chunk_size_from_n_pc_chunk - INFO - automatically set r_chunk_size to nlines of ras\n2023-11-05 02:45:32 - get_ras_chunk_size_from_n_pc_chunk - INFO - got az_chunk_size for ras: 20\n2023-11-05 02:45:32 - de_pc2ras - INFO - loading idx into memory.\n2023-11-05 02:45:32 - de_pc2ras - INFO - starting dask local cluster.\n2023-11-05 02:45:36 - de_pc2ras - INFO - dask local cluster started.\n2023-11-05 02:45:36 - de_pc2ras - INFO - start to work on pc/pc1.zarr\n2023-11-05 02:45:36 - zarr_info - INFO - pc/pc1.zarr zarray shape: (1000,)\n2023-11-05 02:45:36 - zarr_info - INFO - pc/pc1.zarr zarray chunks: (200,)\n2023-11-05 02:45:36 - zarr_info - INFO - pc/pc1.zarr zarray dtype: float32\n2023-11-05 02:45:36 - darr_info - INFO - pc dask array shape: (1000,)\n2023-11-05 02:45:36 - darr_info - INFO - pc dask array chunksize: (200,)\n2023-11-05 02:45:36 - darr_info - INFO - pc dask array dtype: float32\n2023-11-05 02:45:36 - de_pc2ras - INFO - create ras dask array\n2023-11-05 02:45:36 - darr_info - INFO - ras dask array shape: (100, 100)\n2023-11-05 02:45:36 - darr_info - INFO - ras dask array chunksize: (20, 100)\n2023-11-05 02:45:36 - darr_info - INFO - ras dask array dtype: float32\n2023-11-05 02:45:36 - de_pc2ras - INFO - computing graph setted. doing all the computing.\n2023-11-05 02:45:37 - de_pc2ras - INFO - computing finished.|  0.9s\n2023-11-05 02:45:37 - de_pc2ras - INFO - dask cluster closed.\n2023-11-05 02:45:37 - logging_args - INFO - running function: de_pc2ras\n2023-11-05 02:45:37 - logging_args - INFO - fetching args:\n2023-11-05 02:45:37 - logging_args - INFO - idx = 'pc/idx.zarr'\n2023-11-05 02:45:37 - logging_args - INFO - pc = ['pc/pc1.zarr', 'pc/pc2.zarr']\n2023-11-05 02:45:37 - logging_args - INFO - ras = ['pc/ras1.zarr', 'pc/ras2.zarr']\n2023-11-05 02:45:37 - logging_args - INFO - shape = (100, 100)\n2023-11-05 02:45:37 - logging_args - INFO - az_chunk_size = 20\n2023-11-05 02:45:37 - logging_args - INFO - n_az_chunk = None\n2023-11-05 02:45:37 - logging_args - INFO - r_chunk_size = None\n2023-11-05 02:45:37 - logging_args - INFO - n_r_chunk = None\n2023-11-05 02:45:37 - logging_args - INFO - fetching args done.\n2023-11-05 02:45:37 - zarr_info - INFO - idx zarray shape: (2, 1000)\n2023-11-05 02:45:37 - zarr_info - INFO - idx zarray chunks: (2, 200)\n2023-11-05 02:45:37 - zarr_info - INFO - idx zarray dtype: int32\n2023-11-05 02:45:37 - get_ras_chunk_size_from_n_pc_chunk - INFO - automatically set r_chunk_size to nlines of ras\n2023-11-05 02:45:37 - get_ras_chunk_size_from_n_pc_chunk - INFO - got az_chunk_size for ras: 20\n2023-11-05 02:45:37 - de_pc2ras - INFO - loading idx into memory.\n2023-11-05 02:45:37 - de_pc2ras - INFO - starting dask local cluster.\n2023-11-05 02:45:40 - de_pc2ras - INFO - dask local cluster started.\n2023-11-05 02:45:40 - de_pc2ras - INFO - start to work on pc/pc1.zarr\n2023-11-05 02:45:40 - zarr_info - INFO - pc/pc1.zarr zarray shape: (1000,)\n2023-11-05 02:45:40 - zarr_info - INFO - pc/pc1.zarr zarray chunks: (200,)\n2023-11-05 02:45:40 - zarr_info - INFO - pc/pc1.zarr zarray dtype: float32\n2023-11-05 02:45:40 - darr_info - INFO - pc dask array shape: (1000,)\n2023-11-05 02:45:40 - darr_info - INFO - pc dask array chunksize: (200,)\n2023-11-05 02:45:40 - darr_info - INFO - pc dask array dtype: float32\n2023-11-05 02:45:40 - de_pc2ras - INFO - create ras dask array\n2023-11-05 02:45:40 - darr_info - INFO - ras dask array shape: (100, 100)\n2023-11-05 02:45:40 - darr_info - INFO - ras dask array chunksize: (20, 100)\n2023-11-05 02:45:40 - darr_info - INFO - ras dask array dtype: float32\n2023-11-05 02:45:40 - de_pc2ras - INFO - start to work on pc/pc2.zarr\n2023-11-05 02:45:40 - zarr_info - INFO - pc/pc2.zarr zarray shape: (1000, 3)\n2023-11-05 02:45:40 - zarr_info - INFO - pc/pc2.zarr zarray chunks: (200, 1)\n2023-11-05 02:45:40 - zarr_info - INFO - pc/pc2.zarr zarray dtype: complex64\n2023-11-05 02:45:40 - darr_info - INFO - pc dask array shape: (1000, 3)\n2023-11-05 02:45:40 - darr_info - INFO - pc dask array chunksize: (200, 1)\n2023-11-05 02:45:40 - darr_info - INFO - pc dask array dtype: complex64\n2023-11-05 02:45:40 - de_pc2ras - INFO - create ras dask array\n2023-11-05 02:45:40 - darr_info - INFO - ras dask array shape: (100, 100, 3)\n2023-11-05 02:45:40 - darr_info - INFO - ras dask array chunksize: (20, 100, 1)\n2023-11-05 02:45:40 - darr_info - INFO - ras dask array dtype: complex64\n2023-11-05 02:45:40 - de_pc2ras - INFO - computing graph setted. doing all the computing.\n2023-11-05 02:45:41 - de_pc2ras - INFO - computing finished.|  0.9s\n2023-11-05 02:45:42 - de_pc2ras - INFO - dask cluster closed.\n\n\n2023-11-05 02:45:37,146 - distributed.worker - ERROR - Unexpected exception during heartbeat. Closing worker.\nTraceback (most recent call last):\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/worker.py\", line 1253, in heartbeat\n    response = await retry_operation(\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 454, in retry_operation\n    return await retry(\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 433, in retry\n    return await coro()\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1344, in send_recv_from_rpc\n    comm = await self.pool.connect(self.addr)\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1543, in connect\n    raise RuntimeError(\"ConnectionPool is closed\")\nRuntimeError: ConnectionPool is closed\n2023-11-05 02:45:37,147 - tornado.application - ERROR - Exception in callback &lt;bound method Worker.heartbeat of &lt;Worker 'tcp://127.0.0.1:43929', name: 13, status: closed, stored: 0, running: 0/8, ready: 0, comm: 0, waiting: 0&gt;&gt;\nTraceback (most recent call last):\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/tornado/ioloop.py\", line 921, in _run\n    await val\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/worker.py\", line 1253, in heartbeat\n    response = await retry_operation(\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 454, in retry_operation\n    return await retry(\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 433, in retry\n    return await coro()\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1344, in send_recv_from_rpc\n    comm = await self.pool.connect(self.addr)\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1543, in connect\n    raise RuntimeError(\"ConnectionPool is closed\")\nRuntimeError: ConnectionPool is closed\n2023-11-05 02:45:37,149 - distributed.worker - ERROR - Unexpected exception during heartbeat. Closing worker.\nTraceback (most recent call last):\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/worker.py\", line 1253, in heartbeat\n    response = await retry_operation(\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 454, in retry_operation\n    return await retry(\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 433, in retry\n    return await coro()\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1344, in send_recv_from_rpc\n    comm = await self.pool.connect(self.addr)\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1543, in connect\n    raise RuntimeError(\"ConnectionPool is closed\")\nRuntimeError: ConnectionPool is closed\n2023-11-05 02:45:37,150 - tornado.application - ERROR - Exception in callback &lt;bound method Worker.heartbeat of &lt;Worker 'tcp://127.0.0.1:34629', name: 11, status: closed, stored: 0, running: 0/8, ready: 0, comm: 0, waiting: 0&gt;&gt;\nTraceback (most recent call last):\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/tornado/ioloop.py\", line 921, in _run\n    await val\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/worker.py\", line 1253, in heartbeat\n    response = await retry_operation(\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 454, in retry_operation\n    return await retry(\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 433, in retry\n    return await coro()\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1344, in send_recv_from_rpc\n    comm = await self.pool.connect(self.addr)\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1543, in connect\n    raise RuntimeError(\"ConnectionPool is closed\")\nRuntimeError: ConnectionPool is closed\n\n\n\nsource\n\n\nde_pc_union\n\n de_pc_union (idx1:str, idx2:str, idx:str, pc1:str|list=None,\n              pc2:str|list=None, pc:str|list=None, pc_chunk_size:int=None,\n              n_pc_chunk:int=None)\n\nGet the union of two point cloud dataset. For points at their intersection, pc_data1 rather than pc_data2 is copied to the result pc_data. pc_chunk_size and n_pc_chunk are used to determine the final pc_chunk_size. If non of them are provided, the pc_chunk_size is setted as it in idx1.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx1\nstr\n\nindex of the first point cloud\n\n\nidx2\nstr\n\nindex of the second point cloud\n\n\nidx\nstr\n\noutput, index of the union point cloud\n\n\npc1\nstr | list\nNone\npath (in string) or list of path for the first point cloud data\n\n\npc2\nstr | list\nNone\npath (in string) or list of path for the second point cloud data\n\n\npc\nstr | list\nNone\noutput, path (in string) or list of path for the union point cloud data\n\n\npc_chunk_size\nint\nNone\nchunk size in output data,optional\n\n\nn_pc_chunk\nint\nNone\nnumber of chunk in output data, optional\n\n\n\nUsage:\n\npc_data1 = np.random.rand(1000,3).astype(np.float32)+1j*np.random.rand(1000,3).astype(np.float32)\npc_data2 = np.random.rand(800,3).astype(np.float32)+1j*np.random.rand(800,3).astype(np.float32)\n\nidx1 = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\nidx1.sort()\nidx1 = np.stack(np.unravel_index(idx1,shape=(100,100))).astype(np.int32)\n\nidx2 = np.random.choice(np.arange(100*100,dtype=np.int32),size=800,replace=False)\nidx2.sort()\nidx2 = np.stack(np.unravel_index(idx2,shape=(100,100))).astype(np.int32)\n\nidx, inv_iidx1, inv_iidx2, iidx2 = pc_union(idx1,idx2)\n\npc_data = np.empty((idx.shape[1],*pc_data1.shape[1:]),dtype=pc_data1.dtype)\npc_data[inv_iidx1] = pc_data1\npc_data[inv_iidx2] = pc_data2[iidx2]\n\nidx1_zarr = zarr.open('pc/idx1.zarr','w',shape=idx1.shape,dtype=idx1.dtype,chunks=(2,200))\nidx2_zarr = zarr.open('pc/idx2.zarr','w',shape=idx2.shape,dtype=idx2.dtype,chunks=(2,200))\npc1_zarr = zarr.open('pc/pc1.zarr','w',shape=pc_data1.shape,dtype=pc_data1.dtype,chunks=(200,1))\npc2_zarr = zarr.open('pc/pc2.zarr','w',shape=pc_data2.shape,dtype=pc_data2.dtype,chunks=(200,1))\nidx1_zarr[:] = idx1\nidx2_zarr[:] = idx2\npc1_zarr[:] = pc_data1\npc2_zarr[:] = pc_data2\n\n\nde_pc_union('pc/idx1.zarr','pc/idx2.zarr','pc/idx.zarr')\nde_pc_union('pc/idx1.zarr','pc/idx2.zarr','pc/idx.zarr','pc/pc1.zarr','pc/pc2.zarr','pc/pc.zarr')\nidx_zarr = zarr.open('pc/idx.zarr','r')\npc_zarr = zarr.open('pc/pc.zarr','r')\nnp.testing.assert_array_equal(idx_zarr[:],idx)\nnp.testing.assert_array_equal(pc_zarr[:],pc_data)\n\n2023-11-05 02:45:44 - logging_args - INFO - running function: de_pc_union\n2023-11-05 02:45:44 - logging_args - INFO - fetching args:\n2023-11-05 02:45:44 - logging_args - INFO - idx1 = 'pc/idx1.zarr'\n2023-11-05 02:45:44 - logging_args - INFO - idx2 = 'pc/idx2.zarr'\n2023-11-05 02:45:44 - logging_args - INFO - idx = 'pc/idx.zarr'\n2023-11-05 02:45:44 - logging_args - INFO - pc1 = None\n2023-11-05 02:45:44 - logging_args - INFO - pc2 = None\n2023-11-05 02:45:44 - logging_args - INFO - pc = None\n2023-11-05 02:45:44 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 02:45:44 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 02:45:44 - logging_args - INFO - fetching args done.\n2023-11-05 02:45:44 - zarr_info - INFO - pc/idx1.zarr zarray shape: (2, 1000)\n2023-11-05 02:45:44 - zarr_info - INFO - pc/idx1.zarr zarray chunks: (2, 200)\n2023-11-05 02:45:44 - zarr_info - INFO - pc/idx1.zarr zarray dtype: int32\n2023-11-05 02:45:44 - zarr_info - INFO - pc/idx2.zarr zarray shape: (2, 800)\n2023-11-05 02:45:44 - zarr_info - INFO - pc/idx2.zarr zarray chunks: (2, 200)\n2023-11-05 02:45:44 - zarr_info - INFO - pc/idx2.zarr zarray dtype: int32\n2023-11-05 02:45:44 - de_pc_union - INFO - loading idx1 and idx2 into memory.\n2023-11-05 02:45:44 - de_pc_union - INFO - calculate the union\n2023-11-05 02:45:44 - de_pc_union - INFO - number of points in the union: 1711\n2023-11-05 02:45:44 - get_pc_chunk_size_from_pc_chunk_size - INFO - automatically determine pc_chunk_size from\n            pc_chunk_size of idx1.\n2023-11-05 02:45:44 - get_pc_chunk_size_from_pc_chunk_size - INFO - pc_chunk_size for idx: 200\n2023-11-05 02:45:44 - de_pc_union - INFO - write union idx\n2023-11-05 02:45:44 - de_pc_union - INFO - write done\n2023-11-05 02:45:44 - zarr_info - INFO - pc/idx.zarr zarray shape: (2, 1711)\n2023-11-05 02:45:44 - zarr_info - INFO - pc/idx.zarr zarray chunks: (2, 200)\n2023-11-05 02:45:44 - zarr_info - INFO - pc/idx.zarr zarray dtype: int32\n2023-11-05 02:45:44 - de_pc_union - INFO - no point cloud data provided, exit.\n2023-11-05 02:45:44 - logging_args - INFO - running function: de_pc_union\n2023-11-05 02:45:44 - logging_args - INFO - fetching args:\n2023-11-05 02:45:44 - logging_args - INFO - idx1 = 'pc/idx1.zarr'\n2023-11-05 02:45:44 - logging_args - INFO - idx2 = 'pc/idx2.zarr'\n2023-11-05 02:45:44 - logging_args - INFO - idx = 'pc/idx.zarr'\n2023-11-05 02:45:44 - logging_args - INFO - pc1 = 'pc/pc1.zarr'\n2023-11-05 02:45:44 - logging_args - INFO - pc2 = 'pc/pc2.zarr'\n2023-11-05 02:45:44 - logging_args - INFO - pc = 'pc/pc.zarr'\n2023-11-05 02:45:44 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 02:45:44 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 02:45:44 - logging_args - INFO - fetching args done.\n2023-11-05 02:45:44 - zarr_info - INFO - pc/idx1.zarr zarray shape: (2, 1000)\n2023-11-05 02:45:44 - zarr_info - INFO - pc/idx1.zarr zarray chunks: (2, 200)\n2023-11-05 02:45:44 - zarr_info - INFO - pc/idx1.zarr zarray dtype: int32\n2023-11-05 02:45:44 - zarr_info - INFO - pc/idx2.zarr zarray shape: (2, 800)\n2023-11-05 02:45:44 - zarr_info - INFO - pc/idx2.zarr zarray chunks: (2, 200)\n2023-11-05 02:45:44 - zarr_info - INFO - pc/idx2.zarr zarray dtype: int32\n2023-11-05 02:45:44 - de_pc_union - INFO - loading idx1 and idx2 into memory.\n2023-11-05 02:45:44 - de_pc_union - INFO - calculate the union\n2023-11-05 02:45:44 - de_pc_union - INFO - number of points in the union: 1711\n2023-11-05 02:45:44 - get_pc_chunk_size_from_pc_chunk_size - INFO - automatically determine pc_chunk_size from\n            pc_chunk_size of idx1.\n2023-11-05 02:45:44 - get_pc_chunk_size_from_pc_chunk_size - INFO - pc_chunk_size for idx: 200\n2023-11-05 02:45:44 - de_pc_union - INFO - write union idx\n2023-11-05 02:45:45 - de_pc_union - INFO - write done\n2023-11-05 02:45:45 - zarr_info - INFO - pc/idx.zarr zarray shape: (2, 1711)\n2023-11-05 02:45:45 - zarr_info - INFO - pc/idx.zarr zarray chunks: (2, 200)\n2023-11-05 02:45:45 - zarr_info - INFO - pc/idx.zarr zarray dtype: int32\n2023-11-05 02:45:45 - de_pc_union - INFO - starting dask local cluster.\n2023-11-05 02:45:48 - de_pc_union - INFO - dask local cluster started.\n2023-11-05 02:45:48 - zarr_info - INFO - pc/pc1.zarr zarray shape: (1000, 3)\n2023-11-05 02:45:48 - zarr_info - INFO - pc/pc1.zarr zarray chunks: (200, 1)\n2023-11-05 02:45:48 - zarr_info - INFO - pc/pc1.zarr zarray dtype: complex64\n2023-11-05 02:45:48 - zarr_info - INFO - pc/pc2.zarr zarray shape: (800, 3)\n2023-11-05 02:45:48 - zarr_info - INFO - pc/pc2.zarr zarray chunks: (200, 1)\n2023-11-05 02:45:48 - zarr_info - INFO - pc/pc2.zarr zarray dtype: complex64\n2023-11-05 02:45:48 - darr_info - INFO - pc1 dask array shape: (1000, 3)\n2023-11-05 02:45:48 - darr_info - INFO - pc1 dask array chunksize: (200, 1)\n2023-11-05 02:45:48 - darr_info - INFO - pc1 dask array dtype: complex64\n2023-11-05 02:45:48 - darr_info - INFO - pc2 dask array shape: (800, 3)\n2023-11-05 02:45:48 - darr_info - INFO - pc2 dask array chunksize: (200, 1)\n2023-11-05 02:45:48 - darr_info - INFO - pc2 dask array dtype: complex64\n2023-11-05 02:45:48 - de_pc_union - INFO - set up union pc data dask array.\n2023-11-05 02:45:48 - darr_info - INFO - pc dask array shape: (1711, 3)\n2023-11-05 02:45:48 - darr_info - INFO - pc dask array chunksize: (200, 1)\n2023-11-05 02:45:48 - darr_info - INFO - pc dask array dtype: complex64\n2023-11-05 02:45:48 - de_pc_union - INFO - computing graph setted. doing all the computing.\n2023-11-05 02:45:49 - de_pc_union - INFO - computing finished. 1.0s\n2023-11-05 02:45:49 - de_pc_union - INFO - dask cluster closed.\n\n\n\nsource\n\n\nde_pc_intersect\n\n de_pc_intersect (idx1:str, idx2:str, idx:str, pc1:str|list=None,\n                  pc2:str|list=None, pc:str|list=None,\n                  pc_chunk_size:int=None, n_pc_chunk:int=None,\n                  prefer_1=True)\n\nGet the intersection of two point cloud dataset. pc_chunk_size and n_pc_chunk are used to determine the final pc_chunk_size. If non of them are provided, the n_pc_chunk is set to n_chunk in idx1.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx1\nstr\n\nindex of the first point cloud\n\n\nidx2\nstr\n\nindex of the second point cloud\n\n\nidx\nstr\n\noutput, index of the union point cloud\n\n\npc1\nstr | list\nNone\npath (in string) or list of path for the first point cloud data\n\n\npc2\nstr | list\nNone\npath (in string) or list of path for the second point cloud data\n\n\npc\nstr | list\nNone\noutput, path (in string) or list of path for the union point cloud data\n\n\npc_chunk_size\nint\nNone\nchunk size in output data,optional\n\n\nn_pc_chunk\nint\nNone\nnumber of chunk in output data, optional\n\n\nprefer_1\nbool\nTrue\nsave pc1 on intersection to output pc dataset by default True. Otherwise, save data from pc2\n\n\n\nUsage:\n\npc_data1 = np.random.rand(1000,3).astype(np.float32)+1j*np.random.rand(1000,3).astype(np.float32)\npc_data2 = np.random.rand(800,3).astype(np.float32)+1j*np.random.rand(800,3).astype(np.float32)\n\nidx1 = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\nidx1.sort()\nidx1 = np.stack(np.unravel_index(idx1,shape=(100,100))).astype(np.int32)\n\nidx2 = np.random.choice(np.arange(100*100,dtype=np.int32),size=800,replace=False)\nidx2.sort()\nidx2 = np.stack(np.unravel_index(idx2,shape=(100,100))).astype(np.int32)\n\nidx, iidx1, iidx2 = pc_intersect(idx1,idx2)\n\npc_data = np.empty((idx.shape[1],*pc_data1.shape[1:]),dtype=pc_data1.dtype)\npc_data[:] = pc_data2[iidx2]\n\nidx1_zarr = zarr.open('pc/idx1.zarr','w',shape=idx1.shape,dtype=idx1.dtype,chunks=(2,200))\nidx2_zarr = zarr.open('pc/idx2.zarr','w',shape=idx2.shape,dtype=idx2.dtype,chunks=(2,200))\npc1_zarr = zarr.open('pc/pc1.zarr','w',shape=pc_data1.shape,dtype=pc_data1.dtype,chunks=(200,1))\npc2_zarr = zarr.open('pc/pc2.zarr','w',shape=pc_data2.shape,dtype=pc_data2.dtype,chunks=(200,1))\nidx1_zarr[:] = idx1\nidx2_zarr[:] = idx2\npc1_zarr[:] = pc_data1\npc2_zarr[:] = pc_data2\n\n\nde_pc_intersect('pc/idx1.zarr','pc/idx2.zarr','pc/idx.zarr')\nde_pc_intersect('pc/idx1.zarr','pc/idx2.zarr','pc/idx.zarr',pc2='pc/pc2.zarr', pc='pc/pc.zarr',prefer_1=False)\nidx_zarr = zarr.open('pc/idx.zarr','r')\npc_zarr = zarr.open('pc/pc.zarr','r')\nnp.testing.assert_array_equal(idx_zarr[:],idx)\nnp.testing.assert_array_equal(pc_zarr[:],pc_data)\n\n2023-11-05 02:45:51 - logging_args - INFO - running function: de_pc_intersect\n2023-11-05 02:45:51 - logging_args - INFO - fetching args:\n2023-11-05 02:45:51 - logging_args - INFO - idx1 = 'pc/idx1.zarr'\n2023-11-05 02:45:51 - logging_args - INFO - idx2 = 'pc/idx2.zarr'\n2023-11-05 02:45:51 - logging_args - INFO - idx = 'pc/idx.zarr'\n2023-11-05 02:45:51 - logging_args - INFO - pc1 = None\n2023-11-05 02:45:51 - logging_args - INFO - pc2 = None\n2023-11-05 02:45:51 - logging_args - INFO - pc = None\n2023-11-05 02:45:51 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 02:45:51 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 02:45:51 - logging_args - INFO - prefer_1 = True\n2023-11-05 02:45:51 - logging_args - INFO - fetching args done.\n2023-11-05 02:45:51 - zarr_info - INFO - pc/idx1.zarr zarray shape: (2, 1000)\n2023-11-05 02:45:51 - zarr_info - INFO - pc/idx1.zarr zarray chunks: (2, 200)\n2023-11-05 02:45:51 - zarr_info - INFO - pc/idx1.zarr zarray dtype: int32\n2023-11-05 02:45:51 - zarr_info - INFO - pc/idx2.zarr zarray shape: (2, 800)\n2023-11-05 02:45:51 - zarr_info - INFO - pc/idx2.zarr zarray chunks: (2, 200)\n2023-11-05 02:45:51 - zarr_info - INFO - pc/idx2.zarr zarray dtype: int32\n2023-11-05 02:45:51 - de_pc_intersect - INFO - loading idx1 and idx2 into memory.\n2023-11-05 02:45:51 - de_pc_intersect - INFO - calculate the intersection\n2023-11-05 02:45:51 - de_pc_intersect - INFO - number of points in the intersection: 82\n2023-11-05 02:45:51 - get_pc_chunk_size_from_n_pc_chunk - INFO - automatically determine pc_chunk_size from\n            n_pc of idx and n_pc_chunk of idx1\n2023-11-05 02:45:51 - get_pc_chunk_size_from_n_pc_chunk - INFO - pc_chunk_size for idx: 17\n2023-11-05 02:45:51 - de_pc_intersect - INFO - write intersect idx\n2023-11-05 02:45:51 - de_pc_intersect - INFO - write done\n2023-11-05 02:45:51 - zarr_info - INFO - pc/idx.zarr zarray shape: (2, 82)\n2023-11-05 02:45:51 - zarr_info - INFO - pc/idx.zarr zarray chunks: (2, 17)\n2023-11-05 02:45:51 - zarr_info - INFO - pc/idx.zarr zarray dtype: int32\n2023-11-05 02:45:51 - de_pc_intersect - INFO - no point cloud data provided, exit.\n2023-11-05 02:45:51 - logging_args - INFO - running function: de_pc_intersect\n2023-11-05 02:45:51 - logging_args - INFO - fetching args:\n2023-11-05 02:45:51 - logging_args - INFO - idx1 = 'pc/idx1.zarr'\n2023-11-05 02:45:51 - logging_args - INFO - idx2 = 'pc/idx2.zarr'\n2023-11-05 02:45:51 - logging_args - INFO - idx = 'pc/idx.zarr'\n2023-11-05 02:45:51 - logging_args - INFO - pc1 = None\n2023-11-05 02:45:51 - logging_args - INFO - pc2 = 'pc/pc2.zarr'\n2023-11-05 02:45:51 - logging_args - INFO - pc = 'pc/pc.zarr'\n2023-11-05 02:45:51 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 02:45:51 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 02:45:51 - logging_args - INFO - prefer_1 = False\n2023-11-05 02:45:51 - logging_args - INFO - fetching args done.\n2023-11-05 02:45:51 - zarr_info - INFO - pc/idx1.zarr zarray shape: (2, 1000)\n2023-11-05 02:45:51 - zarr_info - INFO - pc/idx1.zarr zarray chunks: (2, 200)\n2023-11-05 02:45:51 - zarr_info - INFO - pc/idx1.zarr zarray dtype: int32\n2023-11-05 02:45:51 - zarr_info - INFO - pc/idx2.zarr zarray shape: (2, 800)\n2023-11-05 02:45:51 - zarr_info - INFO - pc/idx2.zarr zarray chunks: (2, 200)\n2023-11-05 02:45:51 - zarr_info - INFO - pc/idx2.zarr zarray dtype: int32\n2023-11-05 02:45:51 - de_pc_intersect - INFO - loading idx1 and idx2 into memory.\n2023-11-05 02:45:51 - de_pc_intersect - INFO - calculate the intersection\n2023-11-05 02:45:51 - de_pc_intersect - INFO - number of points in the intersection: 82\n2023-11-05 02:45:51 - get_pc_chunk_size_from_n_pc_chunk - INFO - automatically determine pc_chunk_size from\n            n_pc of idx and n_pc_chunk of idx1\n2023-11-05 02:45:51 - get_pc_chunk_size_from_n_pc_chunk - INFO - pc_chunk_size for idx: 17\n2023-11-05 02:45:51 - de_pc_intersect - INFO - write intersect idx\n2023-11-05 02:45:51 - de_pc_intersect - INFO - write done\n2023-11-05 02:45:51 - zarr_info - INFO - pc/idx.zarr zarray shape: (2, 82)\n2023-11-05 02:45:51 - zarr_info - INFO - pc/idx.zarr zarray chunks: (2, 17)\n2023-11-05 02:45:51 - zarr_info - INFO - pc/idx.zarr zarray dtype: int32\n2023-11-05 02:45:51 - de_pc_intersect - INFO - select pc2 as pc_input.\n2023-11-05 02:45:51 - de_pc_intersect - INFO - starting dask local cluster.\n2023-11-05 02:45:55 - de_pc_intersect - INFO - dask local cluster started.\n2023-11-05 02:45:55 - zarr_info - INFO - pc/pc2.zarr zarray shape: (800, 3)\n2023-11-05 02:45:55 - zarr_info - INFO - pc/pc2.zarr zarray chunks: (200, 1)\n2023-11-05 02:45:55 - zarr_info - INFO - pc/pc2.zarr zarray dtype: complex64\n2023-11-05 02:45:55 - darr_info - INFO - pc_input dask array shape: (800, 3)\n2023-11-05 02:45:55 - darr_info - INFO - pc_input dask array chunksize: (200, 1)\n2023-11-05 02:45:55 - darr_info - INFO - pc_input dask array dtype: complex64\n2023-11-05 02:45:55 - de_pc_intersect - INFO - set up intersect pc data dask array.\n2023-11-05 02:45:55 - darr_info - INFO - pc dask array shape: (82, 3)\n2023-11-05 02:45:55 - darr_info - INFO - pc dask array chunksize: (17, 1)\n2023-11-05 02:45:55 - darr_info - INFO - pc dask array dtype: complex64\n2023-11-05 02:45:55 - de_pc_intersect - INFO - computing graph setted. doing all the computing.\n2023-11-05 02:45:56 - de_pc_intersect - INFO - computing finished.s\n2023-11-05 02:45:57 - de_pc_intersect - INFO - dask cluster closed.\n\n\n\nsource\n\n\nde_pc_diff\n\n de_pc_diff (idx1:str, idx2:str, idx:str, pc1:str|list=None,\n             pc:str|list=None, pc_chunk_size:int=None,\n             n_pc_chunk:int=None)\n\nGet the point cloud in idx1 that are not in idx2. pc_chunk_size and n_pc_chunk are used to determine the final pc_chunk_size. If non of them are provided, the n_pc_chunk is set to n_chunk in idx1.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx1\nstr\n\nindex of the first point cloud\n\n\nidx2\nstr\n\nindex of the second point cloud\n\n\nidx\nstr\n\noutput, index of the union point cloud\n\n\npc1\nstr | list\nNone\npath (in string) or list of path for the first point cloud data\n\n\npc\nstr | list\nNone\noutput, path (in string) or list of path for the union point cloud data\n\n\npc_chunk_size\nint\nNone\nchunk size in output data,optional\n\n\nn_pc_chunk\nint\nNone\nnumber of chunk in output data, optional\n\n\n\nUsage:\n\npc_data1 = np.random.rand(1000,3).astype(np.float32)+1j*np.random.rand(1000,3).astype(np.float32)\n\nidx1 = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\nidx1.sort()\nidx1 = np.stack(np.unravel_index(idx1,shape=(100,100))).astype(np.int32)\n\nidx2 = np.random.choice(np.arange(100*100,dtype=np.int32),size=800,replace=False)\nidx2.sort()\nidx2 = np.stack(np.unravel_index(idx2,shape=(100,100))).astype(np.int32)\n\nidx, iidx1 = pc_diff(idx1,idx2)\n\npc_data = np.empty((idx.shape[1],*pc_data1.shape[1:]),dtype=pc_data1.dtype)\npc_data[:] = pc_data1[iidx1]\n\nidx1_zarr = zarr.open('pc/idx1.zarr','w',shape=idx1.shape,dtype=idx1.dtype,chunks=(2,200))\nidx2_zarr = zarr.open('pc/idx2.zarr','w',shape=idx2.shape,dtype=idx2.dtype,chunks=(2,200))\npc1_zarr = zarr.open('pc/pc1.zarr','w',shape=pc_data1.shape,dtype=pc_data1.dtype,chunks=(200,1))\nidx1_zarr[:] = idx1\nidx2_zarr[:] = idx2\npc1_zarr[:] = pc_data1\n\n\nde_pc_diff('pc/idx1.zarr','pc/idx2.zarr','pc/idx.zarr')\nde_pc_diff('pc/idx1.zarr','pc/idx2.zarr','pc/idx.zarr',pc1='pc/pc1.zarr', pc='pc/pc.zarr')\nidx_zarr = zarr.open('pc/idx.zarr','r')\npc_zarr = zarr.open('pc/pc.zarr','r')\nnp.testing.assert_array_equal(idx_zarr[:],idx)\nnp.testing.assert_array_equal(pc_zarr[:],pc_data)\n\n2023-11-05 02:45:58 - logging_args - INFO - running function: de_pc_diff\n2023-11-05 02:45:58 - logging_args - INFO - fetching args:\n2023-11-05 02:45:58 - logging_args - INFO - idx1 = 'pc/idx1.zarr'\n2023-11-05 02:45:58 - logging_args - INFO - idx2 = 'pc/idx2.zarr'\n2023-11-05 02:45:58 - logging_args - INFO - idx = 'pc/idx.zarr'\n2023-11-05 02:45:58 - logging_args - INFO - pc1 = None\n2023-11-05 02:45:58 - logging_args - INFO - pc = None\n2023-11-05 02:45:58 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 02:45:58 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 02:45:58 - logging_args - INFO - fetching args done.\n2023-11-05 02:45:58 - zarr_info - INFO - pc/idx1.zarr zarray shape: (2, 1000)\n2023-11-05 02:45:58 - zarr_info - INFO - pc/idx1.zarr zarray chunks: (2, 200)\n2023-11-05 02:45:58 - zarr_info - INFO - pc/idx1.zarr zarray dtype: int32\n2023-11-05 02:45:58 - zarr_info - INFO - pc/idx2.zarr zarray shape: (2, 800)\n2023-11-05 02:45:58 - zarr_info - INFO - pc/idx2.zarr zarray chunks: (2, 200)\n2023-11-05 02:45:58 - zarr_info - INFO - pc/idx2.zarr zarray dtype: int32\n2023-11-05 02:45:58 - de_pc_diff - INFO - loading idx1 and idx2 into memory.\n2023-11-05 02:45:58 - de_pc_diff - INFO - calculate the diff.\n2023-11-05 02:45:58 - de_pc_diff - INFO - number of points in the diff: 916\n2023-11-05 02:45:58 - get_pc_chunk_size_from_n_pc_chunk - INFO - automatically determine pc_chunk_size from\n            n_pc of idx and n_pc_chunk of idx1\n2023-11-05 02:45:58 - get_pc_chunk_size_from_n_pc_chunk - INFO - pc_chunk_size for idx: 184\n2023-11-05 02:45:58 - de_pc_diff - INFO - write intersect idx\n2023-11-05 02:45:59 - de_pc_diff - INFO - write done\n2023-11-05 02:45:59 - zarr_info - INFO - pc/idx.zarr zarray shape: (2, 916)\n2023-11-05 02:45:59 - zarr_info - INFO - pc/idx.zarr zarray chunks: (2, 184)\n2023-11-05 02:45:59 - zarr_info - INFO - pc/idx.zarr zarray dtype: int32\n2023-11-05 02:45:59 - de_pc_diff - INFO - no point cloud data provided, exit.\n2023-11-05 02:45:59 - logging_args - INFO - running function: de_pc_diff\n2023-11-05 02:45:59 - logging_args - INFO - fetching args:\n2023-11-05 02:45:59 - logging_args - INFO - idx1 = 'pc/idx1.zarr'\n2023-11-05 02:45:59 - logging_args - INFO - idx2 = 'pc/idx2.zarr'\n2023-11-05 02:45:59 - logging_args - INFO - idx = 'pc/idx.zarr'\n2023-11-05 02:45:59 - logging_args - INFO - pc1 = 'pc/pc1.zarr'\n2023-11-05 02:45:59 - logging_args - INFO - pc = 'pc/pc.zarr'\n2023-11-05 02:45:59 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 02:45:59 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 02:45:59 - logging_args - INFO - fetching args done.\n2023-11-05 02:45:59 - zarr_info - INFO - pc/idx1.zarr zarray shape: (2, 1000)\n2023-11-05 02:45:59 - zarr_info - INFO - pc/idx1.zarr zarray chunks: (2, 200)\n2023-11-05 02:45:59 - zarr_info - INFO - pc/idx1.zarr zarray dtype: int32\n2023-11-05 02:45:59 - zarr_info - INFO - pc/idx2.zarr zarray shape: (2, 800)\n2023-11-05 02:45:59 - zarr_info - INFO - pc/idx2.zarr zarray chunks: (2, 200)\n2023-11-05 02:45:59 - zarr_info - INFO - pc/idx2.zarr zarray dtype: int32\n2023-11-05 02:45:59 - de_pc_diff - INFO - loading idx1 and idx2 into memory.\n2023-11-05 02:45:59 - de_pc_diff - INFO - calculate the diff.\n2023-11-05 02:45:59 - de_pc_diff - INFO - number of points in the diff: 916\n2023-11-05 02:45:59 - get_pc_chunk_size_from_n_pc_chunk - INFO - automatically determine pc_chunk_size from\n            n_pc of idx and n_pc_chunk of idx1\n2023-11-05 02:45:59 - get_pc_chunk_size_from_n_pc_chunk - INFO - pc_chunk_size for idx: 184\n2023-11-05 02:45:59 - de_pc_diff - INFO - write intersect idx\n2023-11-05 02:45:59 - de_pc_diff - INFO - write done\n2023-11-05 02:45:59 - zarr_info - INFO - pc/idx.zarr zarray shape: (2, 916)\n2023-11-05 02:45:59 - zarr_info - INFO - pc/idx.zarr zarray chunks: (2, 184)\n2023-11-05 02:45:59 - zarr_info - INFO - pc/idx.zarr zarray dtype: int32\n2023-11-05 02:45:59 - de_pc_diff - INFO - starting dask local cluster.\n2023-11-05 02:46:02 - de_pc_diff - INFO - dask local cluster started.\n2023-11-05 02:46:02 - zarr_info - INFO - pc/pc1.zarr zarray shape: (1000, 3)\n2023-11-05 02:46:02 - zarr_info - INFO - pc/pc1.zarr zarray chunks: (200, 1)\n2023-11-05 02:46:02 - zarr_info - INFO - pc/pc1.zarr zarray dtype: complex64\n2023-11-05 02:46:02 - darr_info - INFO - pc1 dask array shape: (1000, 3)\n2023-11-05 02:46:02 - darr_info - INFO - pc1 dask array chunksize: (200, 1)\n2023-11-05 02:46:02 - darr_info - INFO - pc1 dask array dtype: complex64\n2023-11-05 02:46:02 - de_pc_diff - INFO - set up diff pc data dask array.\n2023-11-05 02:46:02 - darr_info - INFO - pc dask array shape: (916, 3)\n2023-11-05 02:46:02 - darr_info - INFO - pc dask array chunksize: (184, 1)\n2023-11-05 02:46:02 - darr_info - INFO - pc dask array dtype: complex64\n2023-11-05 02:46:02 - de_pc_diff - INFO - computing graph setted. doing all the computing.\n2023-11-05 02:46:03 - de_pc_diff - INFO - computing finished.  1.0s\n2023-11-05 02:46:04 - de_pc_diff - INFO - dask cluster closed.\n\n\n\nsource\n\n\nde_pc_logic_ras\n\n de_pc_logic_ras (ras, idx, operation:str, pc_chunk_size:int=None,\n                  n_pc_chunk:int=None)\n\ngenerate point cloud index based on logical operation of one raster image.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nras\n\n\nthe raster image used for thresholding\n\n\nidx\n\n\noutput, index of selected pixels\n\n\noperation\nstr\n\nlogical operation on input ras\n\n\npc_chunk_size\nint\nNone\nchunk size in output data,optional\n\n\nn_pc_chunk\nint\nNone\nnumber of chunk in output data, optional\n\n\n\n\nras = np.random.rand(100,100).astype(np.float32)\nmin_thres = 0.1; max_thres=0.5\nis_pc = (ras&gt;=min_thres) & (ras&lt;=max_thres)\nidx = np.stack(np.where(is_pc)).astype(np.int32)\nras_zarr = zarr.open('pc/ras.zarr','rw',shape=ras.shape,dtype=ras.dtype,chunks=(10,100))\nras_zarr[:] = ras\n\n\nde_pc_logic_ras('pc/ras.zarr','pc/idx.zarr',f'(ras&gt;={min_thres})&(ras&lt;={max_thres})')\nidx_zarr = zarr.open('pc/idx.zarr','r')\nnp.testing.assert_array_equal(idx_zarr[:],idx)\n\n2023-11-05 02:46:05 - logging_args - INFO - running function: de_pc_logic_ras\n2023-11-05 02:46:05 - logging_args - INFO - fetching args:\n2023-11-05 02:46:05 - logging_args - INFO - ras = 'pc/ras.zarr'\n2023-11-05 02:46:05 - logging_args - INFO - idx = 'pc/idx.zarr'\n2023-11-05 02:46:05 - logging_args - INFO - operation = '(ras&gt;=0.1)&(ras&lt;=0.5)'\n2023-11-05 02:46:05 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 02:46:05 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 02:46:05 - logging_args - INFO - fetching args done.\n2023-11-05 02:46:05 - zarr_info - INFO - pc/ras.zarr zarray shape: (100, 100)\n2023-11-05 02:46:05 - zarr_info - INFO - pc/ras.zarr zarray chunks: (10, 100)\n2023-11-05 02:46:05 - zarr_info - INFO - pc/ras.zarr zarray dtype: float32\n2023-11-05 02:46:05 - de_pc_logic_ras - INFO - loading ras into memory.\n2023-11-05 02:46:05 - de_pc_logic_ras - INFO - select pc based on operation: (ras&gt;=0.1)&(ras&lt;=0.5)\n2023-11-05 02:46:05 - de_pc_logic_ras - INFO - number of selected pixels: 3990.\n2023-11-05 02:46:05 - get_pc_chunk_size_from_n_ras_chunk - INFO - automatically determine pc_chunk_size from\n            n_pc of idx and n_ras_chunk of ras\n2023-11-05 02:46:05 - get_pc_chunk_size_from_n_ras_chunk - INFO - n_ras_chunk of ras: 10\n2023-11-05 02:46:05 - get_pc_chunk_size_from_n_ras_chunk - INFO - pc_chunk_size for idx: 399\n2023-11-05 02:46:05 - de_pc_logic_ras - INFO - writing idx.\n2023-11-05 02:46:05 - de_pc_logic_ras - INFO - write done.\n\n\n\nsource\n\n\nde_pc_logic_pc\n\n de_pc_logic_pc (idx_in:str, pc_in:str, idx:str, operation:str,\n                 pc_chunk_size:int=None, n_pc_chunk:int=None)\n\ngenerate point cloud index and data based on logical operation one point cloud data.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx_in\nstr\n\nthe index of input pc data\n\n\npc_in\nstr\n\nthe point cloud data used for thresholding\n\n\nidx\nstr\n\noutput, index of selected pixels\n\n\noperation\nstr\n\noperator\n\n\npc_chunk_size\nint\nNone\nchunk size in output data,optional\n\n\nn_pc_chunk\nint\nNone\nnumber of chunk in output data, optional\n\n\n\nUsage:\n\npc_in = np.random.rand(1000).astype(np.float32)\nidx_in = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\nidx_in.sort()\nidx_in = np.stack(np.unravel_index(idx_in,shape=(100,100))).astype(np.int32)\n\nmin_thres = 0.1; max_thres=0.5\nis_pc = (pc_in&gt;=min_thres) & (pc_in&lt;=max_thres)\nidx = idx_in[:,is_pc]\npc_in_zarr = zarr.open('pc/pc_in.zarr','w',shape=pc_in.shape,dtype=pc_in.dtype,chunks=(100,))\nidx_in_zarr = zarr.open('pc/idx_in.zarr','w',shape=idx_in.shape,dtype=idx_in.dtype,chunks=(2,100))\npc_in_zarr[:] = pc_in; idx_in_zarr[:] = idx_in\n\n\nde_pc_logic_pc('pc/idx_in.zarr','pc/pc_in.zarr','pc/idx.zarr',f'(pc_in&gt;={min_thres})&(pc_in&lt;={max_thres})')\nidx_zarr = zarr.open('pc/idx.zarr','r')\nnp.testing.assert_array_equal(idx_zarr[:],idx)\n\n2023-11-05 02:46:06 - logging_args - INFO - running function: de_pc_logic_pc\n2023-11-05 02:46:06 - logging_args - INFO - fetching args:\n2023-11-05 02:46:06 - logging_args - INFO - idx_in = 'pc/idx_in.zarr'\n2023-11-05 02:46:06 - logging_args - INFO - pc_in = 'pc/pc_in.zarr'\n2023-11-05 02:46:06 - logging_args - INFO - idx = 'pc/idx.zarr'\n2023-11-05 02:46:06 - logging_args - INFO - operation = '(pc_in&gt;=0.1)&(pc_in&lt;=0.5)'\n2023-11-05 02:46:06 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 02:46:06 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 02:46:06 - logging_args - INFO - fetching args done.\n2023-11-05 02:46:06 - zarr_info - INFO - pc/idx_in.zarr zarray shape: (2, 1000)\n2023-11-05 02:46:06 - zarr_info - INFO - pc/idx_in.zarr zarray chunks: (2, 100)\n2023-11-05 02:46:06 - zarr_info - INFO - pc/idx_in.zarr zarray dtype: int32\n2023-11-05 02:46:06 - zarr_info - INFO - pc/pc_in.zarr zarray shape: (1000,)\n2023-11-05 02:46:06 - zarr_info - INFO - pc/pc_in.zarr zarray chunks: (100,)\n2023-11-05 02:46:06 - zarr_info - INFO - pc/pc_in.zarr zarray dtype: float32\n2023-11-05 02:46:06 - de_pc_logic_pc - INFO - loading idx_in into memory.\n2023-11-05 02:46:06 - de_pc_logic_pc - INFO - loading pc_in into memory.\n2023-11-05 02:46:06 - de_pc_logic_pc - INFO - select pc based on operation: (pc_in&gt;=0.1)&(pc_in&lt;=0.5)\n2023-11-05 02:46:06 - de_pc_logic_pc - INFO - number of selected pixels: 375.\n2023-11-05 02:46:06 - get_pc_chunk_size_from_n_pc_chunk - INFO - automatically determine pc_chunk_size from\n            n_pc of idx and n_pc_chunk of idx_in\n2023-11-05 02:46:06 - get_pc_chunk_size_from_n_pc_chunk - INFO - pc_chunk_size for idx: 38\n2023-11-05 02:46:06 - zarr_info - INFO - idx zarray shape: (2, 375)\n2023-11-05 02:46:06 - zarr_info - INFO - idx zarray chunks: (2, 38)\n2023-11-05 02:46:06 - zarr_info - INFO - idx zarray dtype: int32\n2023-11-05 02:46:06 - de_pc_logic_pc - INFO - writing idx.\n2023-11-05 02:46:06 - de_pc_logic_pc - INFO - write done.\n\n\n\nsource\n\n\nde_pc_select_data\n\n de_pc_select_data (idx_in:str, idx:str, pc_in:str|list, pc:str|list,\n                    pc_chunk_size:int=None, n_pc_chunk:int=None)\n\ngenerate point cloud data based on its index and one point cloud data. The index of generated point cloud data must in the index of the old one.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx_in\nstr\n\nindex of the input data\n\n\nidx\nstr\n\nindex of the output data\n\n\npc_in\nstr | list\n\npath (in string) or list of path for the input point cloud data\n\n\npc\nstr | list\n\noutput, path (in string) or list of path for the output point cloud data\n\n\npc_chunk_size\nint\nNone\nchunk size in output data,optional\n\n\nn_pc_chunk\nint\nNone\nnumber of chunk in output data, optional\n\n\n\n\npc_in = np.random.rand(1000).astype(np.float32)\nidx_in = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\nidx_in.sort()\nidx_in = np.stack(np.unravel_index(idx_in,shape=(100,100))).astype(np.int32)\n\niidx_in = np.random.choice(np.arange(1000,dtype=np.int64),size=500,replace=False); iidx_in.sort()\nidx = idx_in[:,iidx_in]\npc = pc_in[iidx_in]\n\npc_in_zarr = zarr.open('pc/pc_in.zarr','w',shape=pc_in.shape,dtype=pc_in.dtype,chunks=(100,))\nidx_in_zarr = zarr.open('pc/idx_in.zarr','w',shape=idx_in.shape,dtype=idx_in.dtype,chunks=(2,100))\nidx_zarr = zarr.open('pc/idx.zarr','w',shape=idx.shape,dtype=idx.dtype,chunks=(2,100))\npc_in_zarr[:] = pc_in; idx_in_zarr[:] = idx_in; idx_zarr[:] = idx\n\n\nde_pc_select_data('pc/idx_in.zarr','pc/idx.zarr','pc/pc_in.zarr','pc/pc.zarr')\npc_zarr = zarr.open('pc/pc.zarr','r')\nnp.testing.assert_array_equal(pc_zarr[:],pc)\n\n2023-11-05 02:46:07 - logging_args - INFO - running function: de_pc_select_data\n2023-11-05 02:46:07 - logging_args - INFO - fetching args:\n2023-11-05 02:46:07 - logging_args - INFO - idx_in = 'pc/idx_in.zarr'\n2023-11-05 02:46:07 - logging_args - INFO - idx = 'pc/idx.zarr'\n2023-11-05 02:46:07 - logging_args - INFO - pc_in = 'pc/pc_in.zarr'\n2023-11-05 02:46:07 - logging_args - INFO - pc = 'pc/pc.zarr'\n2023-11-05 02:46:07 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 02:46:07 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 02:46:07 - logging_args - INFO - fetching args done.\n2023-11-05 02:46:07 - zarr_info - INFO - pc/idx_in.zarr zarray shape: (2, 1000)\n2023-11-05 02:46:07 - zarr_info - INFO - pc/idx_in.zarr zarray chunks: (2, 100)\n2023-11-05 02:46:07 - zarr_info - INFO - pc/idx_in.zarr zarray dtype: int32\n2023-11-05 02:46:07 - zarr_info - INFO - pc/idx.zarr zarray shape: (2, 500)\n2023-11-05 02:46:07 - zarr_info - INFO - pc/idx.zarr zarray chunks: (2, 100)\n2023-11-05 02:46:07 - zarr_info - INFO - pc/idx.zarr zarray dtype: int32\n2023-11-05 02:46:07 - de_pc_select_data - INFO - loading idx_in and idx into memory.\n2023-11-05 02:46:07 - get_pc_chunk_size_from_pc_chunk_size - INFO - automatically determine pc_chunk_size from\n            pc_chunk_size of idx.\n2023-11-05 02:46:07 - get_pc_chunk_size_from_pc_chunk_size - INFO - pc_chunk_size for pc: 100\n2023-11-05 02:46:07 - de_pc_select_data - INFO - starting dask local cluster.\n2023-11-05 02:46:11 - de_pc_select_data - INFO - dask local cluster started.\n2023-11-05 02:46:11 - zarr_info - INFO - pc/pc_in.zarr zarray shape: (1000,)\n2023-11-05 02:46:11 - zarr_info - INFO - pc/pc_in.zarr zarray chunks: (100,)\n2023-11-05 02:46:11 - zarr_info - INFO - pc/pc_in.zarr zarray dtype: float32\n2023-11-05 02:46:11 - darr_info - INFO - pc_in dask array shape: (1000,)\n2023-11-05 02:46:11 - darr_info - INFO - pc_in dask array chunksize: (100,)\n2023-11-05 02:46:11 - darr_info - INFO - pc_in dask array dtype: float32\n2023-11-05 02:46:11 - de_pc_select_data - INFO - set up selected pc data dask array.\n2023-11-05 02:46:11 - darr_info - INFO - pc dask array shape: (500,)\n2023-11-05 02:46:11 - darr_info - INFO - pc dask array chunksize: (100,)\n2023-11-05 02:46:11 - darr_info - INFO - pc dask array dtype: float32\n2023-11-05 02:46:11 - de_pc_select_data - INFO - computing graph setted. doing all the computing.\n2023-11-05 02:46:12 - de_pc_select_data - INFO - computing finished.[2K\n2023-11-05 02:46:12 - de_pc_select_data - INFO - dask cluster closed.",
    "crumbs": [
      "CLI",
      "pc"
    ]
  },
  {
    "objectID": "CLI/shp.html",
    "href": "CLI/shp.html",
    "title": "shp",
    "section": "",
    "text": "from matplotlib import pyplot as plt\nimport zarr\nimport colorcet\nfrom decorrelation.cli.utils.logging import get_logger\nfrom decorrelation.cli.pc import de_pc_logic_ras,de_ras2pc,de_pc2ras, de_idx2bool\n\n\nsource\n\nde_shp_test\n\n de_shp_test (rslc:str, pvalue:str, az_half_win:int, r_half_win:int,\n              method:str=None, n_az_chunk:int=None,\n              az_chunk_size:int=None, r_chunk_size:int=None,\n              n_r_chunk:int=None)\n\nSHP identification through hypothetic test.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc\nstr\n\ninput: rslc stack\n\n\npvalue\nstr\n\noutput: the p value of the test\n\n\naz_half_win\nint\n\nazimuth half window size\n\n\nr_half_win\nint\n\nrange half window size\n\n\nmethod\nstr\nNone\nSHP identification method,optional. Default: ks\n\n\nn_az_chunk\nint\nNone\nnumber of azimuth chunk\n\n\naz_chunk_size\nint\nNone\nazimuth chunk size, optional. Default: the azimuth chunk size in rslc\n\n\nr_chunk_size\nint\nNone\noutput range chunk size\n\n\nn_r_chunk\nint\nNone\noutput number of range chunks\n\n\n\nThis function is a wrapper of functions in decorrelation.shp that provides file interface. Please refer it for the usage. It utilizes dask for parallel and distributed computation. Compared with the functions in decorrelation.shp, this function splits the dataset into several chunks and the computation in these chunks can run in parallel on multi-GPUs.\nThe r_chunk_size and az_chunk_size is used to determine how many pixels in range and azimuth in one chunk. The chunk size of the output pvalue is also setted according to them.\n\n# rslc = '../../data/rslc.zarr'\nrslc = './raw/rslc.zarr'\npvalue = './shp/pvalue.zarr'\n\n\nlogger = get_logger()\n\n\nde_shp_test(rslc,pvalue,az_half_win=5,r_half_win=5, method=None,az_chunk_size=1000)\n\n2023-11-05 03:08:49 - logging_args - INFO - running function: de_shp_test\n2023-11-05 03:08:49 - logging_args - INFO - fetching args:\n2023-11-05 03:08:49 - logging_args - INFO - rslc = './raw/rslc.zarr'\n2023-11-05 03:08:49 - logging_args - INFO - pvalue = './shp/pvalue.zarr'\n2023-11-05 03:08:49 - logging_args - INFO - az_half_win = 5\n2023-11-05 03:08:49 - logging_args - INFO - r_half_win = 5\n2023-11-05 03:08:49 - logging_args - INFO - method = None\n2023-11-05 03:08:49 - logging_args - INFO - n_az_chunk = None\n2023-11-05 03:08:49 - logging_args - INFO - az_chunk_size = 1000\n2023-11-05 03:08:49 - logging_args - INFO - r_chunk_size = None\n2023-11-05 03:08:49 - logging_args - INFO - n_r_chunk = None\n2023-11-05 03:08:49 - logging_args - INFO - fetching args done.\n2023-11-05 03:08:49 - de_shp_test - INFO - hypothetic test method: ks\n2023-11-05 03:08:49 - zarr_info - INFO - ./raw/rslc.zarr zarray shape: (2500, 1834, 17)\n2023-11-05 03:08:49 - zarr_info - INFO - ./raw/rslc.zarr zarray chunks: (1000, 1000, 1)\n2023-11-05 03:08:49 - zarr_info - INFO - ./raw/rslc.zarr zarray dtype: complex64\n2023-11-05 03:08:49 - get_ras_chunk_size_from_ras_chunk_size - INFO - got az_chunk_size for pvalue: 1000\n2023-11-05 03:08:49 - get_ras_chunk_size_from_ras_chunk_size - INFO - automatically determine r_chunk_size from\n            r_chunk_size of rslc\n2023-11-05 03:08:49 - get_ras_chunk_size_from_ras_chunk_size - INFO - r_chunk_size for pvalue: 1000\n2023-11-05 03:08:49 - de_shp_test - INFO - starting dask CUDA local cluster.\n2023-11-05 03:08:56 - de_shp_test - INFO - dask local CUDA cluster started.\n2023-11-05 03:08:56 - darr_info - INFO - rslc dask array shape: (2500, 1834, 17)\n2023-11-05 03:08:56 - darr_info - INFO - rslc dask array chunksize: (1000, 1000, 17)\n2023-11-05 03:08:56 - darr_info - INFO - rslc dask array dtype: complex64\n2023-11-05 03:08:56 - de_shp_test - INFO - azimuth half window size: 5; azimuth window size: 11\n2023-11-05 03:08:56 - de_shp_test - INFO - range half window size: 5; range window size: 11\n2023-11-05 03:08:56 - de_shp_test - INFO - setting shared boundaries between rlsc chunks.\n2023-11-05 03:08:56 - darr_info - INFO - rslc with overlap dask array shape: (2520, 1844, 17)\n2023-11-05 03:08:56 - darr_info - INFO - rslc with overlap dask array chunksize: (1010, 1005, 17)\n2023-11-05 03:08:56 - darr_info - INFO - rslc with overlap dask array dtype: complex64\n2023-11-05 03:08:56 - darr_info - INFO - rmli with overlap dask array shape: (2520, 1844, 17)\n2023-11-05 03:08:56 - darr_info - INFO - rmli with overlap dask array chunksize: (1010, 1005, 17)\n2023-11-05 03:08:56 - darr_info - INFO - rmli with overlap dask array dtype: float32\n2023-11-05 03:08:56 - de_shp_test - INFO - applying test on sorted rmli stack.\n2023-11-05 03:08:56 - de_shp_test - INFO - p value generated\n2023-11-05 03:08:56 - darr_info - INFO - p value dask array shape: (2520, 1844, 11, 11)\n2023-11-05 03:08:56 - darr_info - INFO - p value dask array chunksize: (1010, 1005, 11, 11)\n2023-11-05 03:08:56 - darr_info - INFO - p value dask array dtype: float32\n2023-11-05 03:08:56 - de_shp_test - INFO - trim shared boundaries between p value chunks and rechunk\n2023-11-05 03:08:56 - darr_info - INFO - p value dask array shape: (2500, 1834, 11, 11)\n2023-11-05 03:08:56 - darr_info - INFO - p value dask array chunksize: (1000, 1000, 1, 1)\n2023-11-05 03:08:56 - darr_info - INFO - p value dask array dtype: float32\n2023-11-05 03:08:56 - de_shp_test - INFO - saving p value.\n2023-11-05 03:08:56 - de_shp_test - INFO - computing graph setted. doing all the computing.\n2023-11-05 03:09:06 - de_shp_test - INFO - computing finished. 9.3s\n2023-11-05 03:09:07 - de_shp_test - INFO - dask cluster closed.\nCPU times: user 2.35 s, sys: 1.43 s, total: 3.78 s\nWall time: 18.8 s\n\n\nThis function can also be called from command line directly:\n\nsource\n\n\nde_select_shp\n\n de_select_shp (pvalue:str, is_shp:str, shp_num:str, p_max:float=0.05,\n                n_az_chunk:int=None, az_chunk_size:int=None,\n                r_chunk_size:int=None, n_r_chunk:int=None)\n\nSelect SHP based on pvalue of SHP test.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npvalue\nstr\n\ninput: pvalue of hypothetic test\n\n\nis_shp\nstr\n\noutput: bool array indicating the SHPs\n\n\nshp_num\nstr\n\noutput: integer array indicating number of SHPs\n\n\np_max\nfloat\n0.05\nthreshold of p value to select SHP,optional. Default: 0.05\n\n\nn_az_chunk\nint\nNone\nnumber of point chunks, optional.\n\n\naz_chunk_size\nint\nNone\npoint cloud data chunk size, optional\n\n\nr_chunk_size\nint\nNone\noutput range chunk size\n\n\nn_r_chunk\nint\nNone\noutput number of range chunks\n\n\n\n\npvalue = './shp/pvalue.zarr'\nis_shp = './shp/is_shp.zarr'\nshp_num = './shp/num.zarr'\np_max = 0.05\naz_chunk_size = 1000\n\n\nde_select_shp(pvalue,is_shp,shp_num,p_max=p_max,az_chunk_size=az_chunk_size)\n\n2023-11-05 03:09:07 - logging_args - INFO - running function: de_select_shp\n2023-11-05 03:09:07 - logging_args - INFO - fetching args:\n2023-11-05 03:09:07 - logging_args - INFO - pvalue = './shp/pvalue.zarr'\n2023-11-05 03:09:07 - logging_args - INFO - is_shp = './shp/is_shp.zarr'\n2023-11-05 03:09:07 - logging_args - INFO - shp_num = './shp/num.zarr'\n2023-11-05 03:09:07 - logging_args - INFO - p_max = 0.05\n2023-11-05 03:09:07 - logging_args - INFO - n_az_chunk = None\n2023-11-05 03:09:07 - logging_args - INFO - az_chunk_size = 1000\n2023-11-05 03:09:07 - logging_args - INFO - r_chunk_size = None\n2023-11-05 03:09:07 - logging_args - INFO - n_r_chunk = None\n2023-11-05 03:09:07 - logging_args - INFO - fetching args done.\n2023-11-05 03:09:07 - zarr_info - INFO - ./shp/pvalue.zarr zarray shape: (2500, 1834, 11, 11)\n2023-11-05 03:09:07 - zarr_info - INFO - ./shp/pvalue.zarr zarray chunks: (1000, 1000, 1, 1)\n2023-11-05 03:09:07 - zarr_info - INFO - ./shp/pvalue.zarr zarray dtype: float32\n2023-11-05 03:09:07 - get_ras_chunk_size_from_ras_chunk_size - INFO - got az_chunk_size for is_shp: 1000\n2023-11-05 03:09:07 - get_ras_chunk_size_from_ras_chunk_size - INFO - automatically determine r_chunk_size from\n            r_chunk_size of pvalue\n2023-11-05 03:09:07 - get_ras_chunk_size_from_ras_chunk_size - INFO - r_chunk_size for is_shp: 1000\n2023-11-05 03:09:07 - de_select_shp - INFO - starting dask cuda cluster.\n2023-11-05 03:09:13 - de_select_shp - INFO - dask cluster started.\n2023-11-05 03:09:13 - darr_info - INFO - pvalue dask array shape: (2500, 1834, 11, 11)\n2023-11-05 03:09:13 - darr_info - INFO - pvalue dask array chunksize: (1000, 1000, 11, 11)\n2023-11-05 03:09:13 - darr_info - INFO - pvalue dask array dtype: float32\n2023-11-05 03:09:13 - de_select_shp - INFO - selecting SHPs based on pvalue threshold: 0.05\n2023-11-05 03:09:13 - darr_info - INFO - is_shp dask array shape: (2500, 1834, 11, 11)\n2023-11-05 03:09:13 - darr_info - INFO - is_shp dask array chunksize: (1000, 1000, 11, 11)\n2023-11-05 03:09:13 - darr_info - INFO - is_shp dask array dtype: bool\n2023-11-05 03:09:13 - de_select_shp - INFO - calculate shp_num.\n2023-11-05 03:09:13 - darr_info - INFO - shp_num dask array shape: (2500, 1834)\n2023-11-05 03:09:13 - darr_info - INFO - shp_num dask array chunksize: (1000, 1000)\n2023-11-05 03:09:13 - darr_info - INFO - shp_num dask array dtype: int32\n2023-11-05 03:09:13 - de_select_shp - INFO - rechunk is_shp\n2023-11-05 03:09:13 - darr_info - INFO - is_shp dask array shape: (2500, 1834, 11, 11)\n2023-11-05 03:09:13 - darr_info - INFO - is_shp dask array chunksize: (1000, 1000, 1, 1)\n2023-11-05 03:09:13 - darr_info - INFO - is_shp dask array dtype: bool\n2023-11-05 03:09:14 - de_select_shp - INFO - saving is_shp.\n2023-11-05 03:09:14 - de_select_shp - INFO - saving shp_num.\n2023-11-05 03:09:14 - de_select_shp - INFO - computing graph setted. doing all the computing.\n2023-11-05 03:09:29 - de_select_shp - INFO - computing finished..6s\n2023-11-05 03:09:31 - de_select_shp - INFO - dask cluster closed.\nCPU times: user 2.04 s, sys: 1.56 s, total: 3.6 s\nWall time: 23.9 s\n\n\n\nshp_num_zarr = zarr.open(shp_num,'r')\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(shp_num_zarr[:],cmap=colorcet.cm.fire)\nax.set(title='Number of SHPs',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\n\n\n\nThen we can select DS candidates based on number of SHPs and slice is_shp only on DS candidates.\n\nds_can_idx = './shp/ds_can_idx.zarr'\nis_ds_can= './shp/is_ds_can.zarr'\nds_can_is_shp = './shp/ds_can_is_shp.zarr'\n\n\nde_pc_logic_ras(shp_num,ds_can_idx,'ras&gt;=50')\n\n2023-11-05 03:09:32 - logging_args - INFO - running function: de_pc_logic_ras\n2023-11-05 03:09:32 - logging_args - INFO - fetching args:\n2023-11-05 03:09:32 - logging_args - INFO - ras = './shp/num.zarr'\n2023-11-05 03:09:32 - logging_args - INFO - idx = './shp/ds_can_idx.zarr'\n2023-11-05 03:09:32 - logging_args - INFO - operation = 'ras&gt;=50'\n2023-11-05 03:09:32 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 03:09:32 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 03:09:32 - logging_args - INFO - fetching args done.\n2023-11-05 03:09:32 - zarr_info - INFO - ./shp/num.zarr zarray shape: (2500, 1834)\n2023-11-05 03:09:32 - zarr_info - INFO - ./shp/num.zarr zarray chunks: (1000, 1000)\n2023-11-05 03:09:32 - zarr_info - INFO - ./shp/num.zarr zarray dtype: int32\n2023-11-05 03:09:32 - de_pc_logic_ras - INFO - loading ras into memory.\n2023-11-05 03:09:32 - de_pc_logic_ras - INFO - select pc based on operation: ras&gt;=50\n2023-11-05 03:09:32 - de_pc_logic_ras - INFO - number of selected pixels: 740397.\n2023-11-05 03:09:32 - get_pc_chunk_size_from_n_ras_chunk - INFO - automatically determine pc_chunk_size from\n            n_pc of idx and n_ras_chunk of ras\n2023-11-05 03:09:32 - get_pc_chunk_size_from_n_ras_chunk - INFO - n_ras_chunk of ras: 6\n2023-11-05 03:09:32 - get_pc_chunk_size_from_n_ras_chunk - INFO - pc_chunk_size for idx: 123400\n2023-11-05 03:09:32 - de_pc_logic_ras - INFO - writing idx.\n2023-11-05 03:09:32 - de_pc_logic_ras - INFO - write done.\n\n\n\nde_ras2pc(ds_can_idx, is_shp, ds_can_is_shp)\nde_idx2bool(ds_can_idx, is_ds_can, shape= shp_num_zarr.shape)\n\n2023-11-05 03:09:32 - logging_args - INFO - running function: de_ras2pc\n2023-11-05 03:09:32 - logging_args - INFO - fetching args:\n2023-11-05 03:09:32 - logging_args - INFO - idx = './shp/ds_can_idx.zarr'\n2023-11-05 03:09:32 - logging_args - INFO - ras = './shp/is_shp.zarr'\n2023-11-05 03:09:32 - logging_args - INFO - pc = './shp/ds_can_is_shp.zarr'\n2023-11-05 03:09:32 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 03:09:32 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 03:09:32 - logging_args - INFO - hd_chunk_size = None\n2023-11-05 03:09:32 - logging_args - INFO - fetching args done.\n2023-11-05 03:09:32 - zarr_info - INFO - ./shp/ds_can_idx.zarr zarray shape: (2, 740397)\n2023-11-05 03:09:32 - zarr_info - INFO - ./shp/ds_can_idx.zarr zarray chunks: (2, 123400)\n2023-11-05 03:09:32 - zarr_info - INFO - ./shp/ds_can_idx.zarr zarray dtype: int32\n2023-11-05 03:09:32 - get_pc_chunk_size_from_pc_chunk_size - INFO - automatically determine pc_chunk_size from\n            pc_chunk_size of idx.\n2023-11-05 03:09:32 - get_pc_chunk_size_from_pc_chunk_size - INFO - pc_chunk_size for pc: 123400\n2023-11-05 03:09:32 - de_ras2pc - INFO - loading idx into memory.\n2023-11-05 03:09:32 - de_ras2pc - INFO - starting dask local cluster.\n2023-11-05 03:09:36 - de_ras2pc - INFO - dask local cluster started.\n2023-11-05 03:09:36 - de_ras2pc - INFO - start to slice on ./shp/is_shp.zarr\n2023-11-05 03:09:36 - zarr_info - INFO - ./shp/is_shp.zarr zarray shape: (2500, 1834, 11, 11)\n2023-11-05 03:09:36 - zarr_info - INFO - ./shp/is_shp.zarr zarray chunks: (1000, 1000, 1, 1)\n2023-11-05 03:09:36 - zarr_info - INFO - ./shp/is_shp.zarr zarray dtype: bool\n2023-11-05 03:09:36 - de_ras2pc - INFO - hd_chunk_size not setted. Use the one from ./shp/is_shp.zarr.\n2023-11-05 03:09:36 - de_ras2pc - INFO - hd_chunk_size: (1, 1).\n2023-11-05 03:09:36 - darr_info - INFO - ras dask array shape: (2500, 1834, 11, 11)\n2023-11-05 03:09:36 - darr_info - INFO - ras dask array chunksize: (1000, 1000, 1, 1)\n2023-11-05 03:09:36 - darr_info - INFO - ras dask array dtype: bool\n2023-11-05 03:09:36 - darr_info - INFO - pc dask array shape: (740397, 11, 11)\n2023-11-05 03:09:36 - darr_info - INFO - pc dask array chunksize: (177430, 1, 1)\n2023-11-05 03:09:36 - darr_info - INFO - pc dask array dtype: bool\n2023-11-05 03:09:36 - de_ras2pc - INFO - rechunk pc data:\n2023-11-05 03:09:36 - darr_info - INFO - pc dask array shape: (740397, 11, 11)\n2023-11-05 03:09:36 - darr_info - INFO - pc dask array chunksize: (123400, 1, 1)\n2023-11-05 03:09:36 - darr_info - INFO - pc dask array dtype: bool\n2023-11-05 03:09:37 - de_ras2pc - INFO - saving to ./shp/ds_can_is_shp.zarr.\n2023-11-05 03:09:37 - de_ras2pc - INFO - computing graph setted. doing all the computing.\n2023-11-05 03:09:40 - de_ras2pc - INFO - computing finished.|  3.3s\n2023-11-05 03:09:40 - de_ras2pc - INFO - dask cluster closed.\n2023-11-05 03:09:40 - logging_args - INFO - running function: de_idx2bool\n2023-11-05 03:09:40 - logging_args - INFO - fetching args:\n2023-11-05 03:09:40 - logging_args - INFO - idx = './shp/ds_can_idx.zarr'\n2023-11-05 03:09:40 - logging_args - INFO - is_pc = './shp/is_ds_can.zarr'\n2023-11-05 03:09:40 - logging_args - INFO - shape = (2500, 1834)\n2023-11-05 03:09:40 - logging_args - INFO - az_chunk_size = None\n2023-11-05 03:09:40 - logging_args - INFO - n_az_chunk = None\n2023-11-05 03:09:40 - logging_args - INFO - r_chunk_size = None\n2023-11-05 03:09:40 - logging_args - INFO - n_r_chunk = None\n2023-11-05 03:09:40 - logging_args - INFO - fetching args done.\n2023-11-05 03:09:40 - zarr_info - INFO - idx zarray shape: (2, 740397)\n2023-11-05 03:09:40 - zarr_info - INFO - idx zarray chunks: (2, 123400)\n2023-11-05 03:09:40 - zarr_info - INFO - idx zarray dtype: int32\n2023-11-05 03:09:40 - de_idx2bool - INFO - loading idx into memory.\n2023-11-05 03:09:40 - de_idx2bool - INFO - calculate the bool array\n2023-11-05 03:09:40 - get_ras_chunk_size_from_n_pc_chunk - INFO - automatically set r_chunk_size to nlines of ras\n2023-11-05 03:09:40 - get_ras_chunk_size_from_n_pc_chunk - INFO - automatically determine az_chunk_size from \n            nlines and n_r_chunk of ras  and n_pc_chunk of idx\n2023-11-05 03:09:40 - get_ras_chunk_size_from_n_pc_chunk - INFO - az_chunk_size for ras: 417\n2023-11-05 03:09:40 - zarr_info - INFO - is_pc zarray shape: (2500, 1834)\n2023-11-05 03:09:40 - zarr_info - INFO - is_pc zarray chunks: (417, 1834)\n2023-11-05 03:09:40 - zarr_info - INFO - is_pc zarray dtype: bool\n2023-11-05 03:09:40 - de_idx2bool - INFO - write the bool array.\n2023-11-05 03:09:41 - de_idx2bool - INFO - write done.\n\n\n\nis_ds_can_zarr = zarr.open(is_ds_can,'r')\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(is_ds_can_zarr[:],cmap=colorcet.cm.fire)\nax.set(title='DS candidiate distribution',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()",
    "crumbs": [
      "CLI",
      "shp"
    ]
  },
  {
    "objectID": "Introduction/software_architecture.html",
    "href": "Introduction/software_architecture.html",
    "title": "Software Architecture",
    "section": "",
    "text": "Unlike most InSAR processing software (e.g., StamPS, MintPy) that have designated processing workflow, Decorrelation only provides a collection of Python functions or commands. The reason is, in real application, there is no perfect workflow that always generate satisfactory deformation result. Especially when the coherence is not good and atmospheric artifact is strong. One needs to try a lot of different methods but they are generally implented in different packages. Even worse, the workflow-based software are encapsulated too much and generally no detailed documentation is provided. It is really frustrating when users need to save intermediate data from one software and prepared them in a designated format and structure required by another software. Sometimes it is necessarry to read a lot of source code to understand what are the output, what are their data structure and what kind of inputs are needed as their typical workflows is not followed. So, instead of providing a standard workflow, Decorrelation is designed as a collection of functions that implement specific InSAR processing techniques (e.g. calculate the dispersion index, do phase linking) and users are encouraged to make their own workflow that are suitable for their case. We provide the necessary infrastructure and your role is to be innovative! To make it easier, Decorrelation provides detailed documentation for each function that explain the usage. We also provide the tutorials section that provide some typical workflow for your reference. In case users want to try methods that are not implemented in Decorrelation, the input and output are well explained in the documentation of every Decorrelation functions.\nAlthough we provide detailed documentation and reference workflow, we still admit this software is not that easy that users only need to run from the first step to the last step. It doesn’t mean we don’t value user-friendliness, but it shouldn’t come at the expense of flexibility and creativity.",
    "crumbs": [
      "Introduction",
      "Software Architecture"
    ]
  },
  {
    "objectID": "Introduction/software_architecture.html#software-design",
    "href": "Introduction/software_architecture.html#software-design",
    "title": "Software Architecture",
    "section": "",
    "text": "Unlike most InSAR processing software (e.g., StamPS, MintPy) that have designated processing workflow, Decorrelation only provides a collection of Python functions or commands. The reason is, in real application, there is no perfect workflow that always generate satisfactory deformation result. Especially when the coherence is not good and atmospheric artifact is strong. One needs to try a lot of different methods but they are generally implented in different packages. Even worse, the workflow-based software are encapsulated too much and generally no detailed documentation is provided. It is really frustrating when users need to save intermediate data from one software and prepared them in a designated format and structure required by another software. Sometimes it is necessarry to read a lot of source code to understand what are the output, what are their data structure and what kind of inputs are needed as their typical workflows is not followed. So, instead of providing a standard workflow, Decorrelation is designed as a collection of functions that implement specific InSAR processing techniques (e.g. calculate the dispersion index, do phase linking) and users are encouraged to make their own workflow that are suitable for their case. We provide the necessary infrastructure and your role is to be innovative! To make it easier, Decorrelation provides detailed documentation for each function that explain the usage. We also provide the tutorials section that provide some typical workflow for your reference. In case users want to try methods that are not implemented in Decorrelation, the input and output are well explained in the documentation of every Decorrelation functions.\nAlthough we provide detailed documentation and reference workflow, we still admit this software is not that easy that users only need to run from the first step to the last step. It doesn’t mean we don’t value user-friendliness, but it shouldn’t come at the expense of flexibility and creativity.",
    "crumbs": [
      "Introduction",
      "Software Architecture"
    ]
  },
  {
    "objectID": "Introduction/software_architecture.html#software-structure",
    "href": "Introduction/software_architecture.html#software-structure",
    "title": "Software Architecture",
    "section": "Software Structure",
    "text": "Software Structure\nMost of the functions in this package provide 2 kind of API, the array-based API and the file-based API. The inputs and output of array-based functions generally are numpy or cupy arrays (Simply, cupy is a package that provides same functions as numpy but runs on GPU), while inputs and outputs of file-based functions are string of path to the array stored in disk. InSAR techniques that can be greatly accelerated with parallel processing are implented in cupy for better performance while all other functions are implented with numpy arrays. The file-based functions are not simple wrapper of the array-based functions. Due to the limitation of numpy and cupy, most array-based functions can only be runned on a single CPU core or on a single GPU. However, the file-based functions support parallel processing on multi-CPU-cores and multi-GPUs with the help of dask. But their is performance cost for using dask, sometimes the array-based functions is faster. Another benefit of dask is the memory usage is smaller as the processing on each chunks can be in sequence.\nAll functions in the file-based API starts with a prefix de to make them more distinguishable. Terminal commands of same name as the file-based functions is also provided. To make it simpler, we call the file-based functions and commands CLI (command line interface), the array-based API API. The API and CLI functions are arranged in different namespace. In this documentation website, if document of one API function xxx is in section API and subsection pl, then it is in the namespace decorrelation.pl, the correct way to import it is from decorrelation.pl import xxx. For CLI funtion de_xxx, it the document page is in section CLI and subsection pl, then it is in the namespace decorrelation.cli.pl and the correct way to import it is from decorrelation.cli.pl import de_xxx.",
    "crumbs": [
      "Introduction",
      "Software Architecture"
    ]
  },
  {
    "objectID": "Introduction/software_architecture.html#data-format",
    "href": "Introduction/software_architecture.html#data-format",
    "title": "Software Architecture",
    "section": "Data format",
    "text": "Data format\nMost of the stored data in this package is in the zarr format, which is a file storage format for chunked, compressed, N-dimensional arrays. The figure below shows how the structure of zarr data. The reading and writing speed is fast since the data volume is compressed. Before compressing, the data are divided into chunks to be more flexiable for dask parallel operation. Generally, the file name is xxxxxx.zarr. You will find it is indeed a directory in the file system. But just treat it as a single file in use.\n\n\n\nimga\n\n\nNote that the sturcture of dask array is similar. Each chunk of a big dask array is just a numpy or cupy array. Independent operations on every chunks are automatically parallelized.\nIn this software, there are mainly two kind of dataset. One is stack of raster data, another is stack of point cloud data. The raster dataset are divided into chunks both azimuth dimension and range dimension. The point cloud dataset are divided into chunks along the spatial dimension. These two chunksize needs to be determined by the user. The chunksize in high dims are automatically determined. Users don’t need to care about it.\nChunksize affect the performance of the program. Unproper chunksize slows down the processing speed or even crash the program. Using too small chunksize makes too much inter-process communication and slows down the program. Too big chunksize may crash the program due to mamory limit. For raster data, it is good to make sure range chunksize of the last chunk is same as others. And it is prefered to divide raster data along azimuth direction rather than range direction.",
    "crumbs": [
      "Introduction",
      "Software Architecture"
    ]
  },
  {
    "objectID": "Introduction/software_architecture.html#an-example",
    "href": "Introduction/software_architecture.html#an-example",
    "title": "Software Architecture",
    "section": "An example",
    "text": "An example\nHere we provide an simple example. The API function decorrelation.pl.emi implemented the EMI phase linking method and decorrelation.cli.de_emi is the file-based API of it.\nImport them first:\n\nfrom decorrelation.pl import emi\nfrom decorrelation.cli.pl import de_emi\nfrom nbdev.showdoc import show_doc # this is just a function to show the document\n\n\nsource\n\nemi\n\n emi (coh:cupy.ndarray, ref:int=0)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoh\nndarray\n\ncomplex coherence metrix,dtype cupy.complex\n\n\nref\nint\n0\nindex of reference image in the phase history output, optional. Default: 0\n\n\nReturns\ntuple\n\nestimated phase history ph, dtype complex; quality (minimum eigvalue, dtype float)\n\n\n\n\nsource\n\n\nde_emi\n\n de_emi (coh:str, ph:str, emi_quality:str, ref:int=0, n_pc_chunk:int=None,\n         pc_chunk_size:int=None)\n\nPhase linking with EMI estimator.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoh\nstr\n\ncoherence matrix\n\n\nph\nstr\n\noutput, wrapped phase\n\n\nemi_quality\nstr\n\noutput, pixel quality\n\n\nref\nint\n0\nreference image for phase\n\n\nn_pc_chunk\nint\nNone\nnumber of point cloud chunk\n\n\npc_chunk_size\nint\nNone\npoint cloud chunk size\n\n\n\nTo apply the emi API funtion:\n\nimport zarr\nimport numpy as np\nimport cupy as cp\n\n\ncoh_zarr = zarr.open('./software_architecture/ds_can_coh.zarr/','r')\n\n\ncoh_zarr,coh_zarr.shape,coh_zarr.chunks,coh_zarr.dtype\n\n(&lt;zarr.core.Array (740397, 17, 17) complex64 read-only&gt;,\n (740397, 17, 17),\n (200000, 17, 17),\n dtype('complex64'))\n\n\nIt is coherence matrix for 740397 selected DS candidate and there are 17 SAR images. So the coherence matrix for one pixel is 17 \\(\\times\\) 17. The coherence matrix is stored in 4 chunks and each chunks stores data for 200000 DS candidate. (The last chunk only have 140397 DS candidate).\n\n!ls -al ./software_architecture/ds_can_coh.zarr/ #It is a directory indeed!\n\ntotal 1570400\ndrwxrwxr-x 2 kangl kangl      4096 Sep 28 12:30 .\ndrwxrwxr-x 5 kangl kangl      4096 Oct  4 12:15 ..\n-rw-rw-r-- 1 kangl kangl 434775676 Sep 28 12:30 0.0.0\n-rw-rw-r-- 1 kangl kangl 432578417 Sep 28 12:30 1.0.0\n-rw-rw-r-- 1 kangl kangl 434846911 Sep 28 12:30 2.0.0\n-rw-rw-r-- 1 kangl kangl 305857416 Sep 28 12:30 3.0.0\n-rw-rw-r-- 1 kangl kangl       398 Sep 28 12:30 .zarray\n\n\n\ncoh = coh_zarr[:] # read as numpy array\n\n\ncoh = cp.asarray(coh) # convert to cupy array\n\n\ncoh.shape\n\n(740397, 17, 17)\n\n\n\n# The processing is really fast!\nph,emi_quality = emi(coh)\n\nCPU times: user 1.18 s, sys: 447 ms, total: 1.62 s\nWall time: 1.69 s\n\n\nNow we apply the CLI function:\n\nde_emi('./software_architecture/ds_can_coh.zarr/',\n       './software_architecture/ds_can_ph.zarr',\n       './software_architecture/ds_can_emi_quality.zarr',\n       point_chunk_size = 200000)\n\n2023-10-08 23:30:17 - de_emi - INFO - fetching args:\n2023-10-08 23:30:17 - de_emi - INFO - coh = './software_architecture/ds_can_coh.zarr/'\n2023-10-08 23:30:17 - de_emi - INFO - ph = './software_architecture/ds_can_ph.zarr'\n2023-10-08 23:30:17 - de_emi - INFO - emi_quality = './software_architecture/ds_can_emi_quality.zarr'\n2023-10-08 23:30:17 - de_emi - INFO - ref = 0\n2023-10-08 23:30:17 - de_emi - INFO - point_chunk_size = 200000\n2023-10-08 23:30:17 - de_emi - INFO - log = None\n2023-10-08 23:30:17 - de_emi - INFO - plot_emi_quality = False\n2023-10-08 23:30:17 - de_emi - INFO - vmin = 1.0\n2023-10-08 23:30:17 - de_emi - INFO - vmax = 1.3\n2023-10-08 23:30:17 - de_emi - INFO - ds_idx = None\n2023-10-08 23:30:17 - de_emi - INFO - shape = None\n2023-10-08 23:30:17 - de_emi - INFO - emi_quality_fig = None\n2023-10-08 23:30:17 - de_emi - INFO - fetching args done.\n2023-10-08 23:30:17 - de_emi - INFO - coh dataset shape: (740397, 17, 17)\n2023-10-08 23:30:17 - de_emi - INFO - coh dataset chunks: (200000, 17, 17)\n2023-10-08 23:30:17 - de_emi - INFO - parallel processing point chunk size: 200000\n2023-10-08 23:30:17 - de_emi - INFO - starting dask CUDA local cluster.\n2023-10-08 23:30:23 - de_emi - INFO - dask local CUDA cluster started.\n2023-10-08 23:30:23 - de_emi - INFO - coh dask array shape: (740397, 17, 17)\n2023-10-08 23:30:23 - de_emi - INFO - coh dask array chunks: ((200000, 200000, 200000, 140397), (17,), (17,))\n2023-10-08 23:30:23 - de_emi - INFO - phase linking with EMI.\n2023-10-08 23:30:23 - de_emi - INFO - got ph and emi_quality.\n2023-10-08 23:30:23 - de_emi - INFO - ph dask array shape: (740397, 17)\n2023-10-08 23:30:23 - de_emi - INFO - ph dask array chunks: ((200000, 200000, 200000, 140397), (17,))\n2023-10-08 23:30:23 - de_emi - INFO - emi_quality dask array shape: (740397,)\n2023-10-08 23:30:23 - de_emi - INFO - emi_quality dask array chunks: ((200000, 200000, 200000, 140397),)\n2023-10-08 23:30:23 - de_emi - INFO - saving ph and emi_quality.\n2023-10-08 23:30:23 - de_emi - INFO - computing graph setted. doing all the computing.\n2023-10-08 23:30:26 - de_emi - INFO - computing finished.\n2023-10-08 23:30:28 - de_emi - INFO - dask cluster closed.\nCPU times: user 637 ms, sys: 723 ms, total: 1.36 s\nWall time: 11.6 s\n\n\n2023-10-08 23:30:19,866 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-08 23:30:19,866 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-08 23:30:19,869 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-08 23:30:19,869 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-08 23:30:19,872 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-08 23:30:19,872 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-08 23:30:19,873 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-08 23:30:19,873 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-08 23:30:19,880 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-08 23:30:19,880 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-08 23:30:19,886 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-08 23:30:19,886 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-08 23:30:19,893 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-08 23:30:19,893 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-08 23:30:19,898 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-08 23:30:19,898 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n\n\nThe CLI function is slower than the API function since it needs to read and write the data and set up the dask CUDA cluster.\nNotice that there is a point_chunk_size option in the CLI function, it means the data is processed in chunks seperately and each chunk have point_chunk_size pixels. By default, this number is set as the chunk size in the input zarr data.\nThere are more options in the CLI function, e.g., to save the printed information to the log file, to plot some result.\nAs mentioned, the CLI funtion also provide command line interface, but it won’t generate any plot on screen since it is not supported in terminal.\n\n!de_emi -h\n\nusage: de_emi [-h] [--ref REF] [--point_chunk_size POINT_CHUNK_SIZE] [--log LOG]\n              [--plot_emi_quality] [--vmin VMIN] [--vmax VMAX] [--ds_idx DS_IDX]\n              [--shape SHAPE] [--emi_quality_fig EMI_QUALITY_FIG]\n              coh ph emi_quality\n\npositional arguments:\n  coh                                  coherence matrix\n  ph                                   output, wrapped phase\n  emi_quality                          output, pixel quality\n\noptions:\n  -h, --help                           show this help message and exit\n  --ref REF                            reference image for phase (default: 0)\n  --point_chunk_size POINT_CHUNK_SIZE  parallel processing point chunk size\n  --log LOG                            log\n  --plot_emi_quality                   if plot the emi quality (default: False)\n  --vmin VMIN                          min value of emi quality to plot\n                                       (default: 1.0)\n  --vmax VMAX                          max value of emi quality to plot\n                                       (default: 1.3)\n  --ds_idx DS_IDX                      index of ds\n  --shape SHAPE                        shape of one image\n  --emi_quality_fig EMI_QUALITY_FIG    path to save the emi quality plot,\n                                       optional. Default, no saving\n\n\nThe CLI also include functions for simple data manipulation (e.g. array slicing and point clouds merging). As it is very easy to do them for numpy/cupy arrays, these CLI do not have corresponding API.\n\n\n\nimga",
    "crumbs": [
      "Introduction",
      "Software Architecture"
    ]
  },
  {
    "objectID": "API/co.html",
    "href": "API/co.html",
    "title": "co",
    "section": "",
    "text": "For generating data for doc and test\nimport zarr\nfrom decorrelation.shp import ks_test\nimport math\nimport itertools\ntry:\n    import cupy as cp\n    from cupy.testing import assert_array_almost_equal\nexcept:\n    pass",
    "crumbs": [
      "API",
      "co"
    ]
  },
  {
    "objectID": "API/co.html#covariance-and-coherence-matrix-estimator",
    "href": "API/co.html#covariance-and-coherence-matrix-estimator",
    "title": "co",
    "section": "Covariance and Coherence Matrix Estimator",
    "text": "Covariance and Coherence Matrix Estimator\n\nsource\n\nemperical_co\n\n emperical_co (rslc:cupy.ndarray, is_shp:cupy.ndarray, block_size:int=128)\n\nMaximum likelihood covariance estimator.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc\nndarray\n\nrslc stack, dtype: cupy.complexfloating\n\n\nis_shp\nndarray\n\nshp bool, dtype: cupy.bool\n\n\nblock_size\nint\n128\nthe CUDA block size, it only affects the calculation speed\n\n\nReturns\ntuple\n\nthe covariance and coherence matrix cov and coh\n\n\n\nThe cov and coh is defined as:\n\\[\ncov = E(z_1z_2^*) \\quad coh=\\frac{E(z_1z_2^*)}{\\sqrt{E(|z_1|^2)E(|z_2|^2)}}\n\\]\nand estimated as:\n\\[\ncov = \\frac{\\sum_{i=1}^{L}z_1^{i}z_2^{i*}}{L} \\quad coh = \\frac{\\sum_{i=1}^{L}z_1^{i}z_2^{i*}}{\\sqrt(\\sum_{i=1}^{L}|z_1^{i}|^2)(\\sum_{i=1}^{L}|z_2^{i}|^2)}\n\\]\nusing all selected SHPs. Their shapes are [nlines,width,nimages,nimages].\nThe rslc is a three dimentional cupy ndarray. The dtype should be cupy.complex64. From outerest to innerest, the three dimentions are azimuth, range and image. is_shp is a four dimentional cupy ndarray. It describes if pixels in the search window are SHP to the central pixel. From outerest ot innerest, they are azimuth, range, secondary pixel relative azimuth, secondary pixel relative range.\nHere is an example:\n\n\nFor generating data for doc and test\nrslc = zarr.open('../../data/rslc.zarr/','r')[600:605,600:610]\nrslc = cp.asarray(rslc)\n\n# SHP selection\naz_half_win = 1; r_half_win = 2\naz_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n\nrmli = cp.abs(rslc)**2\nsorted_rmli = cp.sort(rmli,axis=-1)\ndist,p = ks_test(sorted_rmli,az_half_win=az_half_win,r_half_win=r_half_win)\nis_shp = (p &lt; 0.05) & (p &gt;= 0.0)\n\n# Select DS candidate\nshp_num = cp.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 3\nds_can_is_shp = is_shp[is_ds_can]\nds_can_idx = cp.where(is_ds_can)\n\n\n\nrslc.shape, is_shp.shape, is_shp[2,3]\n\n((5, 10, 17),\n (5, 10, 3, 5),\n array([[False, False, False, False,  True],\n        [False, False,  True, False, False],\n        [False, False,  True, False, False]]))\n\n\nrslc is a stack of 17 rslc images. Each of the image has 5 pixel in azimuth dimention and 10 pixels in range dimention. It shows for pixel (2,3), the (3*5) window around it has 2 SHPs to it (the central one is itself).\n\ncov,coh = emperical_co(rslc,is_shp)\ncov.shape, coh.shape\n\n((5, 10, 17, 17), (5, 10, 17, 17))\n\n\nBoth cov and coh are complex data. The shape shows each covarience or coherence matrix is 17 by 17 since there are 17 images. And cov and coh are matrix for all 5*10 pixels.\n\nsource\n\n\nemperical_co_pc\n\n emperical_co_pc (rslc:cupy.ndarray, idx:cupy.ndarray,\n                  pc_is_shp:cupy.ndarray, block_size:int=128)\n\nMaximum likelihood covariance estimator for sparse data.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc\nndarray\n\nrslc stack, dtype: cupy.complexfloating\n\n\nidx\nndarray\n\nindex of point target (azimuth_index, range_index), dtype: cupy.int, shape: (2,n_sp)\n\n\npc_is_shp\nndarray\n\nshp bool, dtype: cupy.bool\n\n\nblock_size\nint\n128\nthe CUDA block size, it only affects the calculation speed\n\n\nReturns\ntuple\n\nthe covariance and coherence matrix cov and coh\n\n\n\nemperical_co_sp is the emperical_co on sparse data, e.g., DSs. rslc is same as emperical_co. sp_idx is the index, i.e., a tuple of (azimuth_idx, range_idx). Each index is 1D array. pc_is_shp is similar to is_shp in emperical_co but it only contains information about the point cloud data. It is a 3D array with shape [number_of_point,az_win,r_win].\nCompared with emperical_co, emperical_co_pc only estimate coherence/covariance at specific position so the memory usage is much small.\nExample:\n\n\nCode for generating data for doc\nrslc = zarr.open('../../data/rslc.zarr/','r')[600:605,600:610]\nrslc = cp.asarray(rslc)\n\n# SHP selection\naz_half_win = 1; r_half_win = 2\naz_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n\nrmli = cp.abs(rslc)**2\nsorted_rmli = cp.sort(rmli,axis=-1)\ndist,p = ks_test(sorted_rmli,az_half_win=az_half_win,r_half_win=r_half_win)\nis_shp = (p &lt; 0.05) & (p &gt;= 0.0)\n\n# Select DS candidate\nshp_num = cp.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 3\nds_can_is_shp = is_shp[is_ds_can]\nds_can_idx = cp.stack(cp.where(is_ds_can))\n\n\n\nrslc.shape,ds_can_idx,ds_can_is_shp\n\n((5, 10, 17),\n array([[2, 3, 3, 4, 4],\n        [3, 3, 5, 1, 4]]),\n array([[[False, False, False, False,  True],\n         [False, False,  True, False, False],\n         [False, False,  True, False, False]],\n \n        [[False, False,  True, False, False],\n         [False, False,  True, False, False],\n         [False, False, False,  True, False]],\n \n        [[False, False, False, False, False],\n         [False, False,  True, False, False],\n         [ True,  True, False, False, False]],\n \n        [[False, False,  True, False, False],\n         [False,  True,  True, False, False],\n         [False, False, False, False, False]],\n \n        [[False,  True,  True,  True, False],\n         [False, False,  True, False,  True],\n         [False, False, False, False, False]]]))\n\n\nrslc is a stack of 17 rslc images. Each of the image has 5 pixel in azimuth dimention and 10 pixels in range dimention. ds_can_idx shows the index of the DS candidates and ds_can_is_shp shows the corrosponding SHPs.\n\nds_can_cov, ds_can_coh = emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp)",
    "crumbs": [
      "API",
      "co"
    ]
  },
  {
    "objectID": "API/co.html#covariance-and-coherence-matrix-regularizer",
    "href": "API/co.html#covariance-and-coherence-matrix-regularizer",
    "title": "co",
    "section": "Covariance and Coherence Matrix Regularizer",
    "text": "Covariance and Coherence Matrix Regularizer\n\nsource\n\nisPD\n\n isPD (co:cupy.ndarray)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nco\nndarray\nabsolute value of complex coherence/covariance stack\n\n\nReturns\nndarray\nbool array indicating wheather coherence/covariance is positive define\n\n\n\nThis function tells if the matrix is positive defined or not.\n\n\nCode for generating data for doc\nrslc = zarr.open('../../data/rslc.zarr/','r')[600:650,600:650]\nrslc = cp.asarray(rslc)\n\n# SHP selection\naz_half_win = 5; r_half_win = 5\naz_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n\nrmli = cp.abs(rslc)**2\nsorted_rmli = cp.sort(rmli,axis=-1)\ndist,p = ks_test(sorted_rmli,az_half_win=az_half_win,r_half_win=r_half_win)\nis_shp = (p &lt; 0.05) & (p &gt;= 0.0)\n\n# Select DS candidate\nshp_num = cp.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 50\nds_can_is_shp = is_shp[is_ds_can]\nds_can_idx = cp.where(is_ds_can)\n\nds_can_coh = emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp)[1]\n\n\n\nds_can_coh.shape\n\n(149, 17, 17)\n\n\n\nisPD_ds_can = isPD(ds_can_coh)\n\n\nisPD_ds_can\n\narray([ True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True])\n\n\nAll coherence matrix are positive defined.\n\nsource\n\n\nnearestPD\n\n nearestPD (co:cupy.ndarray)\n\nFind the nearest positive-definite matrix to input matrix.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nco\nndarray\nstack of matrix with shape […,N,N]\n\n\nReturns\nndarray\nnearest positive definite matrix of input, shape […,N,N]\n\n\n\nnearest means the Frobenius norm of the difference is minimized.\n\nsource\n\n\nregularize_spectral\n\n regularize_spectral (coh:cupy.ndarray, beta:Union[float,cupy.ndarray])\n\nSpectral regularizer for coherence matrix.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ncoh\nndarray\nstack of matrix with shape […,N,N]\n\n\nbeta\nUnion\nthe regularization parameter, a float number or cupy ndarray with shape […]\n\n\nReturns\nndarray\nregularized matrix, shape […,N,N]\n\n\n\nregularize_spectral can regularize the absolute value of coherence matrix for better phase linking. It is first presented in (Zwieback 2022).\n\nZwieback, S. 2022. “Cheap, Valid Regularizers for Improved Interferometric Phase Linking.” IEEE Geoscience and Remote Sensing Letters 19: 1–4. https://doi.org/10.1109/LGRS.2022.3197423.\nExamples:\n\n\nCode for generating data for doc\nrslc = zarr.open('../../data/rslc.zarr/','r')[600:605,600:610]\nrslc = cp.asarray(rslc)\n\n# SHP selection\naz_half_win = 1; r_half_win = 2\naz_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n\nrmli = cp.abs(rslc)**2\nsorted_rmli = cp.sort(rmli,axis=-1)\ndist,p = ks_test(sorted_rmli,az_half_win=az_half_win,r_half_win=r_half_win)\nis_shp = (p &lt; 0.05) & (p &gt;= 0.0)\n\ncov,coh = emperical_co(rslc,is_shp)\n\n\n\ncoh.shape\n\n(5, 10, 17, 17)\n\n\n\nregularized_coh1 = regularize_spectral(coh,0.1)\n\nMore general, bata can be a cp.ndarray:\n\nbeta = cp.ones(coh.shape[:-2])/10\nregularized_coh2 = regularize_spectral(coh,beta)",
    "crumbs": [
      "API",
      "co"
    ]
  },
  {
    "objectID": "API/pl.html",
    "href": "API/pl.html",
    "title": "pl",
    "section": "",
    "text": "Code for generating data for test and doc\nimport numpy as np\nimport zarr\nfrom decorrelation.shp import ks_test\nfrom decorrelation.co import emperical_co,emperical_co_pc, regularize_spectral\ntry:\n    import cupy as cp\nexcept:\n    pass\nfrom matplotlib import pyplot as plt",
    "crumbs": [
      "API",
      "pl"
    ]
  },
  {
    "objectID": "API/pl.html#emi",
    "href": "API/pl.html#emi",
    "title": "pl",
    "section": "EMI",
    "text": "EMI\n\nsource\n\nemi\n\n emi (coh:cupy.ndarray, ref:int=0)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoh\nndarray\n\ncomplex coherence metrix,dtype cupy.complex\n\n\nref\nint\n0\nindex of reference image in the phase history output, optional. Default: 0\n\n\nReturns\ntuple\n\nestimated phase history ph, dtype complex; quality (minimum eigvalue, dtype float)\n\n\n\nemi is a phase estimator base on Eigendecomposition-based Maximum-likelihood-estimator of Interferometric phase (EMI) (Ansari, De Zan, and Bamler 2018) phase linking method.\n\nAnsari, Homa, Francesco De Zan, and Richard Bamler. 2018. “Efficient Phase Estimation for Interferogram Stacks.” IEEE Transactions on Geoscience and Remote Sensing 56 (7): 4109–25. https://doi.org/10.1109/TGRS.2018.2826045.\nThe amplitude of coh should range between 0 and 1 and the phase of coh should be the interferometric phase. The returned phase is also complex but the amplitude is setted to 1. The quality factor is a measure for the inadequacy of EMI’s model that adding real-valued dyadic for calibration of real coherence matrix which is generally poorly estimated. It is supposed to larger than 1 and smaller means better.\nExample: Complex coherence matrix from a stack of 17 SLC images:\n\n\nCode for generating data for test and doc\nrslc = zarr.open('../../data/rslc.zarr/','r')\nrslc = cp.asarray(rslc[:])\n\n# SHP selection\naz_half_win = 5; r_half_win = 5\naz_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n\nrmli = cp.abs(rslc)**2\nsorted_rmli = cp.sort(rmli,axis=-1)\ndel rmli\ndist,p = ks_test(sorted_rmli,az_half_win=az_half_win,r_half_win=r_half_win)\nis_shp = (p &lt; 0.05) & (p &gt;= 0.0)\ndel p\n\n# Select DS candidate\nshp_num = cp.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 50\n\nds_can_is_shp = is_shp[is_ds_can]\nds_can_idx = cp.where(is_ds_can)\nds_can_cov, ds_can_coh = emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp)\n\n\n\nds_can_coh.shape\n\n(740397, 17, 17)\n\n\n\nds_can_ph, ds_can_emi_quality = emi(ds_can_coh)\nds_can_ph.shape, ds_can_emi_quality.shape\n\n((740397, 17), (740397,))\n\n\n\ncp.angle(ds_can_ph[:,0])\n\narray([-1.12013545e-08,  1.89226612e-09,  1.36733591e-09, ...,\n       -4.15640944e-09, -1.74935986e-11, -3.61503560e-09], dtype=float32)\n\n\n\nds_can_emi_quality_2d = cp.empty_like(is_ds_can,dtype=ds_can_emi_quality.dtype)\nds_can_emi_quality_2d[:] = cp.nan\nds_can_emi_quality_2d[is_ds_can] = ds_can_emi_quality\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(cp.asnumpy(ds_can_emi_quality_2d),interpolation='nearest',vmin=1,vmax=1.3)\nax.set(title='DS EMI quality factor',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()",
    "crumbs": [
      "API",
      "pl"
    ]
  },
  {
    "objectID": "API/pl.html#temporal-coherence-for-distributed-scatterer",
    "href": "API/pl.html#temporal-coherence-for-distributed-scatterer",
    "title": "pl",
    "section": "Temporal Coherence for Distributed Scatterer",
    "text": "Temporal Coherence for Distributed Scatterer\n\nsource\n\nds_temp_coh\n\n ds_temp_coh (coh:cupy.ndarray, ph=&lt;class 'cupy.ndarray'&gt;)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoh\nndarray\n\ncomplex coherence metrix, dtype cupy.complex\n\n\nph\ntype\nndarray\ncomplex phase history, dtype cupy.complex\n\n\n\nThis function estimate the temporal coherence of DSs which is defined as (Ferretti et al. 2011):\n\nFerretti, Alessandro, Alfio Fumagalli, Fabrizio Novali, Claudio Prati, Fabio Rocca, and Alessio Rucci. 2011. “A New Algorithm for Processing Interferometric Data-Stacks: SqueeSAR.” IEEE Transactions on Geoscience and Remote Sensing 49 (9): 3460–70. https://doi.org/10.1109/TGRS.2011.2124465.\n\\[\\gamma = \\frac{1}{N^2-N} \\sum_{n=1}^{N} \\sum_{k \\neq n}^{N} e^{i\\phi_{nk}} e^{-i(\\theta_n-\\theta_k)}\\]\nWhere \\(\\phi_{nk}\\) is the phase of complex coherence matrix and \\(\\theta_{n}\\) is the phase after phase linking.\n\n\nCode for generating data for test and doc\nrslc = zarr.open('../../data/rslc.zarr/','r')\nrslc = cp.asarray(rslc[:])\n\n# SHP selection\naz_half_win = 5; r_half_win = 5\naz_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n\nrmli = cp.abs(rslc)**2\nsorted_rmli = cp.sort(rmli,axis=-1)\ndel rmli\ndist,p = ks_test(sorted_rmli,az_half_win=az_half_win,r_half_win=r_half_win)\nis_shp = (p &lt; 0.05) & (p &gt;= 0.0)\n\n# Select DS candidate\nshp_num = cp.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 50\n\nds_can_is_shp = is_shp[is_ds_can]\nds_can_idx = cp.where(is_ds_can)\nds_can_cov, ds_can_coh = emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp)\nds_can_ph = emi(ds_can_coh)[0]\n\n\n\nds_can_coh.shape,ds_can_ph.shape\n\n((740397, 17, 17), (740397, 17))\n\n\n\nds_can_temp_coh = ds_temp_coh(ds_can_coh,ds_can_ph)\nds_can_temp_coh.shape\n\n(740397,)\n\n\n\nds_can_temp_coh_2d = cp.empty_like(is_ds_can,dtype=ds_can_temp_coh.dtype)\nds_can_temp_coh_2d[:] = cp.nan\nds_can_temp_coh_2d[is_ds_can] = ds_can_temp_coh\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(cp.asnumpy(ds_can_temp_coh_2d),interpolation='nearest')\nax.set(title='DS Temporal Coherence',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()",
    "crumbs": [
      "API",
      "pl"
    ]
  },
  {
    "objectID": "API/plot.html",
    "href": "API/plot.html",
    "title": "plot",
    "section": "",
    "text": "from matplotlib import pyplot as plt\nimport colorcet\nimport toml\n\nVisualization of big data is hard.\nFor big raster image, ploting every pixels consumes too much time and memory and common picture format (e.g. png) do not support too big image. One common solution is to resample to a smaller image and plot it, which is the default option for common plot package (e.g. matplotlib). But it will reduce the resolution and prevent showing local features.\nFor big point cloud image, besides the time and memory consumming, the overlapping of rendered points is also a problem.\nHere we provide the plot functions based on Holoviews and Datashader fix the problems. The point cloud is resampled to a small raster image and then plotted on the screen. The pixel size of the raster image is exactly matching the resolution of the screen to maximize the accuracy. The plot is interative and the resampling is dynamic, which means when you zoom in, a more precise raster image is automatically generated and plotted.\n\n\n\n\n\n\nNote\n\n\n\nNote that the plotting functions here make use of dynamic updates, which require a running Jupyter server. When viewed statically (as this documentation website), the plots will not update fully when you zoom.\n\n\n\nimport holoviews as hv\nimport datashader as ds\nimport spatialpandas\nimport zarr\nimport numpy as np\nfrom holoviews import opts\n\n\nhv.extension('bokeh')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\nsource\n\nraster\n\n raster (p:numpy.ndarray, kdims:list, pdim:str, bounds:tuple=None,\n         prange:tuple=None, aggregator=&lt;class\n         'datashader.reductions.first'&gt;, use_hover:bool=True)\n\nInterative visulization of a raster image.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\np\nndarray\n\ndata to be plot, shape (n,m)\n\n\nkdims\nlist\n\nname of coordinates (x, y)\n\n\npdim\nstr\n\nname of data to be plotted\n\n\nbounds\ntuple\nNone\nextent of the raster, (x0, y0, x1 and y1), (0,0,m,n) )by default\n\n\nprange\ntuple\nNone\nrange of data to be plotted, it is interactively adjusted by default\n\n\naggregator\ntype\nfirst\naggregator for data rasterization\n\n\nuse_hover\nbool\nTrue\nuse hover to show data\n\n\n\n\nrslc_ = '../Tutorials/CLI/load_data/rslc.zarr/'\nrslc = zarr.open(rslc_,'r')[...,0:3]\n\n\nraster_plot = raster(np.angle(rslc[...,2]*rslc[...,0].conj()),kdims=['Range','Azimuth'],pdim='Phase',prange=(-np.pi,np.pi))\n\n\nraster_plot.opts(opts.Image(cmap='colorwheel',width=600, height=400, colorbar=True, xlabel='Range', ylabel='Azimuth',invert_yaxis=True))\n\n\n\n\n\n  \n\n\n\n\n\n# plt.imshow(np.angle(rslc[...,2]*rslc[...,0].conj()))\n\n\nsource\n\n\nraster_stack\n\n raster_stack (p:numpy.ndarray, kdims:list, tdim:str, pdim:str,\n               bounds:tuple=None, t:list=None, prange:tuple=None,\n               aggregator=&lt;class 'datashader.reductions.first'&gt;,\n               use_hover:bool=True)\n\nInterative visulization of a raster image.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\np\nndarray\n\ndata to be plot, shape (n,m,l)\n\n\nkdims\nlist\n\nname of coordinates (x, y)\n\n\ntdim\nstr\n\nname of coordiantes (t,)\n\n\npdim\nstr\n\nname of data to be plotted\n\n\nbounds\ntuple\nNone\nextent of the raster, (x0, y0, x1 and y1), (0,0,m,n) )by default\n\n\nt\nlist\nNone\nt coordinate of the plot, len: l, list of string. [‘0’,‘1’,…] by default\n\n\nprange\ntuple\nNone\nrange of data to be plotted, it is interactively adjusted by default\n\n\naggregator\ntype\nfirst\naggregator for data rasterization\n\n\nuse_hover\nbool\nTrue\nuse hover to show data\n\n\n\n\nrslc_ = '../Tutorials/CLI/load_data/rslc.zarr/'\nrslc = zarr.open(rslc_,'r')[:]\ndates_str = toml.load('../Tutorials/CLI/load_data/meta.toml')['dates']\n\n\nraster_stack_plot = raster_stack(np.angle(rslc*rslc[...,[0]].conj()),\n                                 kdims=['Range','Azimuth'], tdim = 'Date',pdim='Phase',\n                                 t=dates_str,\n                                 prange=(-np.pi,np.pi))\n\n\nhv.output(widget_location='bottom',holomap='scrubber')\n\n\nraster_stack_plot.opts(opts.Image(cmap='colorwheel',width=600, height=400, colorbar=True, xlabel='Range', ylabel='Azimuth',invert_yaxis=True))\n\n\n\n\n\n  \n\n\n\n\nDask array is currently not supported. It will be supported in the future.\n\n# import dask\n# from dask import array as da\n# from dask.distributed import Client, LocalCluster\n\n# cluster = LocalCluster(); client = Client(cluster)\n\n# rslc = da.from_zarr(rslc_)\n# raster_stack_plot = raster_stack(da.angle(rslc*rslc[...,[0]].conj()),\n#                                  kdims=['Range','Azimuth'], tdim = 'Date',pdim='Phase',\n#                                  t=dates_str,\n#                                  prange=(-np.pi,np.pi))\n\n# raster_stack_plot.opts(opts.Image(cmap='colorwheel',width=600, height=400, colorbar=True, xlabel='Range', ylabel='Azimuth',invert_yaxis=True))\n\n# cluster.close(); client.close()\n\n\nsource\n\n\npoints\n\n points\n         (data:Union[pandas.core.frame.DataFrame,dask_expr._collection.Dat\n         aFrame], kdims:list, pdim:str, prange:tuple=None,\n         aggregator=&lt;class 'datashader.reductions.first'&gt;,\n         use_hover:bool=True, vdims:list=None, google_earth:bool=False)\n\nInterative visulization of a point cloud image.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndata\nUnion\n\ndataset to be plot\n\n\nkdims\nlist\n\ncolomn name of Mercator coordinate in dataframe\n\n\npdim\nstr\n\ncolumn name of data to be plotted in dataframe\n\n\nprange\ntuple\nNone\nrange of data to be plotted, it is interactively adjusted by default\n\n\naggregator\ntype\nfirst\naggregator for data rasterization\n\n\nuse_hover\nbool\nTrue\nuse hover to show data\n\n\nvdims\nlist\nNone\ncolumn name of data showed on hover except kdims and pdim. These two are always showed.\n\n\ngoogle_earth\nbool\nFalse\nif use google earth imagery as the background\n\n\n\nHere we plot interferogram after DS processing:\n\nds_ph_ = '../Tutorials/CLI/ds_processing/ds_ph.zarr/'\nds_e_ = '../Tutorials/CLI/ds_processing/ds_e.zarr/'\nds_n_ = '../Tutorials/CLI/ds_processing/ds_n.zarr/'\nds_lon_ = '../Tutorials/CLI/ds_processing/ds_lon.zarr/'\nds_lat_ = '../Tutorials/CLI/ds_processing/ds_lat.zarr/'\nds_ph = zarr.open(ds_ph_,'r')[:]\nds_e = zarr.open(ds_e_,'r')[:]\nds_n = zarr.open(ds_n_,'r')[:]\nds_lon = zarr.open(ds_lon_,'r')[:]\nds_lat = zarr.open(ds_lat_,'r')[:]\n\n\n# data = pd.DataFrame({'e':ds_e,'n':ds_n,'phase':np.angle(ds_ph[:,10]),'lon':ds_lon,'lat':ds_lat})\ncoordinates = spatialpandas.geometry.PointArray((ds_e, ds_n))\ndata = spatialpandas.GeoDataFrame({'geometry':coordinates,'phase':np.angle(ds_ph[:,10]),'lon':ds_lon,'lat':ds_lat})\nplot = points(data,kdims=['e','n'],pdim='phase',prange=(-np.pi,np.pi),vdims=['lon','lat'],google_earth=True)\n\nMake some options on the plot:\n\nplot.opts(opts.Image(cmap='colorwheel',width=600, height=400, colorbar=True, xlabel='Longitude', ylabel='Latitude'),\n          opts.Points(marker='o',size=10,tools=['hover']))\n\n\n\n\n\n  \n\n\n\n\nDask dataframe is also supported:\n\nimport dask\nfrom dask import array as da\nfrom dask import dataframe as dd\nfrom dask.distributed import Client, LocalCluster\n\n\ncluster = LocalCluster(); client = Client(cluster)\n\nError.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)\n\n\n\nds_ph = da.from_zarr(ds_ph_)\nds_e = da.from_zarr(ds_e_)\nds_n = da.from_zarr(ds_n_)\nds_lon = da.from_zarr(ds_lon_)\nds_lat = da.from_zarr(ds_lat_)\n\nds_data = da.stack([ds_e,ds_n,ds_lon,ds_lat,da.angle(ds_ph[:,10])]).T\nds_df = dd.from_dask_array(ds_data,columns=['e','n','lon','lat','phase'])\nds_df = ds_df.persist() # only do it if the memory is enough\nplot = points(ds_df,kdims=['e','n'],pdim='phase',prange=(-np.pi,np.pi),vdims=['lon','lat'],google_earth=True)\n\n\nplot.opts(opts.Image(cmap='colorwheel',width=600, height=400, colorbar=True, xlabel='Longitude', ylabel='Latitude'),\n          opts.Points(marker='o',size=10,tools=['hover']))\n\n\n\n\n\n  \n\n\n\n\n\ncluster.close(); client.close()\n\n\nsource\n\n\npoints_stack\n\n points_stack\n               (data:Union[pandas.core.frame.DataFrame,dask_expr._collecti\n               on.DataFrame], kdims:list, pdata:Union[pandas.core.frame.Da\n               taFrame,dask_expr._collection.DataFrame], pdim:str,\n               prange:tuple=None, aggregator=&lt;class\n               'datashader.reductions.first'&gt;, use_hover:bool=True,\n               vdims:list=None, google_earth:bool=False)\n\nInterative visulization of a stack of point cloud images.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndata\nUnion\n\ncommon data in all plots\n\n\nkdims\nlist\n\ncolomn name of Mercator coordinate in dataframe\n\n\npdata\nUnion\n\ndata to be plotted as color\n\n\npdim\nstr\n\nlabel of pdata\n\n\nprange\ntuple\nNone\nrange of pdata, it is interactively adjusted by default\n\n\naggregator\ntype\nfirst\naggregator for data rasterization\n\n\nuse_hover\nbool\nTrue\nuse hover to show other column\n\n\nvdims\nlist\nNone\ncolumn name of data showed on hover except kdims which are always showed.\n\n\ngoogle_earth\nbool\nFalse\nif use google earth imagery as the background\n\n\n\n\nds_ph_ = '../Tutorials/CLI/ds_processing/ds_ph.zarr/'\nds_e_ = '../Tutorials/CLI/ds_processing/ds_e.zarr/'\nds_n_ = '../Tutorials/CLI/ds_processing/ds_n.zarr/'\nds_lon_ = '../Tutorials/CLI/ds_processing/ds_lon.zarr/'\nds_lat_ = '../Tutorials/CLI/ds_processing/ds_lat.zarr/'\nds_ph = zarr.open(ds_ph_,'r')[:]\nds_e = zarr.open(ds_e_,'r')[:]\nds_n = zarr.open(ds_n_,'r')[:]\nds_lon = zarr.open(ds_lon_,'r')[:]\nds_lat = zarr.open(ds_lat_,'r')[:]\n\nmeta_file = '../CLI/raw/meta.toml'\nwith open(meta_file,'r') as f:\n    meta_data = toml.load(f)\ndates = meta_data['dates']\n\n\n# data = pd.DataFrame({'e':ds_e,'n':ds_n,'lon':ds_lon,'lat':ds_lat,'idx':np.arange(len(ds_e))})\ncoordinates = spatialpandas.geometry.PointArray((ds_e, ds_n))\ndata = spatialpandas.GeoDataFrame({'geometry':coordinates,'lon':ds_lon,'lat':ds_lat,'idx':np.arange(len(ds_e))})\npdata = pd.DataFrame(np.angle(ds_ph),columns=dates)\n\n\nplot_stack = points_stack(data,['e','n'],pdata,'phase',prange=(-np.pi,np.pi),vdims=['lon','lat','idx'],google_earth=True)\n\n\nhv.output(widget_location='bottom',holomap='scrubber')\n\n\nplot_stack.opts(opts.Image(cmap='colorwheel',width=600, height=400, colorbar=True, xlabel='Longitude', ylabel='Latitude'),\n                opts.Points(marker='o',size=10))\n\n\n\n\n\n  \n\n\n\n\nPlot selected images simutaneously is also supported:\n\nplot_stack.layout()[dates[0:4]].cols(2)\n\n\n\n\n\n  \n\n\n\n\nDask is also supported\n\ncluster = LocalCluster(); client = Client(cluster)\n\nError.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)Error.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)\n\n\n\nds_ph = da.from_zarr(ds_ph_)\nds_e = da.from_zarr(ds_e_)\nds_n = da.from_zarr(ds_n_)\nds_lon = da.from_zarr(ds_lon_)\nds_lat = da.from_zarr(ds_lat_)\n\nmeta_file = '../CLI/raw/meta.toml'\nwith open(meta_file,'r') as f:\n    meta_data = toml.load(f)\ndates = meta_data['dates']\n\ndata = da.stack([ds_e,ds_n,ds_lon,ds_lat]).T\ndata = dd.from_dask_array(data,columns=['e','n','lon','lat'])\npdata = dd.from_dask_array(da.angle(ds_ph),columns=dates)\ndata = data.persist(); pdata=pdata.persist() # only do it if the memory is enough\n\n\nplot_stack = points_stack(data,kdims=['e','n'],pdata=pdata,pdim='phase',prange=(-np.pi,np.pi),vdims=['lon','lat'],google_earth=True)\n\n\nhv.output(widget_location='bottom',holomap='scrubber')\n\n\nplot_stack.opts(opts.Image(cmap='colorwheel',width=600, height=400, colorbar=True, xlabel='Longitude', ylabel='Latitude'),\n                opts.Points(marker='o',size=10))\n\n\n\n\n\n  \n\n\n\n\n\ncluster.close(); client.close()",
    "crumbs": [
      "API",
      "plot"
    ]
  },
  {
    "objectID": "Tutorials/CLI/load_data.html",
    "href": "Tutorials/CLI/load_data.html",
    "title": "Load Data",
    "section": "",
    "text": "Currently, only interface to the GAMMA software is porvided.",
    "crumbs": [
      "Tutorials",
      "CLI",
      "Load Data"
    ]
  },
  {
    "objectID": "Tutorials/CLI/load_data.html#load-gamma-result",
    "href": "Tutorials/CLI/load_data.html#load-gamma-result",
    "title": "Load Data",
    "section": "Load GAMMA result",
    "text": "Load GAMMA result\nThe data from gamma software needed for this tutorial:\n\n!ls -R ../../../data/gamma/\n\n../../../data/gamma/:\nDEM  geocoding  rslc\n\n../../../data/gamma/DEM:\ndem_seg  dem_seg_par\n\n../../../data/gamma/geocoding:\n20210802.diff_par  20210802.lt_fine  20210802.lv_theta\n20210802.hgt       20210802.lv_phi\n\n../../../data/gamma/rslc:\n20210802.rslc      20211011.rslc.par  20220718.rslc  20220912.rslc.par\n20210802.rslc.par  20211025.rslc      20220718.rslc.par  20220926.rslc\n20210816.rslc      20211025.rslc.par  20220801.rslc  20220926.rslc.par\n20210816.rslc.par  20220606.rslc      20220801.rslc.par  20221010.rslc\n20210830.rslc      20220606.rslc.par  20220815.rslc  20221010.rslc.par\n20210830.rslc.par  20220620.rslc      20220815.rslc.par  20221024.rslc\n20210913.rslc      20220620.rslc.par  20220829.rslc  20221024.rslc.par\n20210913.rslc.par  20220704.rslc      20220829.rslc.par\n20211011.rslc      20220704.rslc.par  20220912.rslc\n\n\nAnd we load them with functions in the load module:\n\nfrom decorrelation.cli.load import (de_load_gamma_flatten_rslc,\n                                    de_load_gamma_lat_lon_hgt,\n                                    de_load_gamma_look_vector,\n                                    de_load_gamma_range,\n                                    de_load_gamma_metadata)\nfrom decorrelation.cli.utils.logging import get_logger\n\n\nlogger = get_logger()\n\n\nrslc_dir = '../../../data/gamma/rslc'\nreference = '20220620'\nrslc_par = '../../../data/gamma/rslc/20220620.rslc.par'\nhgt = '../../../data/gamma/geocoding/20210802.hgt'\nlt = '../../../data/gamma/geocoding/20210802.lt_fine'\ndiff_par = '../../../data/gamma/geocoding/20210802.diff_par'\ndem_par = '../../../data/gamma/DEM/dem_seg_par'\ntheta = '../../../data/gamma/geocoding/20210802.lv_theta'\nphi = '../../../data/gamma/geocoding/20210802.lv_phi'\naz_chunk_size = 1000\nr_chunk_size = 1000\n\nscratch_dir = './load_data/scratch'\nrslc_zarr = './load_data/rslc.zarr'\nlat_zarr = './load_data/lat.zarr'\nlon_zarr = './load_data/lon.zarr'\ntheta_zarr = './load_data/theta.zarr'\nphi_zarr = './load_data/phi.zarr'\nhgt_zarr = './load_data/hgt.zarr'\nrange_zarr = './load_data/range.zarr'\nmeta_file = './load_data/meta.toml'\n\n\nde_load_gamma_flatten_rslc(rslc_dir,reference,hgt,scratch_dir,rslc_zarr,az_chunk_size=az_chunk_size,r_chunk_size=r_chunk_size)\nde_load_gamma_lat_lon_hgt(diff_par,rslc_par,dem_par,hgt,scratch_dir,lat_zarr,lon_zarr,hgt_zarr,az_chunk_size=az_chunk_size,r_chunk_size=r_chunk_size)\nde_load_gamma_look_vector(theta,phi,lt,rslc_par,dem_par,scratch_dir,theta_zarr,phi_zarr,az_chunk_size=az_chunk_size,r_chunk_size=r_chunk_size)\nde_load_gamma_range(rslc_par,range_zarr,az_chunk_size=az_chunk_size,r_chunk_size=r_chunk_size)\nde_load_gamma_metadata(rslc_dir,reference,meta_file)\n\n2023-11-05 23:34:04 - logging_args - INFO - running function: de_load_gamma_flatten_rslc\n2023-11-05 23:34:04 - logging_args - INFO - fetching args:\n2023-11-05 23:34:04 - logging_args - INFO - rslc_dir = '../../../data/gamma/rslc'\n2023-11-05 23:34:04 - logging_args - INFO - reference = '20220620'\n2023-11-05 23:34:04 - logging_args - INFO - hgt = '../../../data/gamma/geocoding/20210802.hgt'\n2023-11-05 23:34:04 - logging_args - INFO - scratch_dir = './load_data/scratch'\n2023-11-05 23:34:04 - logging_args - INFO - rslc_zarr = './load_data/rslc.zarr'\n2023-11-05 23:34:04 - logging_args - INFO - az_chunk_size = 1000\n2023-11-05 23:34:04 - logging_args - INFO - r_chunk_size = 1000\n2023-11-05 23:34:04 - logging_args - INFO - fetching args done.\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - rslc found: \n        date                                    rslc  \\\n0   20210802  ../../../data/gamma/rslc/20210802.rslc   \n1   20210816  ../../../data/gamma/rslc/20210816.rslc   \n2   20210830  ../../../data/gamma/rslc/20210830.rslc   \n3   20210913  ../../../data/gamma/rslc/20210913.rslc   \n4   20211011  ../../../data/gamma/rslc/20211011.rslc   \n5   20211025  ../../../data/gamma/rslc/20211025.rslc   \n6   20220606  ../../../data/gamma/rslc/20220606.rslc   \n7   20220620  ../../../data/gamma/rslc/20220620.rslc   \n8   20220704  ../../../data/gamma/rslc/20220704.rslc   \n9   20220718  ../../../data/gamma/rslc/20220718.rslc   \n10  20220801  ../../../data/gamma/rslc/20220801.rslc   \n11  20220815  ../../../data/gamma/rslc/20220815.rslc   \n12  20220829  ../../../data/gamma/rslc/20220829.rslc   \n13  20220912  ../../../data/gamma/rslc/20220912.rslc   \n14  20220926  ../../../data/gamma/rslc/20220926.rslc   \n15  20221010  ../../../data/gamma/rslc/20221010.rslc   \n16  20221024  ../../../data/gamma/rslc/20221024.rslc   \n\n                                           par  \n0   ../../../data/gamma/rslc/20210802.rslc.par  \n1   ../../../data/gamma/rslc/20210816.rslc.par  \n2   ../../../data/gamma/rslc/20210830.rslc.par  \n3   ../../../data/gamma/rslc/20210913.rslc.par  \n4   ../../../data/gamma/rslc/20211011.rslc.par  \n5   ../../../data/gamma/rslc/20211025.rslc.par  \n6   ../../../data/gamma/rslc/20220606.rslc.par  \n7   ../../../data/gamma/rslc/20220620.rslc.par  \n8   ../../../data/gamma/rslc/20220704.rslc.par  \n9   ../../../data/gamma/rslc/20220718.rslc.par  \n10  ../../../data/gamma/rslc/20220801.rslc.par  \n11  ../../../data/gamma/rslc/20220815.rslc.par  \n12  ../../../data/gamma/rslc/20220829.rslc.par  \n13  ../../../data/gamma/rslc/20220912.rslc.par  \n14  ../../../data/gamma/rslc/20220926.rslc.par  \n15  ../../../data/gamma/rslc/20221010.rslc.par  \n16  ../../../data/gamma/rslc/20221024.rslc.par  \n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - number of images: 17.\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - image number of lines: 2500.\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - image width: 1834.\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - run gamma command to generate required data for flattened rslcs:\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20210802.rslc.par load_data/scratch/20220620_20210802.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20210802.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20210802.rslc.par load_data/scratch/20220620_20210802.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20210802.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20210816.rslc.par load_data/scratch/20220620_20210816.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20210816.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20210816.rslc.par load_data/scratch/20220620_20210816.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20210816.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20210830.rslc.par load_data/scratch/20220620_20210830.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20210830.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20210830.rslc.par load_data/scratch/20220620_20210830.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20210830.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20210913.rslc.par load_data/scratch/20220620_20210913.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20210913.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20210913.rslc.par load_data/scratch/20220620_20210913.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20210913.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20211011.rslc.par load_data/scratch/20220620_20211011.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20211011.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20211011.rslc.par load_data/scratch/20220620_20211011.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20211011.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20211025.rslc.par load_data/scratch/20220620_20211025.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20211025.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20211025.rslc.par load_data/scratch/20220620_20211025.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20211025.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220606.rslc.par load_data/scratch/20220620_20220606.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20220606.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220606.rslc.par load_data/scratch/20220620_20220606.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20220606.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220620.rslc.par load_data/scratch/20220620_20220620.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20220620.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220620.rslc.par load_data/scratch/20220620_20220620.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20220620.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220704.rslc.par load_data/scratch/20220620_20220704.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20220704.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220704.rslc.par load_data/scratch/20220620_20220704.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20220704.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220718.rslc.par load_data/scratch/20220620_20220718.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20220718.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220718.rslc.par load_data/scratch/20220620_20220718.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20220718.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220801.rslc.par load_data/scratch/20220620_20220801.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20220801.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220801.rslc.par load_data/scratch/20220620_20220801.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20220801.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220815.rslc.par load_data/scratch/20220620_20220815.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20220815.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220815.rslc.par load_data/scratch/20220620_20220815.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20220815.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220829.rslc.par load_data/scratch/20220620_20220829.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20220829.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220829.rslc.par load_data/scratch/20220620_20220829.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20220829.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220912.rslc.par load_data/scratch/20220620_20220912.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20220912.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220912.rslc.par load_data/scratch/20220620_20220912.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20220912.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220926.rslc.par load_data/scratch/20220620_20220926.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20220926.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220926.rslc.par load_data/scratch/20220620_20220926.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20220926.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20221010.rslc.par load_data/scratch/20220620_20221010.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20221010.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20221010.rslc.par load_data/scratch/20220620_20221010.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20221010.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20221024.rslc.par load_data/scratch/20220620_20221024.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20221024.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20221024.rslc.par load_data/scratch/20220620_20221024.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20221024.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - gamma command finished.\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - using dask to load data in gamma binary format to calculate flatten rslcs and save it to zarr.\n2023-11-05 23:34:04 - de_load_gamma_flatten_rslc - INFO - starting dask local cluster.\n2023-11-05 23:34:08 - de_load_gamma_flatten_rslc - INFO - dask local cluster started.\n2023-11-05 23:34:08 - darr_info - INFO - flattened rslc dask array shape: (2500, 1834, 17)\n2023-11-05 23:34:08 - darr_info - INFO - flattened rslc dask array chunksize: (1000, 1000, 1)\n2023-11-05 23:34:08 - darr_info - INFO - flattened rslc dask array dtype: complex64\n2023-11-05 23:34:09 - de_load_gamma_flatten_rslc - INFO - computing graph setted. doing all the computing.\n2023-11-05 23:34:13 - de_load_gamma_flatten_rslc - INFO - computing finished.\n2023-11-05 23:34:14 - de_load_gamma_flatten_rslc - INFO - dask cluster closed.\n2023-11-05 23:34:14 - logging_args - INFO - running function: de_load_gamma_lat_lon_hgt\n2023-11-05 23:34:14 - logging_args - INFO - fetching args:\n2023-11-05 23:34:14 - logging_args - INFO - diff_par = '../../../data/gamma/geocoding/20210802.diff_par'\n2023-11-05 23:34:14 - logging_args - INFO - rslc_par = '../../../data/gamma/rslc/20220620.rslc.par'\n2023-11-05 23:34:14 - logging_args - INFO - dem_par = '../../../data/gamma/DEM/dem_seg_par'\n2023-11-05 23:34:14 - logging_args - INFO - hgt = '../../../data/gamma/geocoding/20210802.hgt'\n2023-11-05 23:34:14 - logging_args - INFO - scratch_dir = './load_data/scratch'\n2023-11-05 23:34:14 - logging_args - INFO - lat_zarr = './load_data/lat.zarr'\n2023-11-05 23:34:14 - logging_args - INFO - lon_zarr = './load_data/lon.zarr'\n2023-11-05 23:34:14 - logging_args - INFO - hgt_zarr = './load_data/hgt.zarr'\n2023-11-05 23:34:14 - logging_args - INFO - az_chunk_size = 1000\n2023-11-05 23:34:14 - logging_args - INFO - r_chunk_size = 1000\n2023-11-05 23:34:14 - logging_args - INFO - fetching args done.\n2023-11-05 23:34:14 - de_load_gamma_lat_lon_hgt - INFO - image shape: (2500,1834)\n2023-11-05 23:34:14 - de_load_gamma_lat_lon_hgt - INFO - run gamma command to generate longitude, latitude and height:\n2023-11-05 23:34:14 - de_load_gamma_lat_lon_hgt - INFO - load_data/scratch/plist exists. skip runing mkgrid load_data/scratch/plist 1834 2500 1 1 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:14 - de_load_gamma_lat_lon_hgt - INFO - load_data/scratch/phgt_wgs84 exists. skip runing pt2geo load_data/scratch/plist - ../../../data/gamma/rslc/20220620.rslc.par - ../../../data/gamma/geocoding/20210802.hgt ../../../data/gamma/DEM/dem_seg_par ../../../data/gamma/geocoding/20210802.diff_par 1 1 - - load_data/scratch/plat_lon load_data/scratch/phgt_wgs84 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:14 - de_load_gamma_lat_lon_hgt - INFO - writing zarr file.\n2023-11-05 23:34:15 - de_load_gamma_lat_lon_hgt - INFO - write done.\n2023-11-05 23:34:15 - logging_args - INFO - running function: de_load_gamma_look_vector\n2023-11-05 23:34:15 - logging_args - INFO - fetching args:\n2023-11-05 23:34:15 - logging_args - INFO - theta = '../../../data/gamma/geocoding/20210802.lv_theta'\n2023-11-05 23:34:15 - logging_args - INFO - phi = '../../../data/gamma/geocoding/20210802.lv_phi'\n2023-11-05 23:34:15 - logging_args - INFO - lt = '../../../data/gamma/geocoding/20210802.lt_fine'\n2023-11-05 23:34:15 - logging_args - INFO - rslc_par = '../../../data/gamma/rslc/20220620.rslc.par'\n2023-11-05 23:34:15 - logging_args - INFO - dem_par = '../../../data/gamma/DEM/dem_seg_par'\n2023-11-05 23:34:15 - logging_args - INFO - scratch_dir = './load_data/scratch'\n2023-11-05 23:34:15 - logging_args - INFO - theta_zarr = './load_data/theta.zarr'\n2023-11-05 23:34:15 - logging_args - INFO - phi_zarr = './load_data/phi.zarr'\n2023-11-05 23:34:15 - logging_args - INFO - az_chunk_size = 1000\n2023-11-05 23:34:15 - logging_args - INFO - r_chunk_size = 1000\n2023-11-05 23:34:15 - logging_args - INFO - fetching args done.\n2023-11-05 23:34:15 - de_load_gamma_look_vector - INFO - image shape: (2500,1834)\n2023-11-05 23:34:15 - de_load_gamma_look_vector - INFO - load_data/scratch/theta_rdc exists. skip runing geocode ../../../data/gamma/geocoding/20210802.lt_fine ../../../data/gamma/geocoding/20210802.lv_theta 5741 load_data/scratch/theta_rdc 1834 2500 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:15 - de_load_gamma_look_vector - INFO - writing data.\n2023-11-05 23:34:15 - de_load_gamma_look_vector - INFO - load_data/scratch/phi_rdc exists. skip runing geocode ../../../data/gamma/geocoding/20210802.lt_fine ../../../data/gamma/geocoding/20210802.lv_phi 5741 load_data/scratch/phi_rdc 1834 2500 &gt;&gt; load_data/scratch/gamma.log\n2023-11-05 23:34:15 - de_load_gamma_look_vector - INFO - writing data.\n2023-11-05 23:34:16 - de_load_gamma_look_vector - INFO - Done.\n2023-11-05 23:34:16 - logging_args - INFO - running function: de_load_gamma_range\n2023-11-05 23:34:16 - logging_args - INFO - fetching args:\n2023-11-05 23:34:16 - logging_args - INFO - rslc_par = '../../../data/gamma/rslc/20220620.rslc.par'\n2023-11-05 23:34:16 - logging_args - INFO - range_zarr = './load_data/range.zarr'\n2023-11-05 23:34:16 - logging_args - INFO - az_chunk_size = 1000\n2023-11-05 23:34:16 - logging_args - INFO - r_chunk_size = 1000\n2023-11-05 23:34:16 - logging_args - INFO - fetching args done.\n2023-11-05 23:34:16 - de_load_gamma_range - INFO - image shape: (2500,1834)\n2023-11-05 23:34:16 - de_load_gamma_range - INFO - Calculating slant range distance.\n2023-11-05 23:34:16 - de_load_gamma_range - INFO - writing data.\n2023-11-05 23:34:16 - de_load_gamma_range - INFO - Done.\n2023-11-05 23:34:16 - logging_args - INFO - running function: de_load_gamma_metadata\n2023-11-05 23:34:16 - logging_args - INFO - fetching args:\n2023-11-05 23:34:16 - logging_args - INFO - rslc_dir = '../../../data/gamma/rslc'\n2023-11-05 23:34:16 - logging_args - INFO - reference = '20220620'\n2023-11-05 23:34:16 - logging_args - INFO - meta_file = './load_data/meta.toml'\n2023-11-05 23:34:16 - logging_args - INFO - fetching args done.\n2023-11-05 23:34:16 - de_load_gamma_metadata - INFO - Fetching heading angle\n2023-11-05 23:34:16 - de_load_gamma_metadata - INFO - Fetching range pixel spacing\n2023-11-05 23:34:16 - de_load_gamma_metadata - INFO - fetching azimuth pixel spacing\n2023-11-05 23:34:16 - de_load_gamma_metadata - INFO - Fetching randar wavelength\n2023-11-05 23:34:16 - de_load_gamma_metadata - INFO - Run gamma command to calculate baseline:\n2023-11-05 23:34:16 - de_load_gamma_metadata - INFO - run command: base_calc /tmp/tmpw04cl2xz/slc_tab ../../../data/gamma/rslc/20220620.rslc.par /tmp/tmpw04cl2xz/bperp /tmp/tmpw04cl2xz/itab - &gt; /tmp/tmpw04cl2xz/log\n2023-11-05 23:34:16 - de_load_gamma_metadata - INFO - gamma command finished.\n2023-11-05 23:34:16 - de_load_gamma_metadata - INFO - All meta data: \ndates = [ \"20210802\", \"20210816\", \"20210830\", \"20210913\", \"20211011\", \"20211025\", \"20220606\", \"20220620\", \"20220704\", \"20220718\", \"20220801\", \"20220815\", \"20220829\", \"20220912\", \"20220926\", \"20221010\", \"20221024\",]\nradar_wavelength = 0.24245249210715603\nrange_pixel_spacing = 4.29054\nazimuth_pixel_spacing = 3.740105\nperpendicular_baseline = [ -97.61360168457031, -45.58580017089844, 17.86680030822754, -26.258899688720703, -63.72420120239258, -56.363399505615234, 64.75759887695312, 0.0, -9.043999671936035, -13.02869987487793, -112.94960021972656, -86.09490203857422, -129.9635009765625, -127.6594009399414, -182.29519653320312, -129.735107421875, -184.31100463867188,]\n\n2023-11-05 23:34:16 - de_load_gamma_metadata - INFO - writing data in toml file.\n2023-11-05 23:34:16 - de_load_gamma_metadata - INFO - Done.\n\n\nHere we get all needed data: look vector, latitude, lontitude, height, metadata, slant range distance, and flattened rslc stack. For visulization on Google Map tiles, coordinates on Web Mercator projection is needed:\n\nfrom decorrelation.cli.utils.transform import de_transform\n\n\ne_zarr = './load_data/e.zarr'\nn_zarr = './load_data/n.zarr'\n\n\nde_transform(lon_zarr,lat_zarr,e_zarr,n_zarr)\n\n2023-11-05 23:34:16 - logging_args - INFO - running function: de_transform\n2023-11-05 23:34:16 - logging_args - INFO - fetching args:\n2023-11-05 23:34:16 - logging_args - INFO - xx_in = './load_data/lon.zarr'\n2023-11-05 23:34:16 - logging_args - INFO - yy_in = './load_data/lat.zarr'\n2023-11-05 23:34:16 - logging_args - INFO - xx_out = './load_data/e.zarr'\n2023-11-05 23:34:16 - logging_args - INFO - yy_out = './load_data/n.zarr'\n2023-11-05 23:34:16 - logging_args - INFO - epsg_in = 4326\n2023-11-05 23:34:16 - logging_args - INFO - epsg_out = 3857\n2023-11-05 23:34:16 - logging_args - INFO - fetching args done.\n2023-11-05 23:34:16 - de_transform - INFO - input EPSG: 4326.\n2023-11-05 23:34:16 - zarr_info - INFO - xx_in zarray shape: (2500, 1834)\n2023-11-05 23:34:16 - zarr_info - INFO - xx_in zarray chunks: (1000, 1000)\n2023-11-05 23:34:16 - zarr_info - INFO - xx_in zarray dtype: float64\n2023-11-05 23:34:16 - zarr_info - INFO - yy_in zarray shape: (2500, 1834)\n2023-11-05 23:34:16 - zarr_info - INFO - yy_in zarray chunks: (1000, 1000)\n2023-11-05 23:34:16 - zarr_info - INFO - yy_in zarray dtype: float64\n2023-11-05 23:34:16 - de_transform - INFO - output EPSG: 3857.\n2023-11-05 23:34:16 - de_transform - INFO - do the transformation.\n2023-11-05 23:34:18 - de_transform - INFO - write output.\n2023-11-05 23:34:18 - de_transform - INFO - write done.",
    "crumbs": [
      "Tutorials",
      "CLI",
      "Load Data"
    ]
  },
  {
    "objectID": "Tutorials/CLI/load_data.html#water-mask",
    "href": "Tutorials/CLI/load_data.html#water-mask",
    "title": "Load Data",
    "section": "Water Mask",
    "text": "Water Mask\nThe DEM on pixels of water is zero according to the convection of GAMMA so we should remove them:\n\nfrom decorrelation.cli.pc import de_pc_logic_ras\n\n\nde_pc_logic_ras(hgt_zarr, './load_data/non_nan.zarr','ras!=0')\n\n2023-11-05 23:34:18 - logging_args - INFO - running function: de_pc_logic_ras\n2023-11-05 23:34:18 - logging_args - INFO - fetching args:\n2023-11-05 23:34:18 - logging_args - INFO - ras = './load_data/hgt.zarr'\n2023-11-05 23:34:18 - logging_args - INFO - idx = './load_data/non_nan.zarr'\n2023-11-05 23:34:18 - logging_args - INFO - operation = 'ras!=0'\n2023-11-05 23:34:18 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 23:34:18 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 23:34:18 - logging_args - INFO - fetching args done.\n2023-11-05 23:34:18 - zarr_info - INFO - ./load_data/hgt.zarr zarray shape: (2500, 1834)\n2023-11-05 23:34:18 - zarr_info - INFO - ./load_data/hgt.zarr zarray chunks: (1000, 1000)\n2023-11-05 23:34:18 - zarr_info - INFO - ./load_data/hgt.zarr zarray dtype: float32\n2023-11-05 23:34:18 - de_pc_logic_ras - INFO - loading ras into memory.\n2023-11-05 23:34:18 - de_pc_logic_ras - INFO - select pc based on operation: ras!=0\n2023-11-05 23:34:18 - de_pc_logic_ras - INFO - number of selected pixels: 4439623.\n2023-11-05 23:34:18 - get_pc_chunk_size_from_n_ras_chunk - INFO - automatically determine pc_chunk_size from\n            n_pc of idx and n_ras_chunk of ras\n2023-11-05 23:34:18 - get_pc_chunk_size_from_n_ras_chunk - INFO - n_ras_chunk of ras: 6\n2023-11-05 23:34:18 - get_pc_chunk_size_from_n_ras_chunk - INFO - pc_chunk_size for idx: 739938\n2023-11-05 23:34:18 - de_pc_logic_ras - INFO - writing idx.\n2023-11-05 23:34:19 - de_pc_logic_ras - INFO - write done.",
    "crumbs": [
      "Tutorials",
      "CLI",
      "Load Data"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ps_processing.html",
    "href": "Tutorials/CLI/ps_processing.html",
    "title": "PS Processing",
    "section": "",
    "text": "In this tutorial, we demostrate how to do PS processing with the decorrelation CLI interface. The input data for PS processing is prepared in Load Data.\n!ls ./load_data\n\ne.zarr    lat.zarr  meta.toml     n.zarr    range.zarr  scratch\nhgt.zarr  lon.zarr  non_nan.zarr  phi.zarr  rslc.zarr   theta.zarr",
    "crumbs": [
      "Tutorials",
      "CLI",
      "PS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ps_processing.html#amplitude-dispersion-index-calculation",
    "href": "Tutorials/CLI/ps_processing.html#amplitude-dispersion-index-calculation",
    "title": "PS Processing",
    "section": "Amplitude dispersion index calculation",
    "text": "Amplitude dispersion index calculation\nHere were calculate the amplitude dispersion index (ADI) which is used to identify persistent scatterers.\n\nimport zarr\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport colorcet\nfrom decorrelation.cli.utils.logging import get_logger\nfrom decorrelation.cli.ps import de_amp_disp\n\n\nrslc = './load_data/rslc.zarr'\nadi = './ps_processing/adi.zarr'\n\n\nlogger = get_logger()\n\n\nde_amp_disp(rslc,adi)\n\n2023-11-05 23:35:11 - logging_args - INFO - running function: de_amp_disp\n2023-11-05 23:35:11 - logging_args - INFO - fetching args:\n2023-11-05 23:35:11 - logging_args - INFO - rslc = './load_data/rslc.zarr'\n2023-11-05 23:35:11 - logging_args - INFO - adi = './ps_processing/adi.zarr'\n2023-11-05 23:35:11 - logging_args - INFO - az_chunk_size = None\n2023-11-05 23:35:11 - logging_args - INFO - n_az_chunk = None\n2023-11-05 23:35:11 - logging_args - INFO - r_chunk_size = None\n2023-11-05 23:35:11 - logging_args - INFO - n_r_chunk = None\n2023-11-05 23:35:11 - logging_args - INFO - fetching args done.\n2023-11-05 23:35:11 - zarr_info - INFO - ./load_data/rslc.zarr zarray shape: (2500, 1834, 17)\n2023-11-05 23:35:11 - zarr_info - INFO - ./load_data/rslc.zarr zarray chunks: (1000, 1000, 1)\n2023-11-05 23:35:11 - zarr_info - INFO - ./load_data/rslc.zarr zarray dtype: complex64\n2023-11-05 23:35:11 - get_ras_chunk_size_from_ras_chunk_size - INFO - automatically determine az_chunk_size from \n            az_chunk_size of rslc\n2023-11-05 23:35:11 - get_ras_chunk_size_from_ras_chunk_size - INFO - az_chunk_size for adi: 1000\n2023-11-05 23:35:11 - get_ras_chunk_size_from_ras_chunk_size - INFO - automatically determine r_chunk_size from\n            r_chunk_size of rslc\n2023-11-05 23:35:11 - get_ras_chunk_size_from_ras_chunk_size - INFO - r_chunk_size for adi: 1000\n2023-11-05 23:35:11 - de_amp_disp - INFO - starting dask CUDA local cluster.\n2023-11-05 23:35:19 - de_amp_disp - INFO - dask local CUDA cluster started.\n2023-11-05 23:35:19 - darr_info - INFO - rslc dask array shape: (2500, 1834, 17)\n2023-11-05 23:35:19 - darr_info - INFO - rslc dask array chunksize: (1000, 1000, 17)\n2023-11-05 23:35:19 - darr_info - INFO - rslc dask array dtype: complex64\n2023-11-05 23:35:19 - de_amp_disp - INFO - calculate amplitude dispersion index.\n2023-11-05 23:35:19 - de_amp_disp - INFO - got amplitude dispersion index.\n2023-11-05 23:35:19 - darr_info - INFO - adi dask array shape: (2500, 1834)\n2023-11-05 23:35:19 - darr_info - INFO - adi dask array chunksize: (1000, 1000)\n2023-11-05 23:35:19 - darr_info - INFO - adi dask array dtype: float32\n2023-11-05 23:35:19 - de_amp_disp - INFO - saving adi.\n2023-11-05 23:35:19 - de_amp_disp - INFO - computing graph setted. doing all the computing.\n2023-11-05 23:35:20 - de_amp_disp - INFO - computing finished. 1.1s\n2023-11-05 23:35:22 - de_amp_disp - INFO - dask cluster closed.\n\n\n\nadi_zarr = zarr.open(adi,'r')\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(adi_zarr[:],vmin=0,vmax=1)\nax.set(title='Amplitude Dispersion Index',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()",
    "crumbs": [
      "Tutorials",
      "CLI",
      "PS Processing"
    ]
  },
  {
    "objectID": "Tutorials/work_with_dask.html",
    "href": "Tutorials/work_with_dask.html",
    "title": "Work With Dask",
    "section": "",
    "text": "import numpy as np\nimport zarr\nimport cupy as cp\nfrom itertools import product\nimport time\n\nfrom matplotlib import pyplot as plt\nimport colorcet\n\nfrom decorrelation.shp import ks_test\nfrom decorrelation.co import emperical_co_pc\nfrom decorrelation.pl import emi\nfrom dask import array as da\nfrom dask import delayed\nimport dask\nfrom dask.distributed import Client\nfrom dask_cuda import LocalCUDACluster\nfrom dask.distributed import progress\ncluster = LocalCUDACluster(n_workers=2)\nclient = Client(cluster)\n\nCPU times: user 646 ms, sys: 189 ms, total: 836 ms\nWall time: 5.32 s\nIn this tutorial, we demostrate how to use Dask for distributed computing.\nTwo significant issues for InSAR big data processing are: 1) the memory of CPU/GPU does not fit the volume of very big data; 2) the processing speed is limited. For the first issue, one common solution is divide the data into independent chunks and process the chunks one by one. In many case, the processing of chunks are independent. Thus the processing can be speeded up by parallel processing.\nDask is a job scheduler that allows deploying process-level parallel processing. Through the Delayed feature, Dask operations only construct the computing workflow rather than do the computation immediately. All of the computations are done at the end to allow Dask better distributing computing resources for the task. Dask makes the parallel processing easier and enable the decoupling of codes for computation and codes for scheduling.\nIn this demo, we use Dask for multi-GPU KS test to select spatially homogenious pixels. This includes:\nThe KS test is one step of DS processing, the full DS processing precedure is in the DS_processing tutorial. However, that tutorial directly utilize arrays.",
    "crumbs": [
      "Tutorials",
      "Customization",
      "Work With Dask"
    ]
  },
  {
    "objectID": "Tutorials/work_with_dask.html#processing",
    "href": "Tutorials/work_with_dask.html#processing",
    "title": "Work With Dask",
    "section": "Processing",
    "text": "Processing\nLoad data into CPU, and set the chunk size:\n\nrslc_path = '../../data/rslc.zarr'\nrslc_zarr = zarr.open(rslc_path,mode='r')\ncpu_rslc = da.from_zarr(rslc_path,chunks=(2500,1000,17))\n\n\nrslc_zarr.chunks\n\n(1000, 1000, 17)\n\n\n\nrslc_zarr.shape\n\n(2500, 1834, 17)\n\n\nNote that SHP identification requires overlapping region to correctly select brothers of pixels around the chunk bound.\n\naz_half_win = 5\nr_half_win = 5\naz_win = 2*az_half_win+1\nr_win = 2*r_half_win+1\n\n\ndepth = {0:az_half_win, 1:r_half_win, 2:0}; boundary = {0:'none',1:'none',2:'none'}\ncpu_rslc_overlap = da.overlap.overlap(cpu_rslc,depth=depth, boundary=boundary)\n\n\nrslc_overlap = cpu_rslc_overlap.map_blocks(cp.asarray)\nrmli_overlap = da.abs(rslc_overlap)**2\nsorted_rmli_overlap = rmli_overlap.map_blocks(cp.sort,axis=-1)\n\nDask provide a convenient function map_blocks to apply function on every chunk. However, it only support function that have only one output. Here we manually do the mapping:\n\ndelayed_ks_test = delayed(ks_test,pure=True,nout=2)\nrmli_delayed = sorted_rmli_overlap.to_delayed()\np_delayed = np.empty_like(rmli_delayed,dtype=object)\ndist_delayed = np.empty_like(rmli_delayed,dtype=object)\n\n\nwith np.nditer(p_delayed,flags=['multi_index','refs_ok'], op_flags=['readwrite']) as p_it:\n    for p_block in p_it:\n        idx = p_it.multi_index\n        dist_delayed[idx],p_delayed[idx] = delayed_ks_test(rmli_delayed[idx],az_half_win=az_half_win,r_half_win=r_half_win)\n\n        chunk_shape = (*sorted_rmli_overlap.blocks[idx].shape[:-1],az_win,r_win)\n        dtype = sorted_rmli_overlap.dtype\n        dist_delayed[idx] = da.from_delayed(dist_delayed[idx],shape=chunk_shape,meta=cp.array((),dtype=dtype))\n        p_delayed[idx] = da.from_delayed(p_delayed[idx],shape=chunk_shape,meta=cp.array((),dtype=dtype))\n\n\np = da.block(p_delayed.reshape(*p_delayed.shape,1).tolist())\ndist = da.block(dist_delayed.reshape(*dist_delayed.shape,1).tolist())\n\nAfter we get the result, the overlapping region need to be trimed:\n\ndepth = {0:az_half_win, 1:r_half_win, 2:0, 3:0}; boundary = {0:'none',1:'none',2:'none',3:'none'}\ndist = da.overlap.trim_overlap(dist,depth=depth,boundary=boundary)\np = da.overlap.trim_overlap(p,depth=depth,boundary=boundary)\n\nSelect SHPs based on p-value threshold:\n\nis_shp = (p &lt; 0.05) & (p &gt;= 0.0)\n\n\nshp_num = da.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 50\n\n\ncpu_dist = da.map_blocks(cp.asnumpy,dist)\ncpu_p = da.map_blocks(cp.asnumpy,p)\ncpu_is_shp = da.map_blocks(cp.asnumpy,is_shp)\ncpu_shp_num = da.map_blocks(cp.asnumpy,shp_num)\ncpu_is_ds_can = da.map_blocks(cp.asnumpy,is_ds_can)\n\nSave the data to disk:\n\n_cpu_dist = cpu_dist.to_zarr('dist.zarr',overwrite=True,compute=False)\n_cpu_p = cpu_p.to_zarr('p.zarr',overwrite=True,compute=False)\n\nDo the computation:\n\nfutures = client.persist([_cpu_dist,_cpu_p,cpu_shp_num,cpu_is_ds_can])\nprogress(futures)\n\n\n\n\n\nshp_num_result, is_ds_can_result = da.compute(futures)[0][2:]\n\n\ncluster.close()\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(shp_num_result,cmap=colorcet.cm.fire)\nax.set(title='Number of SHPs',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\n\n\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(is_ds_can_result,cmap=colorcet.cm.fire)\nax.set(title='DS Candidate distribution',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\n\n\n\n\nimport numpy as np\nimport zarr\nimport cupy as cp\nfrom decorrelation.shp import ks_test\nrslc_zarr = zarr.open('../../data/rslc.zarr',mode='r')\nrslc_cpu = rslc_zarr[:]\nrslc = cp.asarray(rslc_cpu)\nrmli = cp.abs(rslc)**2\nsorted_rmli = cp.sort(rmli,axis=-1)\naz_half_win = 5\nr_half_win = 5\naz_win = 2*az_half_win+1\nr_win = 2*r_half_win+1\ndist,p = ks_test(sorted_rmli,az_half_win=az_half_win,r_half_win=r_half_win)\ndist_cpu = cp.asnumpy(dist)\np_cpu = cp.asnumpy(p)\nzarr.save_array('dist_ks.zarr', dist_cpu,chunks=(1000,1000,az_win,r_win),compressor=None)\nzarr.save_array('p_ks.zarr', p_cpu,chunks=(1000,1000,az_win,r_win),compressor=None)\n\nCPU times: user 1.27 s, sys: 5.68 s, total: 6.95 s\nWall time: 8.21 s",
    "crumbs": [
      "Tutorials",
      "Customization",
      "Work With Dask"
    ]
  },
  {
    "objectID": "Tutorials/ds_processing.html",
    "href": "Tutorials/ds_processing.html",
    "title": "DS Processing",
    "section": "",
    "text": "In this tutorial, we demostrate how to do standard DS processing with the decorrelation package.\nimport numpy as np\nimport zarr\nfrom matplotlib import pyplot as plt\nimport colorcet\n\nimport cupy as cp\nfrom cupyx.scipy.ndimage import uniform_filter\n\nfrom decorrelation.shp import ks_test\nfrom decorrelation.plot import bg_alpha\nfrom decorrelation.co import emperical_co_pc, isPD\nfrom decorrelation.pl import emi, ds_temp_coh",
    "crumbs": [
      "Tutorials",
      "API",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/ds_processing.html#load-rslc-stack",
    "href": "Tutorials/ds_processing.html#load-rslc-stack",
    "title": "DS Processing",
    "section": "Load rslc stack",
    "text": "Load rslc stack\n\nrslc = cp.asarray(zarr.open('../../data/rslc.zarr','r')[:])\nrslc.shape\n\n(2500, 1834, 17)",
    "crumbs": [
      "Tutorials",
      "API",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/ds_processing.html#apply-ks-test",
    "href": "Tutorials/ds_processing.html#apply-ks-test",
    "title": "DS Processing",
    "section": "Apply ks test",
    "text": "Apply ks test\n\nrmli = cp.abs(rslc)**2\nsorted_rmli = cp.sort(rmli,axis=-1)\n\n\naz_half_win = 5\nr_half_win = 5\naz_win = 2*az_half_win+1\nr_win = 2*r_half_win+1\n\n\np = ks_test(sorted_rmli,az_half_win=az_half_win,r_half_win=r_half_win)[1]",
    "crumbs": [
      "Tutorials",
      "API",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/ds_processing.html#select-shps",
    "href": "Tutorials/ds_processing.html#select-shps",
    "title": "DS Processing",
    "section": "Select SHPs",
    "text": "Select SHPs\n\nis_shp = (p &lt; 0.05) & (p &gt;= 0.0)\n\n\nshp_num = cp.count_nonzero(is_shp,axis=(-2,-1))\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(cp.asnumpy(shp_num),cmap=colorcet.cm.fire)\nax.set(title='Number of SHPs',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()",
    "crumbs": [
      "Tutorials",
      "API",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/ds_processing.html#select-dss",
    "href": "Tutorials/ds_processing.html#select-dss",
    "title": "DS Processing",
    "section": "Select DSs",
    "text": "Select DSs\nHere we select DSs candidate as pixels have more than 50 brothers.\n\nis_ds_can = shp_num &gt;= 50\n\nThe number of DSs:\n\ncp.count_nonzero(is_ds_can)\n\narray(740397)\n\n\nThe DSs distribution:\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(cp.asnumpy(is_ds_can),cmap=colorcet.cm.fire)\nax.set(title='DS Candidate distribution',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()",
    "crumbs": [
      "Tutorials",
      "API",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/ds_processing.html#estimate-coherence-matrix",
    "href": "Tutorials/ds_processing.html#estimate-coherence-matrix",
    "title": "DS Processing",
    "section": "Estimate coherence matrix",
    "text": "Estimate coherence matrix\nIn order to save memory, here we only estimate coherence matrix on selected DSs:\n\nds_can_is_shp = is_shp[is_ds_can]\nds_can_idx = cp.stack(cp.where(is_ds_can))\nds_can_cov, ds_can_coh = emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp)\n\nPlot the average coherence matrix:\n\nds_can_ave_coh = abs(ds_can_coh).mean(axis=0)\n\n\nds_can_ave_coh.shape\n\n(17, 17)\n\n\n\nfig, ax = plt.subplots(1,1,figsize=(15,10))\npcm = ax.imshow(cp.asnumpy(ds_can_ave_coh),cmap=colorcet.cm.fire)\nax.set(title='Average Coherence Matrix',xlabel='Image Index',ylabel='Image Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\n\n\n\nThe coherence between the 5-th SLC and other SLC are bad. We may consider removing this image.",
    "crumbs": [
      "Tutorials",
      "API",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/ds_processing.html#phase-linking",
    "href": "Tutorials/ds_processing.html#phase-linking",
    "title": "DS Processing",
    "section": "Phase linking",
    "text": "Phase linking\nHere we apply the EMI method:\n\nds_can_ph, ds_can_emi_quality = emi(ds_can_coh)\nds_can_ph.shape, ds_can_emi_quality.shape\n\n((740397, 17), (740397,))\n\n\n\nds_can_emi_quality_2d = cp.empty_like(is_ds_can,dtype=ds_can_emi_quality.dtype)\nds_can_emi_quality_2d[:] = cp.nan\nds_can_emi_quality_2d[is_ds_can] = ds_can_emi_quality\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(cp.asnumpy(ds_can_emi_quality_2d),interpolation='nearest',vmin=1,vmax=1.3)\nax.set(title='DS EMI quality factor',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\n\n\n\n\nds_can_temp_coh = ds_temp_coh(ds_can_coh,ds_can_ph)\nds_can_temp_coh.shape\n\n(740397,)\n\n\n\nds_can_temp_coh_2d = cp.empty_like(is_ds_can,dtype=ds_can_temp_coh.dtype)\nds_can_temp_coh_2d[:] = cp.nan\nds_can_temp_coh_2d[is_ds_can] = ds_can_temp_coh\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(cp.asnumpy(ds_can_temp_coh_2d),interpolation='nearest')\nax.set(title='DS Temporal Coherence',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()",
    "crumbs": [
      "Tutorials",
      "API",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/ds_processing.html#refine-ds-candidate",
    "href": "Tutorials/ds_processing.html#refine-ds-candidate",
    "title": "DS Processing",
    "section": "Refine DS candidate",
    "text": "Refine DS candidate\nHere we select DS candidate based on EMI quality factor and temporal coherence:\n\n_is_ds_can_refined = (ds_can_emi_quality&gt;=1.0) & (ds_can_emi_quality &lt;1.2) & (ds_can_temp_coh &gt; 0.7) & (ds_can_temp_coh &lt;= 1.0)\n\n\nds_can_refined_idx = tuple(idx[_is_ds_can_refined] for idx in ds_can_idx)\nis_ds_can_refined = cp.zeros_like(is_ds_can)\nis_ds_can_refined[ds_can_refined_idx] = True\n\n\nds_can_refined_coh = ds_can_coh[_is_ds_can_refined]\nds_can_refined_ph = ds_can_ph[_is_ds_can_refined]\n\n\nds_can_refined_coh.shape\n\n(460076, 17, 17)\n\n\nPlot the average coherence matrix and refined DS candiate distribution:\n\nds_can_refined_ave_coh = abs(ds_can_refined_coh).mean(axis=0)\nfig, ax = plt.subplots(1,1,figsize=(15,10))\npcm = ax.imshow(cp.asnumpy(ds_can_refined_ave_coh),cmap=colorcet.cm.fire)\nax.set(title='Average Coherence Matrix',xlabel='Image Index',ylabel='Image Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\n\n\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(cp.asnumpy(is_ds_can_refined),cmap=colorcet.cm.fire)\nax.set(title='DS Candidate Refined distribution',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\n\n\n\nWe find the coherence matrix gets better and noisy pixels are moved.",
    "crumbs": [
      "Tutorials",
      "API",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/overview.html",
    "href": "Tutorials/CLI/overview.html",
    "title": "Tutorials for CLI Overview",
    "section": "",
    "text": "This is a series of tutorials to show how to use CLI for InSAR processing.",
    "crumbs": [
      "Tutorials",
      "CLI",
      "Tutorials for CLI Overview"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ds_processing.html",
    "href": "Tutorials/CLI/ds_processing.html",
    "title": "DS Processing",
    "section": "",
    "text": "In this tutorial, we demostrate how to do DS processing with the decorrelation CLI interface. The input data for DS processing is prepared in Load Data.\n!ls ./load_data\n\ne.zarr    lat.zarr  meta.toml     n.zarr    range.zarr  scratch\nhgt.zarr  lon.zarr  non_nan.zarr  phi.zarr  rslc.zarr   theta.zarr",
    "crumbs": [
      "Tutorials",
      "CLI",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ds_processing.html#shp-selection",
    "href": "Tutorials/CLI/ds_processing.html#shp-selection",
    "title": "DS Processing",
    "section": "SHP selection",
    "text": "SHP selection\nHere we use two sample Kolmogorov-Smirnov (KS) test for Spatially Homogenious Pixel (SHP) identification.\nThe output pvalue is the P-value for this test. The smaller the p-value, the more likely the two sample are from same distribution, i.e., the more likely the two pixels are SHP to each other.\n\nfrom decorrelation.cli.shp import de_shp_test\nimport numpy as np\nfrom decorrelation.cli.utils.logging import get_logger\n\n\nrslc = './load_data/rslc.zarr'\npvalue = './ds_processing/pvalue.zarr'\naz_half_win = 5\nr_half_win = 5\nmethod = 'ks'\naz_chunk_size = 1000\nr_chunk_size = 1000\n\n\nlogger = get_logger()\n\n\nde_shp_test(rslc,pvalue,\n            az_half_win=az_half_win,r_half_win=r_half_win,\n            method=method,az_chunk_size=az_chunk_size)\n\n2023-11-05 23:42:52 - logging_args - INFO - running function: de_shp_test\n2023-11-05 23:42:52 - logging_args - INFO - fetching args:\n2023-11-05 23:42:52 - logging_args - INFO - rslc = './load_data/rslc.zarr'\n2023-11-05 23:42:52 - logging_args - INFO - pvalue = './ds_processing/pvalue.zarr'\n2023-11-05 23:42:52 - logging_args - INFO - az_half_win = 5\n2023-11-05 23:42:52 - logging_args - INFO - r_half_win = 5\n2023-11-05 23:42:52 - logging_args - INFO - method = 'ks'\n2023-11-05 23:42:52 - logging_args - INFO - n_az_chunk = None\n2023-11-05 23:42:52 - logging_args - INFO - az_chunk_size = 1000\n2023-11-05 23:42:52 - logging_args - INFO - r_chunk_size = None\n2023-11-05 23:42:52 - logging_args - INFO - n_r_chunk = None\n2023-11-05 23:42:52 - logging_args - INFO - fetching args done.\n2023-11-05 23:42:52 - de_shp_test - INFO - hypothetic test method: ks\n2023-11-05 23:42:52 - zarr_info - INFO - ./load_data/rslc.zarr zarray shape: (2500, 1834, 17)\n2023-11-05 23:42:52 - zarr_info - INFO - ./load_data/rslc.zarr zarray chunks: (1000, 1000, 1)\n2023-11-05 23:42:52 - zarr_info - INFO - ./load_data/rslc.zarr zarray dtype: complex64\n2023-11-05 23:42:52 - get_ras_chunk_size_from_ras_chunk_size - INFO - got az_chunk_size for pvalue: 1000\n2023-11-05 23:42:52 - get_ras_chunk_size_from_ras_chunk_size - INFO - automatically determine r_chunk_size from\n            r_chunk_size of rslc\n2023-11-05 23:42:52 - get_ras_chunk_size_from_ras_chunk_size - INFO - r_chunk_size for pvalue: 1000\n2023-11-05 23:42:52 - de_shp_test - INFO - starting dask CUDA local cluster.\n2023-11-05 23:42:59 - de_shp_test - INFO - dask local CUDA cluster started.\n2023-11-05 23:42:59 - darr_info - INFO - rslc dask array shape: (2500, 1834, 17)\n2023-11-05 23:42:59 - darr_info - INFO - rslc dask array chunksize: (1000, 1000, 17)\n2023-11-05 23:42:59 - darr_info - INFO - rslc dask array dtype: complex64\n2023-11-05 23:42:59 - de_shp_test - INFO - azimuth half window size: 5; azimuth window size: 11\n2023-11-05 23:42:59 - de_shp_test - INFO - range half window size: 5; range window size: 11\n2023-11-05 23:42:59 - de_shp_test - INFO - setting shared boundaries between rlsc chunks.\n2023-11-05 23:42:59 - darr_info - INFO - rslc with overlap dask array shape: (2520, 1844, 17)\n2023-11-05 23:42:59 - darr_info - INFO - rslc with overlap dask array chunksize: (1010, 1005, 17)\n2023-11-05 23:42:59 - darr_info - INFO - rslc with overlap dask array dtype: complex64\n2023-11-05 23:42:59 - darr_info - INFO - rmli with overlap dask array shape: (2520, 1844, 17)\n2023-11-05 23:42:59 - darr_info - INFO - rmli with overlap dask array chunksize: (1010, 1005, 17)\n2023-11-05 23:42:59 - darr_info - INFO - rmli with overlap dask array dtype: float32\n2023-11-05 23:42:59 - de_shp_test - INFO - applying test on sorted rmli stack.\n2023-11-05 23:42:59 - de_shp_test - INFO - p value generated\n2023-11-05 23:42:59 - darr_info - INFO - p value dask array shape: (2520, 1844, 11, 11)\n2023-11-05 23:42:59 - darr_info - INFO - p value dask array chunksize: (1010, 1005, 11, 11)\n2023-11-05 23:42:59 - darr_info - INFO - p value dask array dtype: float32\n2023-11-05 23:42:59 - de_shp_test - INFO - trim shared boundaries between p value chunks and rechunk\n2023-11-05 23:42:59 - darr_info - INFO - p value dask array shape: (2500, 1834, 11, 11)\n2023-11-05 23:42:59 - darr_info - INFO - p value dask array chunksize: (1000, 1000, 1, 1)\n2023-11-05 23:42:59 - darr_info - INFO - p value dask array dtype: float32\n2023-11-05 23:42:59 - de_shp_test - INFO - saving p value.\n2023-11-05 23:42:59 - de_shp_test - INFO - computing graph setted. doing all the computing.\n2023-11-05 23:43:07 - de_shp_test - INFO - computing finished. 7.7s\n2023-11-05 23:43:09 - de_shp_test - INFO - dask cluster closed.\n\n\nThen we select SHP by setting a threshold on this Pvalue:\n\nfrom decorrelation.cli.shp import de_select_shp\nimport zarr\nfrom matplotlib import pyplot as plt\nimport colorcet\n\n\nis_shp = './ds_processing/is_shp.zarr'\nshp_num = './ds_processing/shp_num.zarr'\np_max = 0.05\naz_chunk_size = 1000\n\n\nde_select_shp(pvalue,is_shp,shp_num,p_max=p_max,az_chunk_size=az_chunk_size)\n\n2023-11-05 23:43:09 - logging_args - INFO - running function: de_select_shp\n2023-11-05 23:43:09 - logging_args - INFO - fetching args:\n2023-11-05 23:43:09 - logging_args - INFO - pvalue = './ds_processing/pvalue.zarr'\n2023-11-05 23:43:09 - logging_args - INFO - is_shp = './ds_processing/is_shp.zarr'\n2023-11-05 23:43:09 - logging_args - INFO - shp_num = './ds_processing/shp_num.zarr'\n2023-11-05 23:43:09 - logging_args - INFO - p_max = 0.05\n2023-11-05 23:43:09 - logging_args - INFO - n_az_chunk = None\n2023-11-05 23:43:09 - logging_args - INFO - az_chunk_size = 1000\n2023-11-05 23:43:09 - logging_args - INFO - r_chunk_size = None\n2023-11-05 23:43:09 - logging_args - INFO - n_r_chunk = None\n2023-11-05 23:43:09 - logging_args - INFO - fetching args done.\n2023-11-05 23:43:09 - zarr_info - INFO - ./ds_processing/pvalue.zarr zarray shape: (2500, 1834, 11, 11)\n2023-11-05 23:43:09 - zarr_info - INFO - ./ds_processing/pvalue.zarr zarray chunks: (1000, 1000, 1, 1)\n2023-11-05 23:43:09 - zarr_info - INFO - ./ds_processing/pvalue.zarr zarray dtype: float32\n2023-11-05 23:43:09 - get_ras_chunk_size_from_ras_chunk_size - INFO - got az_chunk_size for is_shp: 1000\n2023-11-05 23:43:09 - get_ras_chunk_size_from_ras_chunk_size - INFO - automatically determine r_chunk_size from\n            r_chunk_size of pvalue\n2023-11-05 23:43:09 - get_ras_chunk_size_from_ras_chunk_size - INFO - r_chunk_size for is_shp: 1000\n2023-11-05 23:43:09 - de_select_shp - INFO - starting dask cuda cluster.\n2023-11-05 23:43:15 - de_select_shp - INFO - dask cluster started.\n2023-11-05 23:43:15 - darr_info - INFO - pvalue dask array shape: (2500, 1834, 11, 11)\n2023-11-05 23:43:15 - darr_info - INFO - pvalue dask array chunksize: (1000, 1000, 11, 11)\n2023-11-05 23:43:15 - darr_info - INFO - pvalue dask array dtype: float32\n2023-11-05 23:43:15 - de_select_shp - INFO - selecting SHPs based on pvalue threshold: 0.05\n2023-11-05 23:43:15 - darr_info - INFO - is_shp dask array shape: (2500, 1834, 11, 11)\n2023-11-05 23:43:15 - darr_info - INFO - is_shp dask array chunksize: (1000, 1000, 11, 11)\n2023-11-05 23:43:15 - darr_info - INFO - is_shp dask array dtype: bool\n2023-11-05 23:43:15 - de_select_shp - INFO - calculate shp_num.\n2023-11-05 23:43:15 - darr_info - INFO - shp_num dask array shape: (2500, 1834)\n2023-11-05 23:43:15 - darr_info - INFO - shp_num dask array chunksize: (1000, 1000)\n2023-11-05 23:43:15 - darr_info - INFO - shp_num dask array dtype: int32\n2023-11-05 23:43:15 - de_select_shp - INFO - rechunk is_shp\n2023-11-05 23:43:15 - darr_info - INFO - is_shp dask array shape: (2500, 1834, 11, 11)\n2023-11-05 23:43:15 - darr_info - INFO - is_shp dask array chunksize: (1000, 1000, 1, 1)\n2023-11-05 23:43:15 - darr_info - INFO - is_shp dask array dtype: bool\n2023-11-05 23:43:15 - de_select_shp - INFO - saving is_shp.\n2023-11-05 23:43:15 - de_select_shp - INFO - saving shp_num.\n2023-11-05 23:43:15 - de_select_shp - INFO - computing graph setted. doing all the computing.\n2023-11-05 23:43:22 - de_select_shp - INFO - computing finished..5s\n2023-11-05 23:43:24 - de_select_shp - INFO - dask cluster closed.\n\n\nThe output is_shp indicate wheather a pixel in the window is a SHP to its center pixel.\n\nshp_num_zarr = zarr.open(shp_num,'r')\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(shp_num_zarr[:],cmap=colorcet.cm.fire)\nax.set(title='Number of SHPs',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()",
    "crumbs": [
      "Tutorials",
      "CLI",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ds_processing.html#ds-candidates-selection",
    "href": "Tutorials/CLI/ds_processing.html#ds-candidates-selection",
    "title": "DS Processing",
    "section": "DS candidates selection",
    "text": "DS candidates selection\n\nfrom decorrelation.cli.pc import de_pc_logic_ras, de_ras2pc, de_idx2bool,de_pc2ras\n\n\nds_can_idx = './ds_processing/ds_can_idx.zarr'\nis_ds_can= './ds_processing/is_ds_can.zarr'\nds_can_is_shp = './ds_processing/ds_can_is_shp.zarr'\n\n\nde_pc_logic_ras(shp_num,ds_can_idx,'ras&gt;=50')\nde_ras2pc(ds_can_idx, is_shp, ds_can_is_shp)\nde_idx2bool(ds_can_idx, is_ds_can, shape= shp_num_zarr.shape)\n\n2023-11-05 23:44:56 - logging_args - INFO - running function: de_pc_logic_ras\n2023-11-05 23:44:56 - logging_args - INFO - fetching args:\n2023-11-05 23:44:56 - logging_args - INFO - ras = './ds_processing/shp_num.zarr'\n2023-11-05 23:44:56 - logging_args - INFO - idx = './ds_processing/ds_can_idx.zarr'\n2023-11-05 23:44:56 - logging_args - INFO - operation = 'ras&gt;=50'\n2023-11-05 23:44:56 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 23:44:56 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 23:44:56 - logging_args - INFO - fetching args done.\n2023-11-05 23:44:56 - zarr_info - INFO - ./ds_processing/shp_num.zarr zarray shape: (2500, 1834)\n2023-11-05 23:44:56 - zarr_info - INFO - ./ds_processing/shp_num.zarr zarray chunks: (1000, 1000)\n2023-11-05 23:44:56 - zarr_info - INFO - ./ds_processing/shp_num.zarr zarray dtype: int32\n2023-11-05 23:44:56 - de_pc_logic_ras - INFO - loading ras into memory.\n2023-11-05 23:44:56 - de_pc_logic_ras - INFO - select pc based on operation: ras&gt;=50\n2023-11-05 23:44:56 - de_pc_logic_ras - INFO - number of selected pixels: 740397.\n2023-11-05 23:44:56 - get_pc_chunk_size_from_n_ras_chunk - INFO - automatically determine pc_chunk_size from\n            n_pc of idx and n_ras_chunk of ras\n2023-11-05 23:44:56 - get_pc_chunk_size_from_n_ras_chunk - INFO - n_ras_chunk of ras: 6\n2023-11-05 23:44:56 - get_pc_chunk_size_from_n_ras_chunk - INFO - pc_chunk_size for idx: 123400\n2023-11-05 23:44:56 - de_pc_logic_ras - INFO - writing idx.\n2023-11-05 23:44:57 - de_pc_logic_ras - INFO - write done.\n2023-11-05 23:44:57 - logging_args - INFO - running function: de_ras2pc\n2023-11-05 23:44:57 - logging_args - INFO - fetching args:\n2023-11-05 23:44:57 - logging_args - INFO - idx = './ds_processing/ds_can_idx.zarr'\n2023-11-05 23:44:57 - logging_args - INFO - ras = './ds_processing/is_shp.zarr'\n2023-11-05 23:44:57 - logging_args - INFO - pc = './ds_processing/ds_can_is_shp.zarr'\n2023-11-05 23:44:57 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 23:44:57 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 23:44:57 - logging_args - INFO - hd_chunk_size = None\n2023-11-05 23:44:57 - logging_args - INFO - fetching args done.\n2023-11-05 23:44:57 - zarr_info - INFO - ./ds_processing/ds_can_idx.zarr zarray shape: (2, 740397)\n2023-11-05 23:44:57 - zarr_info - INFO - ./ds_processing/ds_can_idx.zarr zarray chunks: (2, 123400)\n2023-11-05 23:44:57 - zarr_info - INFO - ./ds_processing/ds_can_idx.zarr zarray dtype: int32\n2023-11-05 23:44:57 - get_pc_chunk_size_from_pc_chunk_size - INFO - automatically determine pc_chunk_size from\n            pc_chunk_size of idx.\n2023-11-05 23:44:57 - get_pc_chunk_size_from_pc_chunk_size - INFO - pc_chunk_size for pc: 123400\n2023-11-05 23:44:57 - de_ras2pc - INFO - loading idx into memory.\n2023-11-05 23:44:57 - de_ras2pc - INFO - starting dask local cluster.\n2023-11-05 23:45:01 - de_ras2pc - INFO - dask local cluster started.\n2023-11-05 23:45:01 - de_ras2pc - INFO - start to slice on ./ds_processing/is_shp.zarr\n2023-11-05 23:45:01 - zarr_info - INFO - ./ds_processing/is_shp.zarr zarray shape: (2500, 1834, 11, 11)\n2023-11-05 23:45:01 - zarr_info - INFO - ./ds_processing/is_shp.zarr zarray chunks: (1000, 1000, 1, 1)\n2023-11-05 23:45:01 - zarr_info - INFO - ./ds_processing/is_shp.zarr zarray dtype: bool\n2023-11-05 23:45:01 - de_ras2pc - INFO - hd_chunk_size not setted. Use the one from ./ds_processing/is_shp.zarr.\n2023-11-05 23:45:01 - de_ras2pc - INFO - hd_chunk_size: (1, 1).\n2023-11-05 23:45:01 - darr_info - INFO - ras dask array shape: (2500, 1834, 11, 11)\n2023-11-05 23:45:01 - darr_info - INFO - ras dask array chunksize: (1000, 1000, 1, 1)\n2023-11-05 23:45:01 - darr_info - INFO - ras dask array dtype: bool\n2023-11-05 23:45:01 - darr_info - INFO - pc dask array shape: (740397, 11, 11)\n2023-11-05 23:45:01 - darr_info - INFO - pc dask array chunksize: (177430, 1, 1)\n2023-11-05 23:45:01 - darr_info - INFO - pc dask array dtype: bool\n2023-11-05 23:45:01 - de_ras2pc - INFO - rechunk pc data:\n2023-11-05 23:45:01 - darr_info - INFO - pc dask array shape: (740397, 11, 11)\n2023-11-05 23:45:01 - darr_info - INFO - pc dask array chunksize: (123400, 1, 1)\n2023-11-05 23:45:01 - darr_info - INFO - pc dask array dtype: bool\n2023-11-05 23:45:02 - de_ras2pc - INFO - saving to ./ds_processing/ds_can_is_shp.zarr.\n2023-11-05 23:45:02 - de_ras2pc - INFO - computing graph setted. doing all the computing.\n2023-11-05 23:45:05 - de_ras2pc - INFO - computing finished.|  3.5s\n2023-11-05 23:45:06 - de_ras2pc - INFO - dask cluster closed.\n2023-11-05 23:45:06 - logging_args - INFO - running function: de_idx2bool\n2023-11-05 23:45:06 - logging_args - INFO - fetching args:\n2023-11-05 23:45:06 - logging_args - INFO - idx = './ds_processing/ds_can_idx.zarr'\n2023-11-05 23:45:06 - logging_args - INFO - is_pc = './ds_processing/is_ds_can.zarr'\n2023-11-05 23:45:06 - logging_args - INFO - shape = (2500, 1834)\n2023-11-05 23:45:06 - logging_args - INFO - az_chunk_size = None\n2023-11-05 23:45:06 - logging_args - INFO - n_az_chunk = None\n2023-11-05 23:45:06 - logging_args - INFO - r_chunk_size = None\n2023-11-05 23:45:06 - logging_args - INFO - n_r_chunk = None\n2023-11-05 23:45:06 - logging_args - INFO - fetching args done.\n2023-11-05 23:45:06 - zarr_info - INFO - idx zarray shape: (2, 740397)\n2023-11-05 23:45:06 - zarr_info - INFO - idx zarray chunks: (2, 123400)\n2023-11-05 23:45:06 - zarr_info - INFO - idx zarray dtype: int32\n2023-11-05 23:45:06 - de_idx2bool - INFO - loading idx into memory.\n2023-11-05 23:45:06 - de_idx2bool - INFO - calculate the bool array\n2023-11-05 23:45:06 - get_ras_chunk_size_from_n_pc_chunk - INFO - automatically set r_chunk_size to nlines of ras\n2023-11-05 23:45:06 - get_ras_chunk_size_from_n_pc_chunk - INFO - automatically determine az_chunk_size from \n            nlines and n_r_chunk of ras  and n_pc_chunk of idx\n2023-11-05 23:45:06 - get_ras_chunk_size_from_n_pc_chunk - INFO - az_chunk_size for ras: 417\n2023-11-05 23:45:06 - zarr_info - INFO - is_pc zarray shape: (2500, 1834)\n2023-11-05 23:45:06 - zarr_info - INFO - is_pc zarray chunks: (417, 1834)\n2023-11-05 23:45:06 - zarr_info - INFO - is_pc zarray dtype: bool\n2023-11-05 23:45:06 - de_idx2bool - INFO - write the bool array.\n2023-11-05 23:45:06 - de_idx2bool - INFO - write done.\n\n\nds_can_idx is a int array with shape of (2, num_of_DS_can). It indicate the position of DS candidate in radar coordinate.\nAlso, select lon, lat for DS candidates:\n\ne = './load_data/e.zarr/'\nn = './load_data/n.zarr/'\nlon = './load_data/lon.zarr/'\nlat = './load_data/lat.zarr/'\nds_can_e = './ds_processing/ds_can_e.zarr'\nds_can_n = './ds_processing/ds_can_n.zarr'\nds_can_lon = './ds_processing/ds_can_lon.zarr'\nds_can_lat = './ds_processing/ds_can_lat.zarr'\n\n\nde_ras2pc(ds_can_idx,[e,n,lon,lat],[ds_can_e,ds_can_n,ds_can_lon,ds_can_lat])\n\n2023-11-05 23:45:11 - logging_args - INFO - running function: de_ras2pc\n2023-11-05 23:45:11 - logging_args - INFO - fetching args:\n2023-11-05 23:45:11 - logging_args - INFO - idx = './ds_processing/ds_can_idx.zarr'\n2023-11-05 23:45:11 - logging_args - INFO - ras = ['./load_data/e.zarr/', './load_data/n.zarr/', './load_data/lon.zarr/', './load_data/lat.zarr/']\n2023-11-05 23:45:11 - logging_args - INFO - pc = ['./ds_processing/ds_can_e.zarr', './ds_processing/ds_can_n.zarr', './ds_processing/ds_can_lon.zarr', './ds_processing/ds_can_lat.zarr']\n2023-11-05 23:45:11 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 23:45:11 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 23:45:11 - logging_args - INFO - hd_chunk_size = None\n2023-11-05 23:45:11 - logging_args - INFO - fetching args done.\n2023-11-05 23:45:11 - zarr_info - INFO - ./ds_processing/ds_can_idx.zarr zarray shape: (2, 740397)\n2023-11-05 23:45:11 - zarr_info - INFO - ./ds_processing/ds_can_idx.zarr zarray chunks: (2, 123400)\n2023-11-05 23:45:11 - zarr_info - INFO - ./ds_processing/ds_can_idx.zarr zarray dtype: int32\n2023-11-05 23:45:11 - get_pc_chunk_size_from_pc_chunk_size - INFO - automatically determine pc_chunk_size from\n            pc_chunk_size of idx.\n2023-11-05 23:45:11 - get_pc_chunk_size_from_pc_chunk_size - INFO - pc_chunk_size for pc: 123400\n2023-11-05 23:45:11 - de_ras2pc - INFO - loading idx into memory.\n2023-11-05 23:45:11 - de_ras2pc - INFO - starting dask local cluster.\n2023-11-05 23:45:16 - de_ras2pc - INFO - dask local cluster started.\n2023-11-05 23:45:16 - de_ras2pc - INFO - start to slice on ./load_data/e.zarr/\n2023-11-05 23:45:16 - zarr_info - INFO - ./load_data/e.zarr/ zarray shape: (2500, 1834)\n2023-11-05 23:45:16 - zarr_info - INFO - ./load_data/e.zarr/ zarray chunks: (1000, 1000)\n2023-11-05 23:45:16 - zarr_info - INFO - ./load_data/e.zarr/ zarray dtype: float64\n2023-11-05 23:45:16 - de_ras2pc - INFO - hd_chunk_size not setted. Use the one from ./load_data/e.zarr/.\n2023-11-05 23:45:16 - de_ras2pc - INFO - hd_chunk_size: ().\n2023-11-05 23:45:16 - darr_info - INFO - ras dask array shape: (2500, 1834)\n2023-11-05 23:45:16 - darr_info - INFO - ras dask array chunksize: (1000, 1000)\n2023-11-05 23:45:16 - darr_info - INFO - ras dask array dtype: float64\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array shape: (740397,)\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array chunksize: (177430,)\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array dtype: float64\n2023-11-05 23:45:16 - de_ras2pc - INFO - rechunk pc data:\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array shape: (740397,)\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array chunksize: (123400,)\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array dtype: float64\n2023-11-05 23:45:16 - de_ras2pc - INFO - saving to ./ds_processing/ds_can_e.zarr.\n2023-11-05 23:45:16 - de_ras2pc - INFO - start to slice on ./load_data/n.zarr/\n2023-11-05 23:45:16 - zarr_info - INFO - ./load_data/n.zarr/ zarray shape: (2500, 1834)\n2023-11-05 23:45:16 - zarr_info - INFO - ./load_data/n.zarr/ zarray chunks: (1000, 1000)\n2023-11-05 23:45:16 - zarr_info - INFO - ./load_data/n.zarr/ zarray dtype: float64\n2023-11-05 23:45:16 - de_ras2pc - INFO - hd_chunk_size not setted. Use the one from ./load_data/n.zarr/.\n2023-11-05 23:45:16 - de_ras2pc - INFO - hd_chunk_size: ().\n2023-11-05 23:45:16 - darr_info - INFO - ras dask array shape: (2500, 1834)\n2023-11-05 23:45:16 - darr_info - INFO - ras dask array chunksize: (1000, 1000)\n2023-11-05 23:45:16 - darr_info - INFO - ras dask array dtype: float64\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array shape: (740397,)\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array chunksize: (177430,)\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array dtype: float64\n2023-11-05 23:45:16 - de_ras2pc - INFO - rechunk pc data:\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array shape: (740397,)\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array chunksize: (123400,)\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array dtype: float64\n2023-11-05 23:45:16 - de_ras2pc - INFO - saving to ./ds_processing/ds_can_n.zarr.\n2023-11-05 23:45:16 - de_ras2pc - INFO - start to slice on ./load_data/lon.zarr/\n2023-11-05 23:45:16 - zarr_info - INFO - ./load_data/lon.zarr/ zarray shape: (2500, 1834)\n2023-11-05 23:45:16 - zarr_info - INFO - ./load_data/lon.zarr/ zarray chunks: (1000, 1000)\n2023-11-05 23:45:16 - zarr_info - INFO - ./load_data/lon.zarr/ zarray dtype: float64\n2023-11-05 23:45:16 - de_ras2pc - INFO - hd_chunk_size not setted. Use the one from ./load_data/lon.zarr/.\n2023-11-05 23:45:16 - de_ras2pc - INFO - hd_chunk_size: ().\n2023-11-05 23:45:16 - darr_info - INFO - ras dask array shape: (2500, 1834)\n2023-11-05 23:45:16 - darr_info - INFO - ras dask array chunksize: (1000, 1000)\n2023-11-05 23:45:16 - darr_info - INFO - ras dask array dtype: float64\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array shape: (740397,)\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array chunksize: (177430,)\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array dtype: float64\n2023-11-05 23:45:16 - de_ras2pc - INFO - rechunk pc data:\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array shape: (740397,)\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array chunksize: (123400,)\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array dtype: float64\n2023-11-05 23:45:16 - de_ras2pc - INFO - saving to ./ds_processing/ds_can_lon.zarr.\n2023-11-05 23:45:16 - de_ras2pc - INFO - start to slice on ./load_data/lat.zarr/\n2023-11-05 23:45:16 - zarr_info - INFO - ./load_data/lat.zarr/ zarray shape: (2500, 1834)\n2023-11-05 23:45:16 - zarr_info - INFO - ./load_data/lat.zarr/ zarray chunks: (1000, 1000)\n2023-11-05 23:45:16 - zarr_info - INFO - ./load_data/lat.zarr/ zarray dtype: float64\n2023-11-05 23:45:16 - de_ras2pc - INFO - hd_chunk_size not setted. Use the one from ./load_data/lat.zarr/.\n2023-11-05 23:45:16 - de_ras2pc - INFO - hd_chunk_size: ().\n2023-11-05 23:45:16 - darr_info - INFO - ras dask array shape: (2500, 1834)\n2023-11-05 23:45:16 - darr_info - INFO - ras dask array chunksize: (1000, 1000)\n2023-11-05 23:45:16 - darr_info - INFO - ras dask array dtype: float64\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array shape: (740397,)\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array chunksize: (177430,)\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array dtype: float64\n2023-11-05 23:45:16 - de_ras2pc - INFO - rechunk pc data:\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array shape: (740397,)\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array chunksize: (123400,)\n2023-11-05 23:45:16 - darr_info - INFO - pc dask array dtype: float64\n2023-11-05 23:45:16 - de_ras2pc - INFO - saving to ./ds_processing/ds_can_lat.zarr.\n2023-11-05 23:45:16 - de_ras2pc - INFO - computing graph setted. doing all the computing.\n2023-11-05 23:45:17 - de_ras2pc - INFO - computing finished.|  0.7s\n2023-11-05 23:45:18 - de_ras2pc - INFO - dask cluster closed.\n\n\n\nis_ds_can_zarr = zarr.open(is_ds_can,'r')\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(is_ds_can_zarr[:],cmap=colorcet.cm.fire)\nax.set(title='DS candidiate distribution',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()",
    "crumbs": [
      "Tutorials",
      "CLI",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ds_processing.html#coherence-matrix-estimation",
    "href": "Tutorials/CLI/ds_processing.html#coherence-matrix-estimation",
    "title": "DS Processing",
    "section": "Coherence matrix estimation",
    "text": "Coherence matrix estimation\nThen we estimate the coherence matrix of ds candidate:\n\nfrom decorrelation.cli.co import de_emperical_co_pc\n\n\nds_can_coh = './ds_processing/ds_can_coh.zarr'\nds_can_coh_ave = './ds_processing/ds_can_coh_ave.zarr'\n\n\nde_emperical_co_pc(rslc,ds_can_is_shp,ds_can_idx,ds_can_coh,ds_can_coh_ave)\n\n2023-11-05 23:45:22 - logging_args - INFO - running function: de_emperical_co_pc\n2023-11-05 23:45:22 - logging_args - INFO - fetching args:\n2023-11-05 23:45:22 - logging_args - INFO - rslc = './load_data/rslc.zarr'\n2023-11-05 23:45:22 - logging_args - INFO - is_shp = './ds_processing/ds_can_is_shp.zarr'\n2023-11-05 23:45:22 - logging_args - INFO - idx = './ds_processing/ds_can_idx.zarr'\n2023-11-05 23:45:22 - logging_args - INFO - coh = './ds_processing/ds_can_coh.zarr'\n2023-11-05 23:45:22 - logging_args - INFO - coh_ave = './ds_processing/ds_can_coh_ave.zarr'\n2023-11-05 23:45:22 - logging_args - INFO - az_chunk_size = None\n2023-11-05 23:45:22 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 23:45:22 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 23:45:22 - logging_args - INFO - fetching args done.\n2023-11-05 23:45:22 - zarr_info - INFO - ./load_data/rslc.zarr zarray shape: (2500, 1834, 17)\n2023-11-05 23:45:22 - zarr_info - INFO - ./load_data/rslc.zarr zarray chunks: (1000, 1000, 1)\n2023-11-05 23:45:22 - zarr_info - INFO - ./load_data/rslc.zarr zarray dtype: complex64\n2023-11-05 23:45:22 - zarr_info - INFO - ./ds_processing/ds_can_is_shp.zarr zarray shape: (740397, 11, 11)\n2023-11-05 23:45:22 - zarr_info - INFO - ./ds_processing/ds_can_is_shp.zarr zarray chunks: (123400, 1, 1)\n2023-11-05 23:45:22 - zarr_info - INFO - ./ds_processing/ds_can_is_shp.zarr zarray dtype: bool\n2023-11-05 23:45:22 - zarr_info - INFO - ./ds_processing/ds_can_idx.zarr zarray shape: (2, 740397)\n2023-11-05 23:45:22 - zarr_info - INFO - ./ds_processing/ds_can_idx.zarr zarray chunks: (2, 123400)\n2023-11-05 23:45:22 - zarr_info - INFO - ./ds_processing/ds_can_idx.zarr zarray dtype: int32\n2023-11-05 23:45:22 - de_emperical_co_pc - INFO - loading idx into memory.\n2023-11-05 23:45:22 - de_emperical_co_pc - INFO - got azimuth window size and half azimuth window size\n    from is_shp shape: 11, 5\n2023-11-05 23:45:22 - de_emperical_co_pc - INFO - got range window size and half range window size\n    from is_shp shape: 11, 5\n2023-11-05 23:45:22 - de_emperical_co_pc - INFO - parallel processing azimuth chunk size: 1000\n2023-11-05 23:45:22 - de_emperical_co_pc - INFO - parallel processing range chunk size: 1.\n2023-11-05 23:45:22 - de_emperical_co_pc - INFO - number of point in each chunk: (346329, 274921, 119147)\n2023-11-05 23:45:22 - de_emperical_co_pc - INFO - starting dask CUDA local cluster.\n2023-11-05 23:45:28 - de_emperical_co_pc - INFO - dask local CUDA cluster started.\n2023-11-05 23:45:28 - darr_info - INFO - is_shp dask array shape: (740397, 11, 11)\n2023-11-05 23:45:28 - darr_info - INFO - is_shp dask array chunksize: (346329, 11, 11)\n2023-11-05 23:45:28 - darr_info - INFO - is_shp dask array dtype: bool\n2023-11-05 23:45:28 - darr_info - INFO - rslc dask array shape: (2500, 1834, 17)\n2023-11-05 23:45:28 - darr_info - INFO - rslc dask array chunksize: (1000, 1834, 17)\n2023-11-05 23:45:28 - darr_info - INFO - rslc dask array dtype: complex64\n2023-11-05 23:45:28 - de_emperical_co_pc - INFO - setting shared boundaries between rlsc chunks.\n2023-11-05 23:45:28 - darr_info - INFO - rslc_overlap dask array shape: (2520, 1834, 17)\n2023-11-05 23:45:28 - darr_info - INFO - rslc_overlap dask array chunksize: (1010, 1834, 17)\n2023-11-05 23:45:28 - darr_info - INFO - rslc_overlap dask array dtype: complex64\n2023-11-05 23:45:28 - de_emperical_co_pc - INFO - estimating coherence matrix.\n2023-11-05 23:45:28 - de_emperical_co_pc - INFO - get coherence matrix.\n2023-11-05 23:45:28 - darr_info - INFO - coh dask array shape: (740397, 17, 17)\n2023-11-05 23:45:28 - darr_info - INFO - coh dask array chunksize: (346329, 17, 17)\n2023-11-05 23:45:28 - darr_info - INFO - coh dask array dtype: complex64\n2023-11-05 23:45:28 - get_pc_chunk_size_from_pc_chunk_size - INFO - automatically determine pc_chunk_size from\n            pc_chunk_size of is_pc.\n2023-11-05 23:45:28 - get_pc_chunk_size_from_pc_chunk_size - INFO - pc_chunk_size for coh: 123400\n2023-11-05 23:45:28 - de_emperical_co_pc - INFO - rechunking coh to chunk size (for saving with zarr): (123400, 1, 1)\n2023-11-05 23:45:28 - darr_info - INFO - coh dask array shape: (740397, 17, 17)\n2023-11-05 23:45:28 - darr_info - INFO - coh dask array chunksize: (123400, 1, 1)\n2023-11-05 23:45:28 - darr_info - INFO - coh dask array dtype: complex64\n2023-11-05 23:45:28 - de_emperical_co_pc - INFO - get average coherence matrix magnitude.\n2023-11-05 23:45:28 - darr_info - INFO - coh_ave dask array shape: (17, 17)\n2023-11-05 23:45:28 - darr_info - INFO - coh_ave dask array chunksize: (17, 17)\n2023-11-05 23:45:28 - darr_info - INFO - coh_ave dask array dtype: float32\n2023-11-05 23:45:28 - de_emperical_co_pc - INFO - saving coh and coh_ave.\n2023-11-05 23:45:29 - de_emperical_co_pc - INFO - computing graph setted. doing all the computing.\n2023-11-05 23:45:41 - de_emperical_co_pc - INFO - computing finished.2K\n2023-11-05 23:45:43 - de_emperical_co_pc - INFO - dask cluster closed.\n\n\n\nds_can_coh_ave_zarr = zarr.open(ds_can_coh_ave,'r')\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(ds_can_coh_ave_zarr[:],cmap=colorcet.cm.fire)\nax.set(title='Average coherence matrix',xlabel='Image Index',ylabel='Image Index')\nfig.colorbar(pcm)\nfig.show()",
    "crumbs": [
      "Tutorials",
      "CLI",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ds_processing.html#phase-linking",
    "href": "Tutorials/CLI/ds_processing.html#phase-linking",
    "title": "DS Processing",
    "section": "Phase linking",
    "text": "Phase linking\nTo get rid of the closure phase, phase linking is applied here:\n\nfrom decorrelation.cli.pl import de_emi\n\n\nds_can_ph = './ds_processing/ds_can_ph.zarr'\nds_can_emi_quality = './ds_processing/ds_can_emi_quality.zarr'\nemi_quality = './ds_processing/emi_quality.zarr'\n\n\nde_emi(ds_can_coh,ds_can_ph,ds_can_emi_quality)\n\n2023-11-05 23:45:43 - logging_args - INFO - running function: de_emi\n2023-11-05 23:45:43 - logging_args - INFO - fetching args:\n2023-11-05 23:45:43 - logging_args - INFO - coh = './ds_processing/ds_can_coh.zarr'\n2023-11-05 23:45:43 - logging_args - INFO - ph = './ds_processing/ds_can_ph.zarr'\n2023-11-05 23:45:43 - logging_args - INFO - emi_quality = './ds_processing/ds_can_emi_quality.zarr'\n2023-11-05 23:45:43 - logging_args - INFO - ref = 0\n2023-11-05 23:45:43 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 23:45:43 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 23:45:43 - logging_args - INFO - fetching args done.\n2023-11-05 23:45:43 - zarr_info - INFO - ./ds_processing/ds_can_coh.zarr zarray shape: (740397, 17, 17)\n2023-11-05 23:45:43 - zarr_info - INFO - ./ds_processing/ds_can_coh.zarr zarray chunks: (123400, 1, 1)\n2023-11-05 23:45:43 - zarr_info - INFO - ./ds_processing/ds_can_coh.zarr zarray dtype: complex64\n2023-11-05 23:45:43 - get_pc_chunk_size_from_pc_chunk_size - INFO - automatically determine pc_chunk_size from\n            pc_chunk_size of coh.\n2023-11-05 23:45:43 - get_pc_chunk_size_from_pc_chunk_size - INFO - pc_chunk_size for ph: 123400\n2023-11-05 23:45:43 - de_emi - INFO - starting dask CUDA local cluster.\n2023-11-05 23:45:49 - de_emi - INFO - dask local CUDA cluster started.\n2023-11-05 23:45:49 - darr_info - INFO - coh dask array shape: (740397, 17, 17)\n2023-11-05 23:45:49 - darr_info - INFO - coh dask array chunksize: (123400, 17, 17)\n2023-11-05 23:45:49 - darr_info - INFO - coh dask array dtype: complex64\n2023-11-05 23:45:49 - de_emi - INFO - phase linking with EMI.\n2023-11-05 23:45:49 - de_emi - INFO - got ph and emi_quality.\n2023-11-05 23:45:49 - darr_info - INFO - ph dask array shape: (740397, 17)\n2023-11-05 23:45:49 - darr_info - INFO - ph dask array chunksize: (123400, 17)\n2023-11-05 23:45:49 - darr_info - INFO - ph dask array dtype: complex64\n2023-11-05 23:45:49 - darr_info - INFO - emi_quality dask array shape: (740397,)\n2023-11-05 23:45:49 - darr_info - INFO - emi_quality dask array chunksize: (123400,)\n2023-11-05 23:45:49 - darr_info - INFO - emi_quality dask array dtype: float32\n2023-11-05 23:45:49 - de_emi - INFO - rechunk ph\n2023-11-05 23:45:49 - darr_info - INFO - ph dask array shape: (740397, 17)\n2023-11-05 23:45:49 - darr_info - INFO - ph dask array chunksize: (123400, 17)\n2023-11-05 23:45:49 - darr_info - INFO - ph dask array dtype: complex64\n2023-11-05 23:45:49 - de_emi - INFO - saving ph and emi_quality.\n2023-11-05 23:45:49 - de_emi - INFO - computing graph setted. doing all the computing.\n2023-11-05 23:45:53 - de_emi - INFO - computing finished.ed |  3.6s\n2023-11-05 23:45:55 - de_emi - INFO - dask cluster closed.\n\n\n\nrslc_zarr = zarr.open(rslc,'r')\nde_pc2ras(ds_can_idx, ds_can_emi_quality,emi_quality,rslc_zarr.shape[:2],az_chunk_size=rslc_zarr.chunks[0])\n\n2023-11-05 23:45:55 - logging_args - INFO - running function: de_pc2ras\n2023-11-05 23:45:55 - logging_args - INFO - fetching args:\n2023-11-05 23:45:55 - logging_args - INFO - idx = './ds_processing/ds_can_idx.zarr'\n2023-11-05 23:45:55 - logging_args - INFO - pc = './ds_processing/ds_can_emi_quality.zarr'\n2023-11-05 23:45:55 - logging_args - INFO - ras = './ds_processing/emi_quality.zarr'\n2023-11-05 23:45:55 - logging_args - INFO - shape = (2500, 1834)\n2023-11-05 23:45:55 - logging_args - INFO - az_chunk_size = 1000\n2023-11-05 23:45:55 - logging_args - INFO - n_az_chunk = None\n2023-11-05 23:45:55 - logging_args - INFO - r_chunk_size = None\n2023-11-05 23:45:55 - logging_args - INFO - n_r_chunk = None\n2023-11-05 23:45:55 - logging_args - INFO - fetching args done.\n2023-11-05 23:45:55 - zarr_info - INFO - idx zarray shape: (2, 740397)\n2023-11-05 23:45:55 - zarr_info - INFO - idx zarray chunks: (2, 123400)\n2023-11-05 23:45:55 - zarr_info - INFO - idx zarray dtype: int32\n2023-11-05 23:45:55 - get_ras_chunk_size_from_n_pc_chunk - INFO - automatically set r_chunk_size to nlines of ras\n2023-11-05 23:45:55 - get_ras_chunk_size_from_n_pc_chunk - INFO - got az_chunk_size for ras: 1000\n2023-11-05 23:45:55 - de_pc2ras - INFO - loading idx into memory.\n2023-11-05 23:45:55 - de_pc2ras - INFO - starting dask local cluster.\n2023-11-05 23:45:59 - de_pc2ras - INFO - dask local cluster started.\n2023-11-05 23:45:59 - de_pc2ras - INFO - start to work on ./ds_processing/ds_can_emi_quality.zarr\n2023-11-05 23:45:59 - zarr_info - INFO - ./ds_processing/ds_can_emi_quality.zarr zarray shape: (740397,)\n2023-11-05 23:45:59 - zarr_info - INFO - ./ds_processing/ds_can_emi_quality.zarr zarray chunks: (123400,)\n2023-11-05 23:45:59 - zarr_info - INFO - ./ds_processing/ds_can_emi_quality.zarr zarray dtype: float32\n2023-11-05 23:45:59 - darr_info - INFO - pc dask array shape: (740397,)\n2023-11-05 23:45:59 - darr_info - INFO - pc dask array chunksize: (123400,)\n2023-11-05 23:45:59 - darr_info - INFO - pc dask array dtype: float32\n2023-11-05 23:46:00 - de_pc2ras - INFO - create ras dask array\n2023-11-05 23:46:00 - darr_info - INFO - ras dask array shape: (2500, 1834)\n2023-11-05 23:46:00 - darr_info - INFO - ras dask array chunksize: (1000, 1834)\n2023-11-05 23:46:00 - darr_info - INFO - ras dask array dtype: float32\n2023-11-05 23:46:00 - de_pc2ras - INFO - computing graph setted. doing all the computing.\n2023-11-05 23:46:00 - de_pc2ras - INFO - computing finished.|  0.8s\n2023-11-05 23:46:01 - de_pc2ras - INFO - dask cluster closed.\n\n\n\nemi_zarr = zarr.open(emi_quality,'r')\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(emi_zarr[:],interpolation='nearest',vmin=0.5,vmax=1.3,cmap=colorcet.cm.fire)\nax.set(title='EMI quality factor',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)",
    "crumbs": [
      "Tutorials",
      "CLI",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ds_processing.html#ds-temporal-coherence-estimation",
    "href": "Tutorials/CLI/ds_processing.html#ds-temporal-coherence-estimation",
    "title": "DS Processing",
    "section": "DS temporal coherence estimation",
    "text": "DS temporal coherence estimation\nWe can also estimate a temporal coherence for DS:\n\nfrom decorrelation.cli.pl import de_ds_temp_coh\n\n\nds_can_t_coh = './ds_processing/ds_can_t_coh.zarr'\n\n\nde_ds_temp_coh(ds_can_coh,ds_can_ph, ds_can_t_coh)\n\n2023-11-05 23:46:07 - logging_args - INFO - running function: de_ds_temp_coh\n2023-11-05 23:46:07 - logging_args - INFO - fetching args:\n2023-11-05 23:46:07 - logging_args - INFO - coh = './ds_processing/ds_can_coh.zarr'\n2023-11-05 23:46:07 - logging_args - INFO - ph = './ds_processing/ds_can_ph.zarr'\n2023-11-05 23:46:07 - logging_args - INFO - t_coh = './ds_processing/ds_can_t_coh.zarr'\n2023-11-05 23:46:07 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 23:46:07 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 23:46:07 - logging_args - INFO - fetching args done.\n2023-11-05 23:46:07 - zarr_info - INFO - ./ds_processing/ds_can_coh.zarr zarray shape: (740397, 17, 17)\n2023-11-05 23:46:07 - zarr_info - INFO - ./ds_processing/ds_can_coh.zarr zarray chunks: (123400, 1, 1)\n2023-11-05 23:46:07 - zarr_info - INFO - ./ds_processing/ds_can_coh.zarr zarray dtype: complex64\n2023-11-05 23:46:07 - zarr_info - INFO - ./ds_processing/ds_can_ph.zarr zarray shape: (740397, 17)\n2023-11-05 23:46:07 - zarr_info - INFO - ./ds_processing/ds_can_ph.zarr zarray chunks: (123400, 17)\n2023-11-05 23:46:07 - zarr_info - INFO - ./ds_processing/ds_can_ph.zarr zarray dtype: complex64\n2023-11-05 23:46:07 - get_pc_chunk_size_from_pc_chunk_size - INFO - automatically determine pc_chunk_size from\n            pc_chunk_size of coh.\n2023-11-05 23:46:07 - get_pc_chunk_size_from_pc_chunk_size - INFO - pc_chunk_size for ph: 123400\n2023-11-05 23:46:07 - de_ds_temp_coh - INFO - starting dask CUDA local cluster.\n2023-11-05 23:46:12 - de_ds_temp_coh - INFO - dask local CUDA cluster started.\n2023-11-05 23:46:12 - darr_info - INFO - coh dask array shape: (740397, 17, 17)\n2023-11-05 23:46:12 - darr_info - INFO - coh dask array chunksize: (123400, 17, 17)\n2023-11-05 23:46:12 - darr_info - INFO - coh dask array dtype: complex64\n2023-11-05 23:46:12 - darr_info - INFO - ph dask array shape: (740397, 17)\n2023-11-05 23:46:12 - darr_info - INFO - ph dask array chunksize: (123400, 17)\n2023-11-05 23:46:12 - darr_info - INFO - ph dask array dtype: complex64\n2023-11-05 23:46:12 - de_ds_temp_coh - INFO - Estimate temporal coherence for DS.\n2023-11-05 23:46:12 - de_ds_temp_coh - INFO - got temporal coherence t_coh.\n2023-11-05 23:46:12 - darr_info - INFO - t_coh dask array shape: (740397,)\n2023-11-05 23:46:12 - darr_info - INFO - t_coh dask array chunksize: (123400,)\n2023-11-05 23:46:12 - darr_info - INFO - t_coh dask array dtype: float32\n2023-11-05 23:46:12 - de_ds_temp_coh - INFO - saving t_coh.\n2023-11-05 23:46:13 - de_ds_temp_coh - INFO - computing graph setted. doing all the computing.\n2023-11-05 23:46:14 - de_ds_temp_coh - INFO - computing finished.5s\n2023-11-05 23:46:16 - de_ds_temp_coh - INFO - dask cluster closed.\n\n\nPlot it:\n\nt_coh = './ds_processing/t_coh.zarr'\nrslc_zarr = zarr.open(rslc,'r')\nde_pc2ras(ds_can_idx, ds_can_t_coh,t_coh,rslc_zarr.shape[:2],az_chunk_size=rslc_zarr.chunks[0])\n\n2023-11-05 23:46:17 - logging_args - INFO - running function: de_pc2ras\n2023-11-05 23:46:17 - logging_args - INFO - fetching args:\n2023-11-05 23:46:17 - logging_args - INFO - idx = './ds_processing/ds_can_idx.zarr'\n2023-11-05 23:46:17 - logging_args - INFO - pc = './ds_processing/ds_can_t_coh.zarr'\n2023-11-05 23:46:17 - logging_args - INFO - ras = './ds_processing/t_coh.zarr'\n2023-11-05 23:46:17 - logging_args - INFO - shape = (2500, 1834)\n2023-11-05 23:46:17 - logging_args - INFO - az_chunk_size = 1000\n2023-11-05 23:46:17 - logging_args - INFO - n_az_chunk = None\n2023-11-05 23:46:17 - logging_args - INFO - r_chunk_size = None\n2023-11-05 23:46:17 - logging_args - INFO - n_r_chunk = None\n2023-11-05 23:46:17 - logging_args - INFO - fetching args done.\n2023-11-05 23:46:17 - zarr_info - INFO - idx zarray shape: (2, 740397)\n2023-11-05 23:46:17 - zarr_info - INFO - idx zarray chunks: (2, 123400)\n2023-11-05 23:46:17 - zarr_info - INFO - idx zarray dtype: int32\n2023-11-05 23:46:17 - get_ras_chunk_size_from_n_pc_chunk - INFO - automatically set r_chunk_size to nlines of ras\n2023-11-05 23:46:17 - get_ras_chunk_size_from_n_pc_chunk - INFO - got az_chunk_size for ras: 1000\n2023-11-05 23:46:17 - de_pc2ras - INFO - loading idx into memory.\n2023-11-05 23:46:17 - de_pc2ras - INFO - starting dask local cluster.\n2023-11-05 23:46:22 - de_pc2ras - INFO - dask local cluster started.\n2023-11-05 23:46:22 - de_pc2ras - INFO - start to work on ./ds_processing/ds_can_t_coh.zarr\n2023-11-05 23:46:22 - zarr_info - INFO - ./ds_processing/ds_can_t_coh.zarr zarray shape: (740397,)\n2023-11-05 23:46:22 - zarr_info - INFO - ./ds_processing/ds_can_t_coh.zarr zarray chunks: (123400,)\n2023-11-05 23:46:22 - zarr_info - INFO - ./ds_processing/ds_can_t_coh.zarr zarray dtype: float32\n2023-11-05 23:46:22 - darr_info - INFO - pc dask array shape: (740397,)\n2023-11-05 23:46:22 - darr_info - INFO - pc dask array chunksize: (123400,)\n2023-11-05 23:46:22 - darr_info - INFO - pc dask array dtype: float32\n2023-11-05 23:46:22 - de_pc2ras - INFO - create ras dask array\n2023-11-05 23:46:22 - darr_info - INFO - ras dask array shape: (2500, 1834)\n2023-11-05 23:46:22 - darr_info - INFO - ras dask array chunksize: (1000, 1834)\n2023-11-05 23:46:22 - darr_info - INFO - ras dask array dtype: float32\n2023-11-05 23:46:22 - de_pc2ras - INFO - computing graph setted. doing all the computing.\n2023-11-05 23:46:23 - de_pc2ras - INFO - computing finished.|  0.8s\n2023-11-05 23:46:23 - de_pc2ras - INFO - dask cluster closed.\n\n\n\nt_coh_zarr = zarr.open(t_coh,'r')\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(t_coh_zarr[:],interpolation='nearest')\nax.set(title='DS temporal coherence',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)",
    "crumbs": [
      "Tutorials",
      "CLI",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ds_processing.html#ds-candidiates-refinement",
    "href": "Tutorials/CLI/ds_processing.html#ds-candidiates-refinement",
    "title": "DS Processing",
    "section": "DS candidiates refinement",
    "text": "DS candidiates refinement\nThen, we refine the ds candidate using EMI quality factor and the temporal coherence:\n\nfrom decorrelation.cli.pc import de_pc_logic_pc,de_pc_intersect,de_pc_select_data\n\n\nds_can_r1_idx = './ds_processing/ds_can_r1_idx.zarr'\nde_pc_logic_pc(ds_can_idx, ds_can_emi_quality,ds_can_r1_idx,'(pc_in&gt;=1.0)&(pc_in&lt;=1.2)')\n\n2023-11-05 23:47:31 - logging_args - INFO - running function: de_pc_logic_pc\n2023-11-05 23:47:31 - logging_args - INFO - fetching args:\n2023-11-05 23:47:31 - logging_args - INFO - idx_in = './ds_processing/ds_can_idx.zarr'\n2023-11-05 23:47:31 - logging_args - INFO - pc_in = './ds_processing/ds_can_emi_quality.zarr'\n2023-11-05 23:47:31 - logging_args - INFO - idx = './ds_processing/ds_can_r1_idx.zarr'\n2023-11-05 23:47:31 - logging_args - INFO - operation = '(pc_in&gt;=1.0)&(pc_in&lt;=1.2)'\n2023-11-05 23:47:31 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 23:47:31 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 23:47:31 - logging_args - INFO - fetching args done.\n2023-11-05 23:47:31 - zarr_info - INFO - ./ds_processing/ds_can_idx.zarr zarray shape: (2, 740397)\n2023-11-05 23:47:31 - zarr_info - INFO - ./ds_processing/ds_can_idx.zarr zarray chunks: (2, 123400)\n2023-11-05 23:47:31 - zarr_info - INFO - ./ds_processing/ds_can_idx.zarr zarray dtype: int32\n2023-11-05 23:47:31 - zarr_info - INFO - ./ds_processing/ds_can_emi_quality.zarr zarray shape: (740397,)\n2023-11-05 23:47:31 - zarr_info - INFO - ./ds_processing/ds_can_emi_quality.zarr zarray chunks: (123400,)\n2023-11-05 23:47:31 - zarr_info - INFO - ./ds_processing/ds_can_emi_quality.zarr zarray dtype: float32\n2023-11-05 23:47:31 - de_pc_logic_pc - INFO - loading idx_in into memory.\n2023-11-05 23:47:31 - de_pc_logic_pc - INFO - loading pc_in into memory.\n2023-11-05 23:47:31 - de_pc_logic_pc - INFO - select pc based on operation: (pc_in&gt;=1.0)&(pc_in&lt;=1.2)\n2023-11-05 23:47:31 - de_pc_logic_pc - INFO - number of selected pixels: 667111.\n2023-11-05 23:47:31 - get_pc_chunk_size_from_n_pc_chunk - INFO - automatically determine pc_chunk_size from\n            n_pc of idx and n_pc_chunk of idx_in\n2023-11-05 23:47:31 - get_pc_chunk_size_from_n_pc_chunk - INFO - pc_chunk_size for idx: 111186\n2023-11-05 23:47:31 - zarr_info - INFO - idx zarray shape: (2, 667111)\n2023-11-05 23:47:31 - zarr_info - INFO - idx zarray chunks: (2, 111186)\n2023-11-05 23:47:31 - zarr_info - INFO - idx zarray dtype: int32\n2023-11-05 23:47:31 - de_pc_logic_pc - INFO - writing idx.\n2023-11-05 23:47:31 - de_pc_logic_pc - INFO - write done.\n\n\n\nds_can_r2_idx = './ds_processing/ds_can_r2_idx.zarr'\nde_pc_logic_pc(ds_can_idx, ds_can_t_coh,ds_can_r2_idx,'(pc_in&gt;=0.5)&(pc_in&lt;=1.0)')\n\n2023-11-05 23:49:17 - logging_args - INFO - running function: de_pc_logic_pc\n2023-11-05 23:49:17 - logging_args - INFO - fetching args:\n2023-11-05 23:49:17 - logging_args - INFO - idx_in = './ds_processing/ds_can_idx.zarr'\n2023-11-05 23:49:17 - logging_args - INFO - pc_in = './ds_processing/ds_can_t_coh.zarr'\n2023-11-05 23:49:17 - logging_args - INFO - idx = './ds_processing/ds_can_r2_idx.zarr'\n2023-11-05 23:49:17 - logging_args - INFO - operation = '(pc_in&gt;=0.5)&(pc_in&lt;=1.0)'\n2023-11-05 23:49:17 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 23:49:17 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 23:49:17 - logging_args - INFO - fetching args done.\n2023-11-05 23:49:17 - zarr_info - INFO - ./ds_processing/ds_can_idx.zarr zarray shape: (2, 740397)\n2023-11-05 23:49:17 - zarr_info - INFO - ./ds_processing/ds_can_idx.zarr zarray chunks: (2, 123400)\n2023-11-05 23:49:17 - zarr_info - INFO - ./ds_processing/ds_can_idx.zarr zarray dtype: int32\n2023-11-05 23:49:17 - zarr_info - INFO - ./ds_processing/ds_can_t_coh.zarr zarray shape: (740397,)\n2023-11-05 23:49:17 - zarr_info - INFO - ./ds_processing/ds_can_t_coh.zarr zarray chunks: (123400,)\n2023-11-05 23:49:17 - zarr_info - INFO - ./ds_processing/ds_can_t_coh.zarr zarray dtype: float32\n2023-11-05 23:49:17 - de_pc_logic_pc - INFO - loading idx_in into memory.\n2023-11-05 23:49:17 - de_pc_logic_pc - INFO - loading pc_in into memory.\n2023-11-05 23:49:17 - de_pc_logic_pc - INFO - select pc based on operation: (pc_in&gt;=0.5)&(pc_in&lt;=1.0)\n2023-11-05 23:49:17 - de_pc_logic_pc - INFO - number of selected pixels: 610219.\n2023-11-05 23:49:17 - get_pc_chunk_size_from_n_pc_chunk - INFO - automatically determine pc_chunk_size from\n            n_pc of idx and n_pc_chunk of idx_in\n2023-11-05 23:49:17 - get_pc_chunk_size_from_n_pc_chunk - INFO - pc_chunk_size for idx: 101704\n2023-11-05 23:49:17 - zarr_info - INFO - idx zarray shape: (2, 610219)\n2023-11-05 23:49:17 - zarr_info - INFO - idx zarray chunks: (2, 101704)\n2023-11-05 23:49:17 - zarr_info - INFO - idx zarray dtype: int32\n2023-11-05 23:49:17 - de_pc_logic_pc - INFO - writing idx.\n2023-11-05 23:49:17 - de_pc_logic_pc - INFO - write done.\n\n\nGet their intersection and mask water:\n\n\n\n\n\n\nNote\n\n\n\nNote that de_pc_union can be applied is the coherence is not good and no much pixels selected.\n\n\n\nds_can_r_idx = './ds_processing/ds_can_r_idx.zarr'\nds_idx = './ds_processing/ds_idx.zarr'\nnon_nan_idx = './load_data/non_nan.zarr'\nde_pc_intersect(ds_can_r1_idx,ds_can_r2_idx,ds_can_r_idx)\nde_pc_intersect(ds_can_r_idx,non_nan_idx,ds_idx)\n\n2023-11-05 23:49:28 - logging_args - INFO - running function: de_pc_intersect\n2023-11-05 23:49:28 - logging_args - INFO - fetching args:\n2023-11-05 23:49:28 - logging_args - INFO - idx1 = './ds_processing/ds_can_r1_idx.zarr'\n2023-11-05 23:49:28 - logging_args - INFO - idx2 = './ds_processing/ds_can_r2_idx.zarr'\n2023-11-05 23:49:28 - logging_args - INFO - idx = './ds_processing/ds_can_r_idx.zarr'\n2023-11-05 23:49:28 - logging_args - INFO - pc1 = None\n2023-11-05 23:49:28 - logging_args - INFO - pc2 = None\n2023-11-05 23:49:28 - logging_args - INFO - pc = None\n2023-11-05 23:49:28 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 23:49:28 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 23:49:28 - logging_args - INFO - prefer_1 = True\n2023-11-05 23:49:28 - logging_args - INFO - fetching args done.\n2023-11-05 23:49:28 - zarr_info - INFO - ./ds_processing/ds_can_r1_idx.zarr zarray shape: (2, 667111)\n2023-11-05 23:49:28 - zarr_info - INFO - ./ds_processing/ds_can_r1_idx.zarr zarray chunks: (2, 111186)\n2023-11-05 23:49:28 - zarr_info - INFO - ./ds_processing/ds_can_r1_idx.zarr zarray dtype: int32\n2023-11-05 23:49:28 - zarr_info - INFO - ./ds_processing/ds_can_r2_idx.zarr zarray shape: (2, 610219)\n2023-11-05 23:49:28 - zarr_info - INFO - ./ds_processing/ds_can_r2_idx.zarr zarray chunks: (2, 101704)\n2023-11-05 23:49:28 - zarr_info - INFO - ./ds_processing/ds_can_r2_idx.zarr zarray dtype: int32\n2023-11-05 23:49:28 - de_pc_intersect - INFO - loading idx1 and idx2 into memory.\n2023-11-05 23:49:28 - de_pc_intersect - INFO - calculate the intersection\n2023-11-05 23:49:28 - de_pc_intersect - INFO - number of points in the intersection: 574010\n2023-11-05 23:49:28 - get_pc_chunk_size_from_n_pc_chunk - INFO - automatically determine pc_chunk_size from\n            n_pc of idx and n_pc_chunk of idx1\n2023-11-05 23:49:28 - get_pc_chunk_size_from_n_pc_chunk - INFO - pc_chunk_size for idx: 95669\n2023-11-05 23:49:28 - de_pc_intersect - INFO - write intersect idx\n2023-11-05 23:49:29 - de_pc_intersect - INFO - write done\n2023-11-05 23:49:29 - zarr_info - INFO - ./ds_processing/ds_can_r_idx.zarr zarray shape: (2, 574010)\n2023-11-05 23:49:29 - zarr_info - INFO - ./ds_processing/ds_can_r_idx.zarr zarray chunks: (2, 95669)\n2023-11-05 23:49:29 - zarr_info - INFO - ./ds_processing/ds_can_r_idx.zarr zarray dtype: int32\n2023-11-05 23:49:29 - de_pc_intersect - INFO - no point cloud data provided, exit.\n2023-11-05 23:49:29 - logging_args - INFO - running function: de_pc_intersect\n2023-11-05 23:49:29 - logging_args - INFO - fetching args:\n2023-11-05 23:49:29 - logging_args - INFO - idx1 = './ds_processing/ds_can_r_idx.zarr'\n2023-11-05 23:49:29 - logging_args - INFO - idx2 = './load_data/non_nan.zarr'\n2023-11-05 23:49:29 - logging_args - INFO - idx = './ds_processing/ds_idx.zarr'\n2023-11-05 23:49:29 - logging_args - INFO - pc1 = None\n2023-11-05 23:49:29 - logging_args - INFO - pc2 = None\n2023-11-05 23:49:29 - logging_args - INFO - pc = None\n2023-11-05 23:49:29 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 23:49:29 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 23:49:29 - logging_args - INFO - prefer_1 = True\n2023-11-05 23:49:29 - logging_args - INFO - fetching args done.\n2023-11-05 23:49:29 - zarr_info - INFO - ./ds_processing/ds_can_r_idx.zarr zarray shape: (2, 574010)\n2023-11-05 23:49:29 - zarr_info - INFO - ./ds_processing/ds_can_r_idx.zarr zarray chunks: (2, 95669)\n2023-11-05 23:49:29 - zarr_info - INFO - ./ds_processing/ds_can_r_idx.zarr zarray dtype: int32\n2023-11-05 23:49:29 - zarr_info - INFO - ./load_data/non_nan.zarr zarray shape: (2, 4439623)\n2023-11-05 23:49:29 - zarr_info - INFO - ./load_data/non_nan.zarr zarray chunks: (2, 739938)\n2023-11-05 23:49:29 - zarr_info - INFO - ./load_data/non_nan.zarr zarray dtype: int32\n2023-11-05 23:49:29 - de_pc_intersect - INFO - loading idx1 and idx2 into memory.\n2023-11-05 23:49:29 - de_pc_intersect - INFO - calculate the intersection\n2023-11-05 23:49:29 - de_pc_intersect - INFO - number of points in the intersection: 571314\n2023-11-05 23:49:29 - get_pc_chunk_size_from_n_pc_chunk - INFO - automatically determine pc_chunk_size from\n            n_pc of idx and n_pc_chunk of idx1\n2023-11-05 23:49:29 - get_pc_chunk_size_from_n_pc_chunk - INFO - pc_chunk_size for idx: 95219\n2023-11-05 23:49:29 - de_pc_intersect - INFO - write intersect idx\n2023-11-05 23:49:29 - de_pc_intersect - INFO - write done\n2023-11-05 23:49:29 - zarr_info - INFO - ./ds_processing/ds_idx.zarr zarray shape: (2, 571314)\n2023-11-05 23:49:29 - zarr_info - INFO - ./ds_processing/ds_idx.zarr zarray chunks: (2, 95219)\n2023-11-05 23:49:29 - zarr_info - INFO - ./ds_processing/ds_idx.zarr zarray dtype: int32\n2023-11-05 23:49:29 - de_pc_intersect - INFO - no point cloud data provided, exit.\n\n\nThen get the needed data for ds:\n\nds_coh = './ds_processing/ds_coh.zarr'\nds_ph = './ds_processing/ds_ph.zarr'\nds_e = './ds_processing/ds_e.zarr'\nds_n = './ds_processing/ds_n.zarr'\nds_lon = './ds_processing/ds_lon.zarr'\nds_lat = './ds_processing/ds_lat.zarr'\n\n\nde_pc_select_data(ds_can_idx,ds_idx,pc_in=[ds_can_coh,ds_can_ph,ds_can_e,ds_can_n,ds_can_lon,ds_can_lat],pc=[ds_coh,ds_ph,ds_e,ds_n,ds_lon,ds_lat])\n\n2023-11-05 23:49:43 - logging_args - INFO - running function: de_pc_select_data\n2023-11-05 23:49:43 - logging_args - INFO - fetching args:\n2023-11-05 23:49:43 - logging_args - INFO - idx_in = './ds_processing/ds_can_idx.zarr'\n2023-11-05 23:49:43 - logging_args - INFO - idx = './ds_processing/ds_idx.zarr'\n2023-11-05 23:49:43 - logging_args - INFO - pc_in = ['./ds_processing/ds_can_coh.zarr', './ds_processing/ds_can_ph.zarr', './ds_processing/ds_can_e.zarr', './ds_processing/ds_can_n.zarr', './ds_processing/ds_can_lon.zarr', './ds_processing/ds_can_lat.zarr']\n2023-11-05 23:49:43 - logging_args - INFO - pc = ['./ds_processing/ds_coh.zarr', './ds_processing/ds_ph.zarr', './ds_processing/ds_e.zarr', './ds_processing/ds_n.zarr', './ds_processing/ds_lon.zarr', './ds_processing/ds_lat.zarr']\n2023-11-05 23:49:43 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 23:49:43 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 23:49:43 - logging_args - INFO - fetching args done.\n2023-11-05 23:49:43 - zarr_info - INFO - ./ds_processing/ds_can_idx.zarr zarray shape: (2, 740397)\n2023-11-05 23:49:43 - zarr_info - INFO - ./ds_processing/ds_can_idx.zarr zarray chunks: (2, 123400)\n2023-11-05 23:49:43 - zarr_info - INFO - ./ds_processing/ds_can_idx.zarr zarray dtype: int32\n2023-11-05 23:49:43 - zarr_info - INFO - ./ds_processing/ds_idx.zarr zarray shape: (2, 571314)\n2023-11-05 23:49:43 - zarr_info - INFO - ./ds_processing/ds_idx.zarr zarray chunks: (2, 95219)\n2023-11-05 23:49:43 - zarr_info - INFO - ./ds_processing/ds_idx.zarr zarray dtype: int32\n2023-11-05 23:49:43 - de_pc_select_data - INFO - loading idx_in and idx into memory.\n2023-11-05 23:49:43 - get_pc_chunk_size_from_pc_chunk_size - INFO - automatically determine pc_chunk_size from\n            pc_chunk_size of idx.\n2023-11-05 23:49:43 - get_pc_chunk_size_from_pc_chunk_size - INFO - pc_chunk_size for pc: 95219\n2023-11-05 23:49:43 - de_pc_select_data - INFO - starting dask local cluster.\n2023-11-05 23:49:48 - de_pc_select_data - INFO - dask local cluster started.\n2023-11-05 23:49:48 - zarr_info - INFO - ./ds_processing/ds_can_coh.zarr zarray shape: (740397, 17, 17)\n2023-11-05 23:49:48 - zarr_info - INFO - ./ds_processing/ds_can_coh.zarr zarray chunks: (123400, 1, 1)\n2023-11-05 23:49:48 - zarr_info - INFO - ./ds_processing/ds_can_coh.zarr zarray dtype: complex64\n2023-11-05 23:49:48 - darr_info - INFO - pc_in dask array shape: (740397, 17, 17)\n2023-11-05 23:49:48 - darr_info - INFO - pc_in dask array chunksize: (123400, 1, 1)\n2023-11-05 23:49:48 - darr_info - INFO - pc_in dask array dtype: complex64\n2023-11-05 23:49:48 - de_pc_select_data - INFO - set up selected pc data dask array.\n2023-11-05 23:49:48 - darr_info - INFO - pc dask array shape: (571314, 17, 17)\n2023-11-05 23:49:48 - darr_info - INFO - pc dask array chunksize: (95219, 1, 1)\n2023-11-05 23:49:48 - darr_info - INFO - pc dask array dtype: complex64\n2023-11-05 23:49:54 - zarr_info - INFO - ./ds_processing/ds_can_ph.zarr zarray shape: (740397, 17)\n2023-11-05 23:49:54 - zarr_info - INFO - ./ds_processing/ds_can_ph.zarr zarray chunks: (123400, 17)\n2023-11-05 23:49:54 - zarr_info - INFO - ./ds_processing/ds_can_ph.zarr zarray dtype: complex64\n2023-11-05 23:49:54 - darr_info - INFO - pc_in dask array shape: (740397, 17)\n2023-11-05 23:49:54 - darr_info - INFO - pc_in dask array chunksize: (123400, 17)\n2023-11-05 23:49:54 - darr_info - INFO - pc_in dask array dtype: complex64\n2023-11-05 23:49:54 - de_pc_select_data - INFO - set up selected pc data dask array.\n2023-11-05 23:49:54 - darr_info - INFO - pc dask array shape: (571314, 17)\n2023-11-05 23:49:54 - darr_info - INFO - pc dask array chunksize: (95219, 17)\n2023-11-05 23:49:54 - darr_info - INFO - pc dask array dtype: complex64\n2023-11-05 23:49:54 - zarr_info - INFO - ./ds_processing/ds_can_e.zarr zarray shape: (740397,)\n2023-11-05 23:49:54 - zarr_info - INFO - ./ds_processing/ds_can_e.zarr zarray chunks: (123400,)\n2023-11-05 23:49:54 - zarr_info - INFO - ./ds_processing/ds_can_e.zarr zarray dtype: float64\n2023-11-05 23:49:54 - darr_info - INFO - pc_in dask array shape: (740397,)\n2023-11-05 23:49:54 - darr_info - INFO - pc_in dask array chunksize: (123400,)\n2023-11-05 23:49:54 - darr_info - INFO - pc_in dask array dtype: float64\n2023-11-05 23:49:54 - de_pc_select_data - INFO - set up selected pc data dask array.\n2023-11-05 23:49:54 - darr_info - INFO - pc dask array shape: (571314,)\n2023-11-05 23:49:54 - darr_info - INFO - pc dask array chunksize: (95219,)\n2023-11-05 23:49:54 - darr_info - INFO - pc dask array dtype: float64\n2023-11-05 23:49:55 - zarr_info - INFO - ./ds_processing/ds_can_n.zarr zarray shape: (740397,)\n2023-11-05 23:49:55 - zarr_info - INFO - ./ds_processing/ds_can_n.zarr zarray chunks: (123400,)\n2023-11-05 23:49:55 - zarr_info - INFO - ./ds_processing/ds_can_n.zarr zarray dtype: float64\n2023-11-05 23:49:55 - darr_info - INFO - pc_in dask array shape: (740397,)\n2023-11-05 23:49:55 - darr_info - INFO - pc_in dask array chunksize: (123400,)\n2023-11-05 23:49:55 - darr_info - INFO - pc_in dask array dtype: float64\n2023-11-05 23:49:55 - de_pc_select_data - INFO - set up selected pc data dask array.\n2023-11-05 23:49:55 - darr_info - INFO - pc dask array shape: (571314,)\n2023-11-05 23:49:55 - darr_info - INFO - pc dask array chunksize: (95219,)\n2023-11-05 23:49:55 - darr_info - INFO - pc dask array dtype: float64\n2023-11-05 23:49:55 - zarr_info - INFO - ./ds_processing/ds_can_lon.zarr zarray shape: (740397,)\n2023-11-05 23:49:55 - zarr_info - INFO - ./ds_processing/ds_can_lon.zarr zarray chunks: (123400,)\n2023-11-05 23:49:55 - zarr_info - INFO - ./ds_processing/ds_can_lon.zarr zarray dtype: float64\n2023-11-05 23:49:55 - darr_info - INFO - pc_in dask array shape: (740397,)\n2023-11-05 23:49:55 - darr_info - INFO - pc_in dask array chunksize: (123400,)\n2023-11-05 23:49:55 - darr_info - INFO - pc_in dask array dtype: float64\n2023-11-05 23:49:55 - de_pc_select_data - INFO - set up selected pc data dask array.\n2023-11-05 23:49:55 - darr_info - INFO - pc dask array shape: (571314,)\n2023-11-05 23:49:55 - darr_info - INFO - pc dask array chunksize: (95219,)\n2023-11-05 23:49:55 - darr_info - INFO - pc dask array dtype: float64\n2023-11-05 23:49:55 - zarr_info - INFO - ./ds_processing/ds_can_lat.zarr zarray shape: (740397,)\n2023-11-05 23:49:55 - zarr_info - INFO - ./ds_processing/ds_can_lat.zarr zarray chunks: (123400,)\n2023-11-05 23:49:55 - zarr_info - INFO - ./ds_processing/ds_can_lat.zarr zarray dtype: float64\n2023-11-05 23:49:55 - darr_info - INFO - pc_in dask array shape: (740397,)\n2023-11-05 23:49:55 - darr_info - INFO - pc_in dask array chunksize: (123400,)\n2023-11-05 23:49:55 - darr_info - INFO - pc_in dask array dtype: float64\n2023-11-05 23:49:55 - de_pc_select_data - INFO - set up selected pc data dask array.\n2023-11-05 23:49:55 - darr_info - INFO - pc dask array shape: (571314,)\n2023-11-05 23:49:55 - darr_info - INFO - pc dask array chunksize: (95219,)\n2023-11-05 23:49:55 - darr_info - INFO - pc dask array dtype: float64\n2023-11-05 23:49:55 - de_pc_select_data - INFO - computing graph setted. doing all the computing.\n2023-11-05 23:50:03 - de_pc_select_data - INFO - computing finished.[2K\n2023-11-05 23:50:04 - de_pc_select_data - INFO - dask cluster closed.\n\n\n\nds_coh_zarr = zarr.open(ds_coh,'r')\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(np.mean(abs(ds_coh_zarr[:]),axis=0),cmap=colorcet.cm.fire)\nax.set(title='Average coherence matrix',xlabel='Image Index',ylabel='Image Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\n\n\n\nHere we find the coherence matrix is better.",
    "crumbs": [
      "Tutorials",
      "CLI",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html",
    "href": "Tutorials/adaptive_multilook.html",
    "title": "Adaptive Multilook",
    "section": "",
    "text": "In this tutorial, we demostrate how to use decorrelation package to identify spatially homogeneous pixels, extimate the coherence matrix and compare the original interferogram, multilook intergerogram and the adaptive multilook interferogram.\nimport numpy as np\nimport zarr\nfrom matplotlib import pyplot as plt\n\nimport cupy as cp\nfrom cupyx.scipy.ndimage import uniform_filter\n\nfrom decorrelation.shp import ks_test\nfrom decorrelation.plot import bg_alpha\nfrom decorrelation.co import emperical_co",
    "crumbs": [
      "Tutorials",
      "API",
      "Adaptive Multilook"
    ]
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html#load-rslc-stack",
    "href": "Tutorials/adaptive_multilook.html#load-rslc-stack",
    "title": "Adaptive Multilook",
    "section": "Load rslc stack",
    "text": "Load rslc stack\n\ncp.cuda.Device(1).use()\n\n&lt;CUDA Device 1&gt;\n\n\n\nrslc = cp.asarray(zarr.open('../../data/rslc.zarr','r')[:])\nrslc.shape\n\n(2500, 1834, 17)",
    "crumbs": [
      "Tutorials",
      "API",
      "Adaptive Multilook"
    ]
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html#apply-ks-test",
    "href": "Tutorials/adaptive_multilook.html#apply-ks-test",
    "title": "Adaptive Multilook",
    "section": "Apply ks test",
    "text": "Apply ks test\n\nrmli = cp.abs(rslc)**2\n\n\naz_half_win = 5\nr_half_win = 5\naz_win = 2*az_half_win+1\nr_win = 2*r_half_win+1\n\n\np = ks_test(rmli,az_half_win=az_half_win,r_half_win=r_half_win)[1]\n\nCPU times: user 371 ms, sys: 56.7 ms, total: 428 ms\nWall time: 821 ms\n\n\nks_test in decorrelation package is extremely fast!",
    "crumbs": [
      "Tutorials",
      "API",
      "Adaptive Multilook"
    ]
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html#select-shps",
    "href": "Tutorials/adaptive_multilook.html#select-shps",
    "title": "Adaptive Multilook",
    "section": "Select SHPs",
    "text": "Select SHPs\n\nis_shp = (p &lt; 0.05) & (p &gt;= 0.0)\n\n\nshp_num = cp.count_nonzero(is_shp,axis=(-2,-1))\nshp_num_np = cp.asnumpy(shp_num)\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(shp_num_np)\nax.set(title='Number of SHPs',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()",
    "crumbs": [
      "Tutorials",
      "API",
      "Adaptive Multilook"
    ]
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html#estimate-coherence-matrix",
    "href": "Tutorials/adaptive_multilook.html#estimate-coherence-matrix",
    "title": "Adaptive Multilook",
    "section": "Estimate coherence matrix",
    "text": "Estimate coherence matrix\n\ncoh = emperical_co(rslc,is_shp)[1]\n\nCPU times: user 2.63 s, sys: 38.1 ms, total: 2.67 s\nWall time: 2.86 s",
    "crumbs": [
      "Tutorials",
      "API",
      "Adaptive Multilook"
    ]
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html#compare",
    "href": "Tutorials/adaptive_multilook.html#compare",
    "title": "Adaptive Multilook",
    "section": "Compare",
    "text": "Compare\nHere we compare 1-look interferogram, multilook interferogram and adaptive multilook interferogram\n\nref_image = 15\nsec_image = 16\n\n1 look interferogram:\n\ndiff = rslc[:,:,ref_image]*rslc[:,:,sec_image].conj()\n\nMultilook interferogram:\n\nml_diff = uniform_filter(diff,size=(az_win,r_win))\n\nAdaptive multilook interferogram:\n\nad_ml_diff = coh[:,:,ref_image,sec_image]\n\nThe plot background:\n\nplot_bg = rmli[:,:,0]\nplot_bg = cp.asnumpy(plot_bg)\nalpha = bg_alpha(plot_bg)\n\nPlot:\n\nfig,axes = plt.subplots(1,3,figsize=(24/2,7/2))\nxlabel = 'Range Index'\nylabel = 'Azimuth Index'\npcm0 = axes[0].imshow(cp.asnumpy(cp.angle(diff)),alpha=alpha,interpolation='nearest',cmap='hsv')\npcm1 = axes[1].imshow(cp.asnumpy(cp.angle(ml_diff)),alpha=alpha,interpolation='nearest',cmap='hsv')\npcm2 = axes[2].imshow(cp.asnumpy(cp.angle(ad_ml_diff)),alpha=alpha,interpolation='nearest',cmap='hsv')\nfor ax in axes:\n    ax.set(facecolor = \"black\")\naxes[0].set(title='Orignal Interferogram',xlabel=xlabel,ylabel=ylabel)\naxes[1].set(title=f'Multilook {az_win} by {r_win}',xlabel=xlabel,ylabel=ylabel)\naxes[2].set(title=f'Adaptively multilook {az_win} by {r_win}',xlabel=xlabel,ylabel=ylabel)\nfig.colorbar(pcm0,ax=axes[0])\nfig.colorbar(pcm1,ax=axes[1])\nfig.colorbar(pcm1,ax=axes[2])\nfig.show()",
    "crumbs": [
      "Tutorials",
      "API",
      "Adaptive Multilook"
    ]
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html#conclusion",
    "href": "Tutorials/adaptive_multilook.html#conclusion",
    "title": "Adaptive Multilook",
    "section": "Conclusion",
    "text": "Conclusion\n\nAdaptive multilooking based on SHPs selection performs better than non-adaptive one;\nks_test and emperical_co implemented in decorrelation package are fast.",
    "crumbs": [
      "Tutorials",
      "API",
      "Adaptive Multilook"
    ]
  },
  {
    "objectID": "API/shp.html",
    "href": "API/shp.html",
    "title": "shp",
    "section": "",
    "text": "from scipy import stats\nimport numpy as np\nimport itertools",
    "crumbs": [
      "API",
      "shp"
    ]
  },
  {
    "objectID": "API/shp.html#kolmogorov-smirnov-ks-two-sample-test",
    "href": "API/shp.html#kolmogorov-smirnov-ks-two-sample-test",
    "title": "shp",
    "section": "Kolmogorov-Smirnov (KS) two-sample test",
    "text": "Kolmogorov-Smirnov (KS) two-sample test\n\nsource\n\nks_test\n\n ks_test (rmli:cupy.ndarray, az_half_win:int, r_half_win:int,\n          block_size:int=128)\n\nSHP identification based on Two-Sample Kolmogorov-Smirnov Test.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrmli\nndarray\n\nthe rmli stack, dtype: cupy.floating\n\n\naz_half_win\nint\n\nSHP identification half search window size in azimuth direction\n\n\nr_half_win\nint\n\nSHP identification half search window size in range direction\n\n\nblock_size\nint\n128\nthe CUDA block size, it only affects the calculation speed\n\n\nReturns\ntuple\n\nthe KS test statistics dist and p value p\n\n\n\nThe ks_test function apply the Two-Sample Kolmogorov-Smirnov Test on a stack of rmli images to identify SHPs candidate for further processing. This method is originally published in (Ferretti et al. 2011). This function is designed to run on GPU for high speed.\n\nFerretti, Alessandro, Alfio Fumagalli, Fabrizio Novali, Claudio Prati, Fabio Rocca, and Alessio Rucci. 2011. “A New Algorithm for Processing Interferometric Data-Stacks: SqueeSAR.” IEEE Transactions on Geoscience and Remote Sensing 49 (9): 3460–70. https://doi.org/10.1109/TGRS.2011.2124465.\nThe rmli is a three dimentional cupy ndarray. The dtype should be float. From outerest to innerest, the three dimentions are azimuth, range and image. For each pixel P, a search window centered at P is defined by az_half_win and r_half_win. All pixels in this search window is compared with P by KS test. They are refered here as secondary pixels. The total number of secondary pixels (including P) is (2*az_half_win+1)*(2*r_half_win+1).\nThe returns are the ks test statistic which is the maximum value of the absolute difference between the emperical cumulative distribution functions of the two samples, and p value. Both of them are 4 dimentional cupy ndarrays. From outerest ot innerest, they are azimuth, range, secondary pixel relative azimuth, secondary pixel relative range. For P at the corner of the image where part of the search window is out of the image, the result is -1.\nHere is a simplest example. First simulate rmli time series of two pixels from two correlated normal distributions:\n\nsample_size = 20\nrng = np.random.default_rng()\nsample1 = stats.uniform.rvs(size=sample_size, random_state=rng).astype(cp.float32)\nsample2 = stats.norm.rvs(size=sample_size, random_state=rng).astype(cp.float32)\n\nConvert the data to cupy ndarray and make sure the dtype is cp.float32 and the data are sorted:\n\nrmli_stack = cp.stack((cp.asarray(sample1), cp.asarray(sample2))).reshape(1,2,sample_size)\nrmli_stack = rmli_stack.astype(cp.float32)\nrmli_stack.shape\n\n(1, 2, 20)\n\n\nThe shape of rmli_stack shows it contains 20 images. Each of the image has 1 pixel in azimuth dimention and 2 pixels in range dimention. Set the az_half_win and r_half_win to 1 and apply the ks_test function:\n\ndist,p = ks_test(rmli_stack,1,1)\nprint(dist.shape)\nprint(dist)\n\n(1, 2, 3, 3)\n[[[[-1.  -1.  -1. ]\n   [-1.   0.   0.6]\n   [-1.  -1.  -1. ]]\n\n  [[-1.  -1.  -1. ]\n   [ 0.6  0.  -1. ]\n   [-1.  -1.  -1. ]]]]\n\n\ndist is the ks test statistic. The shape of it shows for each pixel P in this 1*2 image, a 3*3 search window is defined and all pixels in this search window is test with P. The value 0 in dist is the ks test result of pixel P and pixel P itself. The value -1 means the secondary pixel is out of the image and no ks test is applied.\n\nprint(p.shape)\nprint(p)\n\n(1, 2, 3, 3)\n[[[[-1.0000000e+00 -1.0000000e+00 -1.0000000e+00]\n   [-1.0000000e+00  0.0000000e+00  7.2528544e-04]\n   [-1.0000000e+00 -1.0000000e+00 -1.0000000e+00]]\n\n  [[-1.0000000e+00 -1.0000000e+00 -1.0000000e+00]\n   [ 7.2528544e-04  0.0000000e+00 -1.0000000e+00]\n   [-1.0000000e+00 -1.0000000e+00 -1.0000000e+00]]]]\n\n\np is the ks test p value with same shape of dist.\n\nprint(stats.ks_2samp(sample1, sample2,method='asymp'))\n\nKstestResult(statistic=0.6, pvalue=0.0005681672000000003, statistic_location=-0.12029845, statistic_sign=-1)\n\n\nBy comparing the result of ks_test and ks_2samp from scipy, the statistics are same which prove the correctness of ks_test. The difference in p value is because the approcimation method used are different but the orders of magnitudes are consistent.",
    "crumbs": [
      "API",
      "shp"
    ]
  },
  {
    "objectID": "API/pc.html",
    "href": "API/pc.html",
    "title": "pc",
    "section": "",
    "text": "The indices of point cloud data idx is expressed as sorted int32 array with shape (2, n_point).\nidx[0,:] is their azimuth indices and idx[1,:] is the range indices.\nidx is first sorted in azimuth indices and then sorted in range indices.\nHere is an example:\narray([[0, 0, 1, 1, 2, 3],\n       [2, 3, 0, 3, 1, 2]], dtype=int32)\n\nsource\n\npc2ras\n\n pc2ras (idx:Union[numpy.ndarray,cupy.ndarray],\n         pc_data:Union[numpy.ndarray,cupy.ndarray], shape:tuple)\n\nconvert sparse data to raster, filled with nan\n\n\n\n\nType\nDetails\n\n\n\n\nidx\nUnion\nidx array\n\n\npc_data\nUnion\ndata, 1D or more\n\n\nshape\ntuple\nimage shape\n\n\n\n\nsource\n\n\npc_union\n\n pc_union (idx1:Union[numpy.ndarray,cupy.ndarray],\n           idx2:Union[numpy.ndarray,cupy.ndarray])\n\nGet the union of two point cloud dataset. For points at their intersection, pc_data1 rather than pc_data2 is copied to the result pc_data.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nidx1\nUnion\nint array, index of the first point cloud\n\n\nidx2\nUnion\nint array, index of the second point cloud\n\n\nReturns\ntuple\nthe union index idx; index of the point in output union index that originally in the first point cloud inv_iidx; index of the point in output union index that only exist in the second point cloud inv_iidx2; index of the point in the second input index that are not in the first input point cloud\n\n\n\nUsage:\n\nras = cp.array([[4,3,8,3],\n                [4,7,2,6],\n                [9,0,3,7],\n                [1,4,2,6]])\nidx1 = cp.array([[0,0,1,1,2,3],\n                 [2,3,0,3,1,2]],dtype=np.int32)\nidx2 = cp.array([[0,0,1,2,2,3],\n                 [0,3,1,1,3,1]],dtype=np.int32)\npc_data1 = cp.array([3,2,5,4,32,2])\npc_data2 = cp.array([3,5,6,2,1,4])\n\nidx, inv_iidx1, inv_iidx2, iidx2 = pc_union(idx1,idx2)\n\nWith all the returns in pc_union, it is very easy to construct the union data:\n\npc_data = cp.empty((idx.shape[1],*pc_data1.shape[1:]),dtype=pc_data1.dtype)\npc_data[inv_iidx1] = pc_data1\npc_data[inv_iidx2] = pc_data2[iidx2]\n\nnp.testing.assert_equal(cp.asnumpy(pc_data),np.array([3,3,2,5,6,4,32,1,4,2]))\nnp.testing.assert_equal(cp.asnumpy(ras[idx[0],idx[1]]),np.array([4,8,3,4,7,6,0,7,4,2]))\n\n\nsource\n\n\npc_intersect\n\n pc_intersect (idx1:Union[numpy.ndarray,cupy.ndarray],\n               idx2:Union[numpy.ndarray,cupy.ndarray])\n\nGet the intersection of two point cloud dataset.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nidx1\nUnion\nint array, index of the first point cloud\n\n\nidx2\nUnion\nint array, index of the second point cloud\n\n\nReturns\ntuple\nthe intersect index idx,index of the point in first point cloud index that also exist in the second point cloud,index of the point in second point cloud index that also exist in the first point cloud\n\n\n\n\nras = cp.array([[4,3,8,3],\n                [4,7,2,6],\n                [9,0,3,7],\n                [1,4,2,6]])\nidx1 = cp.array([[0,0,1,1,2,3],\n                 [2,3,0,3,1,2]],dtype=np.int32)\nidx2 = cp.array([[0,0,1,2,2,3],\n                 [0,3,1,1,3,1]],dtype=np.int32)\npc_data1 = cp.array([3,2,5,4,32,2])\npc_data2 = cp.array([3,5,6,2,1,4])\n\nidx, iidx1, iidx2 = pc_intersect(idx1,idx2)\npc_data_int1 = pc_data1[iidx1]\npc_data_int2 = pc_data2[iidx2]\n\nnp.testing.assert_equal(cp.asnumpy(idx),np.array([[0,2],\n                                                  [3,1]]))\nnp.testing.assert_equal(cp.asnumpy(ras[(idx[0],idx[1])]),np.array([3,0]))\nnp.testing.assert_equal(cp.asnumpy(pc_data_int1),np.array([2,32]))\nnp.testing.assert_equal(cp.asnumpy(pc_data_int2),np.array([5,2]))\n\n\nsource\n\n\npc_diff\n\n pc_diff (idx1:Union[numpy.ndarray,cupy.ndarray],\n          idx2:Union[numpy.ndarray,cupy.ndarray])\n\nGet the point cloud in idx1 that are not in idx2.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nidx1\nUnion\nint array, index of the first point cloud\n\n\nidx2\nUnion\nint array, index of the second point cloud\n\n\nReturns\ntuple\nthe diff index idx,index of the point in first point cloud index that do not exist in the second point cloud,\n\n\n\n\nidx1 = cp.array([[0,0,1,1,2,3],\n                 [2,3,0,3,1,2]],dtype=np.int32)\nidx2 = cp.array([[0,0,1,2,2,3],\n                 [0,3,1,1,3,1]],dtype=np.int32)\n\nidx, iidx1 = pc_diff(idx1,idx2)\npc_data_diff = pc_data1[iidx1]\n\nnp.testing.assert_equal(cp.asnumpy(idx),np.array([[0,1,1,3],\n                                                  [2,0,3,2]]))\nnp.testing.assert_equal(cp.asnumpy(iidx1),np.array([0,2,3,5]))",
    "crumbs": [
      "API",
      "pc"
    ]
  },
  {
    "objectID": "API/ps.html",
    "href": "API/ps.html",
    "title": "ps",
    "section": "",
    "text": "import zarr\nfrom matplotlib import pyplot as plt\nimport colorcet\n\n\nsource\n\namp_disp\n\n amp_disp (rslc:Union[cupy.ndarray,numpy.ndarray])\n\ncalculation the amplitude dispersion index from SLC stack.\n\n\n\n\nType\nDetails\n\n\n\n\nrslc\nUnion\nrslc stack\n\n\nReturns\nUnion\ndispersion index\n\n\n\nUsing amplitude dispersion index (ADI) to identify persistent scatterers is first used in (Ferretti, Prati, and Rocca Jan./2001).\n\nFerretti, A., C. Prati, and F. Rocca. Jan./2001. “Permanent Scatterers in SAR Interferometry.” IEEE Transactions on Geoscience and Remote Sensing 39 (1): 8–20. https://doi.org/10.1109/36.898661.\nUsage:\n\nrslc = zarr.open('../../data/rslc.zarr/','r')[:]\nrslc_gpu = cp.asarray(rslc)\n\n\nadi_cpu = amp_disp(rslc)\nadi_gpu = amp_disp(rslc_gpu)\nnp.testing.assert_array_almost_equal(adi_cpu,adi_gpu.get())\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(adi_cpu,vmin=0,vmax=1)\nax.set(title='Amplitude Dispersion Index',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()"
  },
  {
    "objectID": "CLI/plot.html",
    "href": "CLI/plot.html",
    "title": "plot",
    "section": "",
    "text": "import holoviews as hv\nimport numpy as np\nfrom decorrelation.cli.utils.logging import get_logger\n\nError.  nthreads cannot be larger than environment variable \"NUMEXPR_MAX_THREADS\" (64)\n\n\n\nsource\n\nrender_ras_tiles\n\n render_ras_tiles (ras:str, out_dir:str)\n\nrender raster data to tiles of difference zoom levels.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nras\nstr\npath to input data, 2D zarr array (one single raster) or 3D zarr array (a stack of rasters)\n\n\nout_dir\nstr\noutput directory to store rendered data\n\n\n\nrender_ras_tiles render one single raster (2D array) or a stack of rasters (2D array) into tiles of difference resolution (zoom level).\n\nadi = 'plot/adi.zarr'\nrslc = 'plot/rslc.zarr'\nrendered_adi_dir = 'plot/adi_tiles'\nrendered_rslc_dir = 'plot/rslc_tiles'\n\n\nlogger = get_logger()\n\n\nrender_ras_tiles(adi,rendered_adi_dir)\n\n2024-03-21 19:36:00 - logging_args - INFO - running function: render_ras_tiles\n2024-03-21 19:36:00 - logging_args - INFO - fetching args:\n2024-03-21 19:36:00 - logging_args - INFO - ras = 'plot/adi.zarr'\n2024-03-21 19:36:00 - logging_args - INFO - out_dir = 'plot/adi_tiles'\n2024-03-21 19:36:00 - logging_args - INFO - fetching args done.\n2024-03-21 19:36:00 - zarr_info - INFO - plot/adi.zarr zarray shape: (2500, 1834)\n2024-03-21 19:36:00 - zarr_info - INFO - plot/adi.zarr zarray chunks: (1000, 1000)\n2024-03-21 19:36:00 - zarr_info - INFO - plot/adi.zarr zarray dtype: float32\n2024-03-21 19:36:00 - render_ras_tiles - INFO - rendered tiles zoom level range from 0 (finest resolution) to 10 (coarsest resolution).\n2024-03-21 19:36:00 - render_ras_tiles - INFO - tiles to be rendered: \n                       path         shape      chunks    dtype\n0    plot/adi_tiles/0.zarr  (2500, 1834)  (256, 256)  float32\n1    plot/adi_tiles/1.zarr   (1250, 917)  (256, 256)  float32\n2    plot/adi_tiles/2.zarr    (625, 459)  (256, 256)  float32\n3    plot/adi_tiles/3.zarr    (313, 230)  (256, 256)  float32\n4    plot/adi_tiles/4.zarr    (157, 115)  (256, 256)  float32\n5    plot/adi_tiles/5.zarr      (79, 58)  (256, 256)  float32\n6    plot/adi_tiles/6.zarr      (40, 29)  (256, 256)  float32\n7    plot/adi_tiles/7.zarr      (20, 15)  (256, 256)  float32\n8    plot/adi_tiles/8.zarr       (10, 8)  (256, 256)  float32\n9    plot/adi_tiles/9.zarr        (5, 4)  (256, 256)  float32\n10  plot/adi_tiles/10.zarr        (3, 2)  (256, 256)  float32\n2024-03-21 19:36:00 - render_ras_tiles - INFO - tiles rendering starts.\nTiles: 100%|██████████| 11/11 [00:00&lt;00:00, 33.32it/s]\n2024-03-21 19:36:01 - render_ras_tiles - INFO - tiles rendering finished.\n\n\n\nrender_ras_tiles(rslc,rendered_rslc_dir)\n\n2024-03-21 19:36:01 - logging_args - INFO - running function: render_ras_tiles\n2024-03-21 19:36:01 - logging_args - INFO - fetching args:\n2024-03-21 19:36:01 - logging_args - INFO - ras = 'plot/rslc.zarr'\n2024-03-21 19:36:01 - logging_args - INFO - out_dir = 'plot/rslc_tiles'\n2024-03-21 19:36:01 - logging_args - INFO - fetching args done.\n2024-03-21 19:36:01 - zarr_info - INFO - plot/rslc.zarr zarray shape: (2500, 1834, 17)\n2024-03-21 19:36:01 - zarr_info - INFO - plot/rslc.zarr zarray chunks: (1000, 1000, 1)\n2024-03-21 19:36:01 - zarr_info - INFO - plot/rslc.zarr zarray dtype: complex64\n2024-03-21 19:36:01 - render_ras_tiles - INFO - rendered tiles zoom level range from 0 (finest resolution) to 10 (coarsest resolution).\n2024-03-21 19:36:02 - render_ras_tiles - INFO - tiles to be rendered: \n                        path             shape         chunks      dtype\n0    plot/rslc_tiles/0.zarr  (2500, 1834, 17)  (256, 256, 1)  complex64\n1    plot/rslc_tiles/1.zarr   (1250, 917, 17)  (256, 256, 1)  complex64\n2    plot/rslc_tiles/2.zarr    (625, 459, 17)  (256, 256, 1)  complex64\n3    plot/rslc_tiles/3.zarr    (313, 230, 17)  (256, 256, 1)  complex64\n4    plot/rslc_tiles/4.zarr    (157, 115, 17)  (256, 256, 1)  complex64\n5    plot/rslc_tiles/5.zarr      (79, 58, 17)  (256, 256, 1)  complex64\n6    plot/rslc_tiles/6.zarr      (40, 29, 17)  (256, 256, 1)  complex64\n7    plot/rslc_tiles/7.zarr      (20, 15, 17)  (256, 256, 1)  complex64\n8    plot/rslc_tiles/8.zarr       (10, 8, 17)  (256, 256, 1)  complex64\n9    plot/rslc_tiles/9.zarr        (5, 4, 17)  (256, 256, 1)  complex64\n10  plot/rslc_tiles/10.zarr        (3, 2, 17)  (256, 256, 1)  complex64\n2024-03-21 19:36:02 - render_ras_tiles - INFO - tiles rendering starts.\nImages: 100%|██████████| 17/17 [00:08&lt;00:00,  1.90it/s]\n2024-03-21 19:36:11 - render_ras_tiles - INFO - tiles rendering finished.\n\n\n\nsource\n\n\nras_plot\n\n ras_plot (rendered_tiles_dir:str, post_proc:Callable=None,\n           bounds:tuple=None)\n\nplot rendered ras tiles.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrendered_tiles_dir\nstr\n\ndirectory to the rendered images\n\n\npost_proc\nCallable\nNone\nfunction for the post processing\n\n\nbounds\ntuple\nNone\nbounding box (x0, y0, x_max, y_max)\n\n\n\n\nhv.extension('bokeh')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n\n\n\n\n\n\n\nras_plot take the rendered tiles as the input and return a Holoviews DynamicMap. It accept a post processing function for customized post processing. Here we define a function to mask pixels with ADI larger than 0.4:\n\ndef mask_adi(data:np.array,):\n    data[data&gt;=0.4]=np.nan\n    return data\n\n\nadi_plot = ras_plot(rendered_adi_dir,post_proc=mask_adi,bounds=(0,0,1833,2499))\n\nAdd annotations:\n\nadi_plot = adi_plot.redim(x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'),\n                          z=hv.Dimension('adi',label='Amplitude Dispersion Index',range=(0,0.4)))\n\nSpecify plotting options and plot:\n\nadi_plot.opts(opts.Image(cmap='fire',width=600, height=400, colorbar=True,\n                         invert_yaxis=True, tools=['hover'],))\n\n\n\n\n\n  \n\n\n\n\n\nsource\n\n\nras_stack_plot\n\n ras_stack_plot (rendered_tiles_dir:str, post_proc:Callable=None,\n                 bounds:tuple=None)\n\nplot rendered stack of ras tiles.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrendered_tiles_dir\nstr\n\ndirectory to the rendered images\n\n\npost_proc\nCallable\nNone\nfunction for the post processing\n\n\nbounds\ntuple\nNone\nbounding box (x0, y0, x_max, y_max)\n\n\n\nras_stack_plot take the rendered images as the input and return a Holoviews DynamicMap. It accept a post processing function for customized post processing. Here we define a function to generate interferograms w.r.t the first SLC:\n\ndef intf_0(data_zarr, xslice, yslice,i):\n    return np.angle(data_zarr[yslice,xslice,i]*data_zarr[yslice,xslice,0].conj())\n\n\nintf_plot = ras_stack_plot(rendered_rslc_dir,post_proc=intf_0)\n\nAdd annotations:\n\ndates = [\"20210802\", \"20210816\", \"20210830\", \"20210913\", \"20211011\", \"20211025\", \"20220606\", \"20220620\",\n         \"20220704\", \"20220718\", \"20220801\", \"20220815\", \"20220829\", \"20220912\", \"20220926\", \"20221010\",\n         \"20221024\",]\nintf_plot = intf_plot.redim(i=hv.Dimension('i', label='Interferogram', range=(0,16), value_format=(lambda i: dates[i]+'_'+dates[0])),\n                            x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('Phase',range=(-np.pi,np.pi)))\n\nSpecify plotting options and plot:\n\nhv.output(widget_location='bottom')\nintf_plot.opts(opts.Image(cmap='colorwheel',width=600, height=400, colorbar=True,\n                          invert_yaxis=True, tools=['hover'],))\n\n\n\n\n\n  \n\n\n\n\nWe can also plot sequential interferograms. In this case, we only plot 26 interferograms.\n\ndef intf_seq(data_zarr, xslice, yslice,i):\n    return np.angle(data_zarr[yslice,xslice,i]*data_zarr[yslice,xslice,i-1].conj())\nintf_plot = ras_stack_plot(rendered_rslc_dir,post_proc=intf_seq)\nintf_plot = intf_plot.redim(i=hv.Dimension('i', label='Interferogram', range=(1,16), value_format=(lambda i: dates[i]+'_'+dates[i-1])),\n                            x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('Phase',range=(-np.pi,np.pi)))\nintf_plot.opts(opts.Image(cmap='colorwheel',width=600, height=400, colorbar=True,\n                          invert_yaxis=True, tools=['hover'],))\n\n\n\n\n\n  \n\n\n\n\nOr the intensity:\n\ndef intensity(data_zarr, xslice, yslice,i):\n    return np.log(np.abs(data_zarr[yslice,xslice,i])**2)\n\nint_plot = ras_stack_plot(rendered_rslc_dir,post_proc=intensity)\nint_plot = int_plot.redim(i=hv.Dimension('i', label='Intensity', range=(1,16), value_format=(lambda i: dates[i])),\n                          x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('Intensity'))\nint_plot.opts(opts.Image(cmap='fire',width=600, height=400, colorbar=True,\n                          invert_yaxis=True, tools=['hover'],))",
    "crumbs": [
      "CLI",
      "plot"
    ]
  },
  {
    "objectID": "CLI/pl.html",
    "href": "CLI/pl.html",
    "title": "pl",
    "section": "",
    "text": "from matplotlib import pyplot as plt\nimport zarr\nimport colorcet\nfrom decorrelation.cli.utils.logging import get_logger\nfrom decorrelation.cli.pc import de_pc2ras\n\n\nsource\n\nde_emi\n\n de_emi (coh:str, ph:str, emi_quality:str, ref:int=0, n_pc_chunk:int=None,\n         pc_chunk_size:int=None)\n\nPhase linking with EMI estimator.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoh\nstr\n\ncoherence matrix\n\n\nph\nstr\n\noutput, wrapped phase\n\n\nemi_quality\nstr\n\noutput, pixel quality\n\n\nref\nint\n0\nreference image for phase\n\n\nn_pc_chunk\nint\nNone\nnumber of point cloud chunk\n\n\npc_chunk_size\nint\nNone\npoint cloud chunk size\n\n\n\n\nds_can_coh = './co/ds_can_coh.zarr'\nds_can_ph = './pl/ds_can_ph.zarr'\nds_can_emi_quality = './pl/ds_can_emi_quality.zarr'\nref = 0\n\n\nlogger = get_logger()\n\n\nde_emi(ds_can_coh,ds_can_ph,ds_can_emi_quality,ref=ref)\n\n2023-11-05 23:41:25 - logging_args - INFO - running function: de_emi\n2023-11-05 23:41:25 - logging_args - INFO - fetching args:\n2023-11-05 23:41:25 - logging_args - INFO - coh = './co/ds_can_coh.zarr'\n2023-11-05 23:41:25 - logging_args - INFO - ph = './pl/ds_can_ph.zarr'\n2023-11-05 23:41:25 - logging_args - INFO - emi_quality = './pl/ds_can_emi_quality.zarr'\n2023-11-05 23:41:25 - logging_args - INFO - ref = 0\n2023-11-05 23:41:25 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 23:41:25 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 23:41:25 - logging_args - INFO - fetching args done.\n2023-11-05 23:41:25 - zarr_info - INFO - ./co/ds_can_coh.zarr zarray shape: (740397, 17, 17)\n2023-11-05 23:41:25 - zarr_info - INFO - ./co/ds_can_coh.zarr zarray chunks: (123400, 1, 1)\n2023-11-05 23:41:25 - zarr_info - INFO - ./co/ds_can_coh.zarr zarray dtype: complex64\n2023-11-05 23:41:25 - get_pc_chunk_size_from_pc_chunk_size - INFO - automatically determine pc_chunk_size from\n            pc_chunk_size of coh.\n2023-11-05 23:41:25 - get_pc_chunk_size_from_pc_chunk_size - INFO - pc_chunk_size for ph: 123400\n2023-11-05 23:41:25 - de_emi - INFO - starting dask CUDA local cluster.\n2023-11-05 23:41:32 - de_emi - INFO - dask local CUDA cluster started.\n2023-11-05 23:41:32 - darr_info - INFO - coh dask array shape: (740397, 17, 17)\n2023-11-05 23:41:32 - darr_info - INFO - coh dask array chunksize: (123400, 17, 17)\n2023-11-05 23:41:32 - darr_info - INFO - coh dask array dtype: complex64\n2023-11-05 23:41:32 - de_emi - INFO - phase linking with EMI.\n2023-11-05 23:41:33 - de_emi - INFO - got ph and emi_quality.\n2023-11-05 23:41:33 - darr_info - INFO - ph dask array shape: (740397, 17)\n2023-11-05 23:41:33 - darr_info - INFO - ph dask array chunksize: (123400, 17)\n2023-11-05 23:41:33 - darr_info - INFO - ph dask array dtype: complex64\n2023-11-05 23:41:33 - darr_info - INFO - emi_quality dask array shape: (740397,)\n2023-11-05 23:41:33 - darr_info - INFO - emi_quality dask array chunksize: (123400,)\n2023-11-05 23:41:33 - darr_info - INFO - emi_quality dask array dtype: float32\n2023-11-05 23:41:33 - de_emi - INFO - rechunk ph\n2023-11-05 23:41:33 - darr_info - INFO - ph dask array shape: (740397, 17)\n2023-11-05 23:41:33 - darr_info - INFO - ph dask array chunksize: (123400, 17)\n2023-11-05 23:41:33 - darr_info - INFO - ph dask array dtype: complex64\n2023-11-05 23:41:33 - de_emi - INFO - saving ph and emi_quality.\n2023-11-05 23:41:33 - de_emi - INFO - computing graph setted. doing all the computing.\n2023-11-05 23:41:48 - de_emi - INFO - computing finished.ed | 14.9s\n2023-11-05 23:41:50 - de_emi - INFO - dask cluster closed.\n\n\n\nds_can_idx = './shp/ds_can_idx.zarr'\nemi_quality = './pl/emi_quality.zarr'\nrslc_zarr = zarr.open('./raw/rslc.zarr/','r')\nde_pc2ras(ds_can_idx, ds_can_emi_quality,emi_quality,rslc_zarr.shape[:2],az_chunk_size=rslc_zarr.chunks[0])\n\n2023-11-05 23:41:50 - logging_args - INFO - running function: de_pc2ras\n2023-11-05 23:41:50 - logging_args - INFO - fetching args:\n2023-11-05 23:41:50 - logging_args - INFO - idx = './shp/ds_can_idx.zarr'\n2023-11-05 23:41:50 - logging_args - INFO - pc = './pl/ds_can_emi_quality.zarr'\n2023-11-05 23:41:50 - logging_args - INFO - ras = './pl/emi_quality.zarr'\n2023-11-05 23:41:50 - logging_args - INFO - shape = (2500, 1834)\n2023-11-05 23:41:50 - logging_args - INFO - az_chunk_size = 1000\n2023-11-05 23:41:50 - logging_args - INFO - n_az_chunk = None\n2023-11-05 23:41:50 - logging_args - INFO - r_chunk_size = None\n2023-11-05 23:41:50 - logging_args - INFO - n_r_chunk = None\n2023-11-05 23:41:50 - logging_args - INFO - fetching args done.\n2023-11-05 23:41:50 - zarr_info - INFO - idx zarray shape: (2, 740397)\n2023-11-05 23:41:50 - zarr_info - INFO - idx zarray chunks: (2, 123400)\n2023-11-05 23:41:50 - zarr_info - INFO - idx zarray dtype: int32\n2023-11-05 23:41:50 - get_ras_chunk_size_from_n_pc_chunk - INFO - automatically set r_chunk_size to nlines of ras\n2023-11-05 23:41:50 - get_ras_chunk_size_from_n_pc_chunk - INFO - got az_chunk_size for ras: 1000\n2023-11-05 23:41:50 - de_pc2ras - INFO - loading idx into memory.\n2023-11-05 23:41:51 - de_pc2ras - INFO - starting dask local cluster.\n2023-11-05 23:41:55 - de_pc2ras - INFO - dask local cluster started.\n2023-11-05 23:41:55 - de_pc2ras - INFO - start to work on ./pl/ds_can_emi_quality.zarr\n2023-11-05 23:41:55 - zarr_info - INFO - ./pl/ds_can_emi_quality.zarr zarray shape: (740397,)\n2023-11-05 23:41:55 - zarr_info - INFO - ./pl/ds_can_emi_quality.zarr zarray chunks: (123400,)\n2023-11-05 23:41:55 - zarr_info - INFO - ./pl/ds_can_emi_quality.zarr zarray dtype: float32\n2023-11-05 23:41:55 - darr_info - INFO - pc dask array shape: (740397,)\n2023-11-05 23:41:55 - darr_info - INFO - pc dask array chunksize: (123400,)\n2023-11-05 23:41:55 - darr_info - INFO - pc dask array dtype: float32\n2023-11-05 23:41:55 - de_pc2ras - INFO - create ras dask array\n2023-11-05 23:41:55 - darr_info - INFO - ras dask array shape: (2500, 1834)\n2023-11-05 23:41:55 - darr_info - INFO - ras dask array chunksize: (1000, 1834)\n2023-11-05 23:41:55 - darr_info - INFO - ras dask array dtype: float32\n2023-11-05 23:41:55 - de_pc2ras - INFO - computing graph setted. doing all the computing.\n2023-11-05 23:41:57 - de_pc2ras - INFO - computing finished.|  1.5s\n2023-11-05 23:41:57 - de_pc2ras - INFO - dask cluster closed.\n\n\n\nemi_zarr = zarr.open('./pl/emi_quality.zarr','r')\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(emi_zarr[:],interpolation='nearest',vmin=1.0,vmax=1.3,cmap=colorcet.cm.fire)\nax.set(title='EMI quality factor',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\n\n\n\n\n\n\n\n\n\nsource\n\n\nde_ds_temp_coh\n\n de_ds_temp_coh (coh:str, ph:str, t_coh:str, n_pc_chunk:int=None,\n                 pc_chunk_size:int=None)\n\nDS temporal coherence.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoh\nstr\n\ncoherence matrix\n\n\nph\nstr\n\nwrapped phase\n\n\nt_coh\nstr\n\noutput, temporal coherence\n\n\nn_pc_chunk\nint\nNone\nnumber of point cloud chunk\n\n\npc_chunk_size\nint\nNone\npoint cloud chunk size\n\n\n\nThis function estimate the temporal coherence of DSs which is defined as (Ferretti et al. 2011):\n\nFerretti, Alessandro, Alfio Fumagalli, Fabrizio Novali, Claudio Prati, Fabio Rocca, and Alessio Rucci. 2011. “A New Algorithm for Processing Interferometric Data-Stacks: SqueeSAR.” IEEE Transactions on Geoscience and Remote Sensing 49 (9): 3460–70. https://doi.org/10.1109/TGRS.2011.2124465.\n\\[\\gamma = \\frac{1}{N^2-N} \\sum_{n=1}^{N} \\sum_{k \\neq n}^{N} e^{i\\phi_{nk}} e^{-i(\\theta_n-\\theta_k)}\\]\nWhere \\(\\phi_{nk}\\) is the phase of complex coherence matrix and \\(\\theta_{n}\\) is the phase after phase linking.\n\nds_can_coh = './co/ds_can_coh.zarr'\nds_can_ph = './pl/ds_can_ph.zarr'\nds_can_t_coh = './pl/ds_can_t_coh.zarr'\n\n\nde_ds_temp_coh(ds_can_coh,ds_can_ph, ds_can_t_coh)\n\n2023-11-05 23:41:58 - logging_args - INFO - running function: de_ds_temp_coh\n2023-11-05 23:41:58 - logging_args - INFO - fetching args:\n2023-11-05 23:41:58 - logging_args - INFO - coh = './co/ds_can_coh.zarr'\n2023-11-05 23:41:58 - logging_args - INFO - ph = './pl/ds_can_ph.zarr'\n2023-11-05 23:41:58 - logging_args - INFO - t_coh = './pl/ds_can_t_coh.zarr'\n2023-11-05 23:41:58 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 23:41:58 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 23:41:58 - logging_args - INFO - fetching args done.\n2023-11-05 23:41:58 - zarr_info - INFO - ./co/ds_can_coh.zarr zarray shape: (740397, 17, 17)\n2023-11-05 23:41:58 - zarr_info - INFO - ./co/ds_can_coh.zarr zarray chunks: (123400, 1, 1)\n2023-11-05 23:41:58 - zarr_info - INFO - ./co/ds_can_coh.zarr zarray dtype: complex64\n2023-11-05 23:41:58 - zarr_info - INFO - ./pl/ds_can_ph.zarr zarray shape: (740397, 17)\n2023-11-05 23:41:58 - zarr_info - INFO - ./pl/ds_can_ph.zarr zarray chunks: (123400, 17)\n2023-11-05 23:41:58 - zarr_info - INFO - ./pl/ds_can_ph.zarr zarray dtype: complex64\n2023-11-05 23:41:58 - get_pc_chunk_size_from_pc_chunk_size - INFO - automatically determine pc_chunk_size from\n            pc_chunk_size of coh.\n2023-11-05 23:41:58 - get_pc_chunk_size_from_pc_chunk_size - INFO - pc_chunk_size for ph: 123400\n2023-11-05 23:41:58 - de_ds_temp_coh - INFO - starting dask CUDA local cluster.\n2023-11-05 23:42:03 - de_ds_temp_coh - INFO - dask local CUDA cluster started.\n2023-11-05 23:42:03 - darr_info - INFO - coh dask array shape: (740397, 17, 17)\n2023-11-05 23:42:03 - darr_info - INFO - coh dask array chunksize: (123400, 17, 17)\n2023-11-05 23:42:03 - darr_info - INFO - coh dask array dtype: complex64\n2023-11-05 23:42:03 - darr_info - INFO - ph dask array shape: (740397, 17)\n2023-11-05 23:42:03 - darr_info - INFO - ph dask array chunksize: (123400, 17)\n2023-11-05 23:42:03 - darr_info - INFO - ph dask array dtype: complex64\n2023-11-05 23:42:03 - de_ds_temp_coh - INFO - Estimate temporal coherence for DS.\n2023-11-05 23:42:03 - de_ds_temp_coh - INFO - got temporal coherence t_coh.\n2023-11-05 23:42:03 - darr_info - INFO - t_coh dask array shape: (740397,)\n2023-11-05 23:42:03 - darr_info - INFO - t_coh dask array chunksize: (123400,)\n2023-11-05 23:42:03 - darr_info - INFO - t_coh dask array dtype: float32\n2023-11-05 23:42:03 - de_ds_temp_coh - INFO - saving t_coh.\n2023-11-05 23:42:03 - de_ds_temp_coh - INFO - computing graph setted. doing all the computing.\n2023-11-05 23:42:04 - de_ds_temp_coh - INFO - computing finished.5s\n2023-11-05 23:42:06 - de_ds_temp_coh - INFO - dask cluster closed.\n\n\n\nds_can_idx = './shp/ds_can_idx.zarr'\nt_coh = './pl/t_coh.zarr'\nrslc_zarr = zarr.open('./raw/rslc.zarr/','r')\nde_pc2ras(ds_can_idx, ds_can_t_coh,t_coh,rslc_zarr.shape[:2],az_chunk_size=rslc_zarr.chunks[0])\n\n2023-11-05 23:42:06 - logging_args - INFO - running function: de_pc2ras\n2023-11-05 23:42:06 - logging_args - INFO - fetching args:\n2023-11-05 23:42:06 - logging_args - INFO - idx = './shp/ds_can_idx.zarr'\n2023-11-05 23:42:06 - logging_args - INFO - pc = './pl/ds_can_t_coh.zarr'\n2023-11-05 23:42:06 - logging_args - INFO - ras = './pl/t_coh.zarr'\n2023-11-05 23:42:06 - logging_args - INFO - shape = (2500, 1834)\n2023-11-05 23:42:06 - logging_args - INFO - az_chunk_size = 1000\n2023-11-05 23:42:06 - logging_args - INFO - n_az_chunk = None\n2023-11-05 23:42:06 - logging_args - INFO - r_chunk_size = None\n2023-11-05 23:42:06 - logging_args - INFO - n_r_chunk = None\n2023-11-05 23:42:06 - logging_args - INFO - fetching args done.\n2023-11-05 23:42:06 - zarr_info - INFO - idx zarray shape: (2, 740397)\n2023-11-05 23:42:06 - zarr_info - INFO - idx zarray chunks: (2, 123400)\n2023-11-05 23:42:06 - zarr_info - INFO - idx zarray dtype: int32\n2023-11-05 23:42:06 - get_ras_chunk_size_from_n_pc_chunk - INFO - automatically set r_chunk_size to nlines of ras\n2023-11-05 23:42:06 - get_ras_chunk_size_from_n_pc_chunk - INFO - got az_chunk_size for ras: 1000\n2023-11-05 23:42:06 - de_pc2ras - INFO - loading idx into memory.\n2023-11-05 23:42:06 - de_pc2ras - INFO - starting dask local cluster.\n2023-11-05 23:42:11 - de_pc2ras - INFO - dask local cluster started.\n2023-11-05 23:42:11 - de_pc2ras - INFO - start to work on ./pl/ds_can_t_coh.zarr\n2023-11-05 23:42:11 - zarr_info - INFO - ./pl/ds_can_t_coh.zarr zarray shape: (740397,)\n2023-11-05 23:42:11 - zarr_info - INFO - ./pl/ds_can_t_coh.zarr zarray chunks: (123400,)\n2023-11-05 23:42:11 - zarr_info - INFO - ./pl/ds_can_t_coh.zarr zarray dtype: float32\n2023-11-05 23:42:11 - darr_info - INFO - pc dask array shape: (740397,)\n2023-11-05 23:42:11 - darr_info - INFO - pc dask array chunksize: (123400,)\n2023-11-05 23:42:11 - darr_info - INFO - pc dask array dtype: float32\n2023-11-05 23:42:11 - de_pc2ras - INFO - create ras dask array\n2023-11-05 23:42:11 - darr_info - INFO - ras dask array shape: (2500, 1834)\n2023-11-05 23:42:11 - darr_info - INFO - ras dask array chunksize: (1000, 1834)\n2023-11-05 23:42:11 - darr_info - INFO - ras dask array dtype: float32\n2023-11-05 23:42:11 - de_pc2ras - INFO - computing graph setted. doing all the computing.\n2023-11-05 23:42:12 - de_pc2ras - INFO - computing finished.|  0.8s\n2023-11-05 23:42:12 - de_pc2ras - INFO - dask cluster closed.\n\n\n2023-11-05 23:42:12,273 - distributed.worker - ERROR - Unexpected exception during heartbeat. Closing worker.\nTraceback (most recent call last):\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/worker.py\", line 1253, in heartbeat\n    response = await retry_operation(\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 454, in retry_operation\n    return await retry(\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 433, in retry\n    return await coro()\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1344, in send_recv_from_rpc\n    comm = await self.pool.connect(self.addr)\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1543, in connect\n    raise RuntimeError(\"ConnectionPool is closed\")\nRuntimeError: ConnectionPool is closed\n2023-11-05 23:42:12,275 - tornado.application - ERROR - Exception in callback &lt;bound method Worker.heartbeat of &lt;Worker 'tcp://127.0.0.1:40345', name: 15, status: closed, stored: 0, running: 0/8, ready: 0, comm: 0, waiting: 0&gt;&gt;\nTraceback (most recent call last):\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/tornado/ioloop.py\", line 921, in _run\n    await val\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/worker.py\", line 1253, in heartbeat\n    response = await retry_operation(\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 454, in retry_operation\n    return await retry(\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 433, in retry\n    return await coro()\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1344, in send_recv_from_rpc\n    comm = await self.pool.connect(self.addr)\n  File \"/users/kangl/miniforge3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1543, in connect\n    raise RuntimeError(\"ConnectionPool is closed\")\nRuntimeError: ConnectionPool is closed\n\n\n\nt_coh_zarr = zarr.open(t_coh,'r')\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(t_coh_zarr[:],interpolation='nearest')\nax.set(title='DS temporal coherence',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)",
    "crumbs": [
      "CLI",
      "pl"
    ]
  },
  {
    "objectID": "CLI/load.html",
    "href": "CLI/load.html",
    "title": "load",
    "section": "",
    "text": "import zarr\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom decorrelation.cli.utils.logging import get_logger\n\n\nsource\n\nde_load_gamma_flatten_rslc\n\n de_load_gamma_flatten_rslc (rslc_dir:str, reference:str, hgt:str,\n                             scratch_dir:str, rslc_zarr:str,\n                             az_chunk_size:int=None,\n                             r_chunk_size:int=None)\n\nGenerate flatten rslc data from gamma command and convert them into zarr format. The shape of hgt should be same as one rslc image, i.e. the hgt file is generated with 1 by 1 look geocoding.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc_dir\nstr\n\ngamma rslc directory, the name of the rslc and their par files should be ‘????????.rslc’ and ‘????????.rslc.par’\n\n\nreference\nstr\n\nreference date, eg: ‘20200202’\n\n\nhgt\nstr\n\nthe DEM in radar coordinate\n\n\nscratch_dir\nstr\n\ndirectory for preserve gamma intermediate files\n\n\nrslc_zarr\nstr\n\noutput, the flattened rslcs stack in zarr format\n\n\naz_chunk_size\nint\nNone\nrslcs stack azimuth chunk size, azimuth number of lines by default (one chunk)\n\n\nr_chunk_size\nint\nNone\nrslcs stack range chunk size\n\n\n\nThe method behind the flattened RSLC:\nLet the value of i-th rslc be \\(s_i\\), the simulated phase due to DEM and position difference be \\(u_{ij}\\). D-InSAR basically is: \\[d_{ij}=s_i \\times s_j^* \\times e^{-ju_{ij}}.\\] Let the distance between satellite and ground target for th i-th observation be \\(l_i\\). Then, the simulated phase for DInSAR \\[u_{ij} = l_i-l_j.\\] So, a simple conclusion is \\[u_{ij}-u_{ik}=-u_{jk}.\\] If we define \\[s_i^{\\prime} = s_i \\times e^{ju_{xi}},\\] where \\(X\\) can be any arbitrary interger less than \\(N\\)- the total number of the RSLCs. Then we can find that \\[int_{ij}^{\\prime} =  s_i^{\\prime} \\times s_j^{\\prime*} = s_i \\times s_j^* \\times e^{j(u_{xi}-u_{xj})} = s_i \\times s_j^* \\times e^{j(u_{xi}-u_{xj})} = s_i \\times s_j^* \\times e^{-ju_{ij}} = d_{ij}.\\]\nWe call \\(s_i^{\\prime}\\) as flattened RSLC. The advantage of flattened RSLC is DInSAR can be easily calculated by simple conjugate multiplication.\nAn example:\n\nrslc_dir = '../../data/gamma/rslc'\nreference = '20220620'\nhgt = '../../data/gamma/geocoding/20210802.hgt'\nrslc_zarr = './raw/rslc.zarr'\nscratch_dir = './raw/scratch'\naz_chunk_size = 1000\nr_chunk_size = 1000\n\n\nlogger = get_logger()\n\n\nde_load_gamma_flatten_rslc(rslc_dir,reference,hgt,scratch_dir,rslc_zarr,az_chunk_size=az_chunk_size,r_chunk_size=r_chunk_size)\n\n2023-11-05 23:33:30 - logging_args - INFO - running function: de_load_gamma_flatten_rslc\n2023-11-05 23:33:30 - logging_args - INFO - fetching args:\n2023-11-05 23:33:30 - logging_args - INFO - rslc_dir = '../../data/gamma/rslc'\n2023-11-05 23:33:30 - logging_args - INFO - reference = '20220620'\n2023-11-05 23:33:30 - logging_args - INFO - hgt = '../../data/gamma/geocoding/20210802.hgt'\n2023-11-05 23:33:30 - logging_args - INFO - scratch_dir = './raw/scratch'\n2023-11-05 23:33:30 - logging_args - INFO - rslc_zarr = './raw/rslc.zarr'\n2023-11-05 23:33:30 - logging_args - INFO - az_chunk_size = 1000\n2023-11-05 23:33:30 - logging_args - INFO - r_chunk_size = 1000\n2023-11-05 23:33:30 - logging_args - INFO - fetching args done.\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - rslc found: \n        date                                 rslc  \\\n0   20210802  ../../data/gamma/rslc/20210802.rslc   \n1   20210816  ../../data/gamma/rslc/20210816.rslc   \n2   20210830  ../../data/gamma/rslc/20210830.rslc   \n3   20210913  ../../data/gamma/rslc/20210913.rslc   \n4   20211011  ../../data/gamma/rslc/20211011.rslc   \n5   20211025  ../../data/gamma/rslc/20211025.rslc   \n6   20220606  ../../data/gamma/rslc/20220606.rslc   \n7   20220620  ../../data/gamma/rslc/20220620.rslc   \n8   20220704  ../../data/gamma/rslc/20220704.rslc   \n9   20220718  ../../data/gamma/rslc/20220718.rslc   \n10  20220801  ../../data/gamma/rslc/20220801.rslc   \n11  20220815  ../../data/gamma/rslc/20220815.rslc   \n12  20220829  ../../data/gamma/rslc/20220829.rslc   \n13  20220912  ../../data/gamma/rslc/20220912.rslc   \n14  20220926  ../../data/gamma/rslc/20220926.rslc   \n15  20221010  ../../data/gamma/rslc/20221010.rslc   \n16  20221024  ../../data/gamma/rslc/20221024.rslc   \n\n                                        par  \n0   ../../data/gamma/rslc/20210802.rslc.par  \n1   ../../data/gamma/rslc/20210816.rslc.par  \n2   ../../data/gamma/rslc/20210830.rslc.par  \n3   ../../data/gamma/rslc/20210913.rslc.par  \n4   ../../data/gamma/rslc/20211011.rslc.par  \n5   ../../data/gamma/rslc/20211025.rslc.par  \n6   ../../data/gamma/rslc/20220606.rslc.par  \n7   ../../data/gamma/rslc/20220620.rslc.par  \n8   ../../data/gamma/rslc/20220704.rslc.par  \n9   ../../data/gamma/rslc/20220718.rslc.par  \n10  ../../data/gamma/rslc/20220801.rslc.par  \n11  ../../data/gamma/rslc/20220815.rslc.par  \n12  ../../data/gamma/rslc/20220829.rslc.par  \n13  ../../data/gamma/rslc/20220912.rslc.par  \n14  ../../data/gamma/rslc/20220926.rslc.par  \n15  ../../data/gamma/rslc/20221010.rslc.par  \n16  ../../data/gamma/rslc/20221024.rslc.par  \n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - number of images: 17.\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - image number of lines: 2500.\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - image width: 1834.\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - run gamma command to generate required data for flattened rslcs:\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210802.rslc.par raw/scratch/20220620_20210802.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20210802.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210802.rslc.par raw/scratch/20220620_20210802.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20210802.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210816.rslc.par raw/scratch/20220620_20210816.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20210816.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210816.rslc.par raw/scratch/20220620_20210816.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20210816.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210830.rslc.par raw/scratch/20220620_20210830.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20210830.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210830.rslc.par raw/scratch/20220620_20210830.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20210830.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210913.rslc.par raw/scratch/20220620_20210913.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20210913.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210913.rslc.par raw/scratch/20220620_20210913.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20210913.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20211011.rslc.par raw/scratch/20220620_20211011.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20211011.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20211011.rslc.par raw/scratch/20220620_20211011.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20211011.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20211025.rslc.par raw/scratch/20220620_20211025.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20211025.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20211025.rslc.par raw/scratch/20220620_20211025.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20211025.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220606.rslc.par raw/scratch/20220620_20220606.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20220606.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220606.rslc.par raw/scratch/20220620_20220606.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20220606.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220620.rslc.par raw/scratch/20220620_20220620.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20220620.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220620.rslc.par raw/scratch/20220620_20220620.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20220620.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220704.rslc.par raw/scratch/20220620_20220704.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20220704.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220704.rslc.par raw/scratch/20220620_20220704.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20220704.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220718.rslc.par raw/scratch/20220620_20220718.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20220718.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220718.rslc.par raw/scratch/20220620_20220718.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20220718.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220801.rslc.par raw/scratch/20220620_20220801.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20220801.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220801.rslc.par raw/scratch/20220620_20220801.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20220801.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220815.rslc.par raw/scratch/20220620_20220815.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20220815.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220815.rslc.par raw/scratch/20220620_20220815.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20220815.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220829.rslc.par raw/scratch/20220620_20220829.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20220829.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220829.rslc.par raw/scratch/20220620_20220829.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20220829.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220912.rslc.par raw/scratch/20220620_20220912.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20220912.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220912.rslc.par raw/scratch/20220620_20220912.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20220912.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220926.rslc.par raw/scratch/20220620_20220926.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20220926.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220926.rslc.par raw/scratch/20220620_20220926.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20220926.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20221010.rslc.par raw/scratch/20220620_20221010.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20221010.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20221010.rslc.par raw/scratch/20220620_20221010.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20221010.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20221024.rslc.par raw/scratch/20220620_20221024.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20221024.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20221024.rslc.par raw/scratch/20220620_20221024.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20221024.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - gamma command finished.\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - using dask to load data in gamma binary format to calculate flatten rslcs and save it to zarr.\n2023-11-05 23:33:30 - de_load_gamma_flatten_rslc - INFO - starting dask local cluster.\n2023-11-05 23:33:34 - de_load_gamma_flatten_rslc - INFO - dask local cluster started.\n2023-11-05 23:33:34 - darr_info - INFO - flattened rslc dask array shape: (2500, 1834, 17)\n2023-11-05 23:33:34 - darr_info - INFO - flattened rslc dask array chunksize: (1000, 1000, 1)\n2023-11-05 23:33:34 - darr_info - INFO - flattened rslc dask array dtype: complex64\n2023-11-05 23:33:35 - de_load_gamma_flatten_rslc - INFO - computing graph setted. doing all the computing.\n2023-11-05 23:33:39 - de_load_gamma_flatten_rslc - INFO - computing finished.\n2023-11-05 23:33:40 - de_load_gamma_flatten_rslc - INFO - dask cluster closed.\n\n\n\nsource\n\n\nde_load_gamma_lat_lon_hgt\n\n de_load_gamma_lat_lon_hgt (diff_par:str, rslc_par:str, dem_par:str,\n                            hgt:str, scratch_dir:str, lat_zarr:str,\n                            lon_zarr:str, hgt_zarr:str,\n                            az_chunk_size:int=None, r_chunk_size:int=None)\n\nFunction to load longitude and latitude from gamma binary format to zarr.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndiff_par\nstr\n\ngeocoding diff_par,using the simulated image as reference\n\n\nrslc_par\nstr\n\npar file of the reference rslc\n\n\ndem_par\nstr\n\ndem par\n\n\nhgt\nstr\n\nDEM in radar coordinate\n\n\nscratch_dir\nstr\n\ndirectory for preserve gamma intermediate files\n\n\nlat_zarr\nstr\n\noutput, latitude zarr\n\n\nlon_zarr\nstr\n\noutput, longitude zarr\n\n\nhgt_zarr\nstr\n\noutput, height zarr\n\n\naz_chunk_size\nint\nNone\nazimuth chunk size, default (height)\n\n\nr_chunk_size\nint\nNone\nrange chunk size, default (width)\n\n\n\n\ndiff_par = '../../data/gamma/geocoding/20210802.diff_par'\nrslc_par = '../../data/gamma/rslc/20220620.rslc.par'\ndem_par = '../../data/gamma/DEM/dem_seg_par'\nhgt = '../../data/gamma/geocoding/20210802.hgt'\nscratch_dir = './raw/scratch'\nlat_zarr = './raw/lat.zarr'\nlon_zarr = './raw/lon.zarr'\nhgt_zarr = './raw/hgt.zarr'\naz_chunk_size = 1000\nr_chunk_size = 1000\n\nAn example:\n\nde_load_gamma_lat_lon_hgt(diff_par,rslc_par,dem_par,hgt,scratch_dir,lat_zarr,lon_zarr,hgt_zarr,az_chunk_size=az_chunk_size,r_chunk_size=r_chunk_size)\n\n2023-11-05 23:33:40 - logging_args - INFO - running function: de_load_gamma_lat_lon_hgt\n2023-11-05 23:33:40 - logging_args - INFO - fetching args:\n2023-11-05 23:33:40 - logging_args - INFO - diff_par = '../../data/gamma/geocoding/20210802.diff_par'\n2023-11-05 23:33:40 - logging_args - INFO - rslc_par = '../../data/gamma/rslc/20220620.rslc.par'\n2023-11-05 23:33:40 - logging_args - INFO - dem_par = '../../data/gamma/DEM/dem_seg_par'\n2023-11-05 23:33:40 - logging_args - INFO - hgt = '../../data/gamma/geocoding/20210802.hgt'\n2023-11-05 23:33:40 - logging_args - INFO - scratch_dir = './raw/scratch'\n2023-11-05 23:33:40 - logging_args - INFO - lat_zarr = './raw/lat.zarr'\n2023-11-05 23:33:40 - logging_args - INFO - lon_zarr = './raw/lon.zarr'\n2023-11-05 23:33:40 - logging_args - INFO - hgt_zarr = './raw/hgt.zarr'\n2023-11-05 23:33:40 - logging_args - INFO - az_chunk_size = 1000\n2023-11-05 23:33:40 - logging_args - INFO - r_chunk_size = 1000\n2023-11-05 23:33:40 - logging_args - INFO - fetching args done.\n2023-11-05 23:33:40 - de_load_gamma_lat_lon_hgt - INFO - image shape: (2500,1834)\n2023-11-05 23:33:40 - de_load_gamma_lat_lon_hgt - INFO - run gamma command to generate longitude, latitude and height:\n2023-11-05 23:33:40 - de_load_gamma_lat_lon_hgt - INFO - raw/scratch/plist exists. skip runing mkgrid raw/scratch/plist 1834 2500 1 1 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:40 - de_load_gamma_lat_lon_hgt - INFO - raw/scratch/phgt_wgs84 exists. skip runing pt2geo raw/scratch/plist - ../../data/gamma/rslc/20220620.rslc.par - ../../data/gamma/geocoding/20210802.hgt ../../data/gamma/DEM/dem_seg_par ../../data/gamma/geocoding/20210802.diff_par 1 1 - - raw/scratch/plat_lon raw/scratch/phgt_wgs84 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:40 - de_load_gamma_lat_lon_hgt - INFO - writing zarr file.\n2023-11-05 23:33:41 - de_load_gamma_lat_lon_hgt - INFO - write done.\n\n\n\nlon_data = zarr.open(lon_zarr,mode='r')[:]\nlat_data = zarr.open(lat_zarr,mode='r')[:]\nhgt_data = zarr.open(hgt_zarr,mode='r')[:]\n\nlon_data[lon_data==0] = np.nan\nlat_data[lat_data==0] = np.nan\nhgt_data[hgt_data==0] = np.nan\n\n\nfig,axes = plt.subplots(1,3,figsize=(16,5))\nim0 = axes[0].imshow(lon_data)\naxes[0].set_title('Longitude')\nfig.colorbar(im0, ax=axes[0])\nim1 = axes[1].imshow(lat_data)\naxes[1].set_title('Latitude')\nfig.colorbar(im1, ax=axes[1])\nim2 = axes[2].imshow(hgt_data)\naxes[2].set_title('Height')\nfig.colorbar(im2, ax=axes[2])\nfig.show()\n\n\n\n\n\n\n\n\n\nsource\n\n\nde_load_gamma_look_vector\n\n de_load_gamma_look_vector (theta:str, phi:str, lt:str, rslc_par:str,\n                            dem_par:str, scratch_dir:str, theta_zarr:str,\n                            phi_zarr:str, az_chunk_size:int=None,\n                            r_chunk_size:int=None)\n\nLoad look vector (elevation angle and orientation angle) in map geometry from gamma binary format to look vector in radar geometry zarr file. The two input data should be generated with the look_vector gamma command.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntheta\nstr\n\nelevation angle\n\n\nphi\nstr\n\norientation angle\n\n\nlt\nstr\n\nlookup table\n\n\nrslc_par\nstr\n\npar file of the reference rslc\n\n\ndem_par\nstr\n\ndem par\n\n\nscratch_dir\nstr\n\ndirectory for preserve gamma intermediate files\n\n\ntheta_zarr\nstr\n\noutput, elevation angle zarr\n\n\nphi_zarr\nstr\n\noutput, orientation angle zarr\n\n\naz_chunk_size\nint\nNone\nazimuth chunk size, default (height)\n\n\nr_chunk_size\nint\nNone\nrange chunk size, default (width)\n\n\n\nAn example:\n\nlt = '../../data/gamma/geocoding/20210802.lt_fine'\nrslc_par = '../../data/gamma/rslc/20220620.rslc.par'\ndem_par = '../../data/gamma/DEM/dem_seg_par'\ntheta = '../../data/gamma/geocoding/20210802.lv_theta'\nphi = '../../data/gamma/geocoding/20210802.lv_phi'\nscratch_dir = './raw/scratch'\ntheta_zarr = './raw/theta.zarr'\nphi_zarr = './raw/phi.zarr'\naz_chunk_size = 1000\n\n\nde_load_gamma_look_vector(theta,phi,lt,rslc_par,dem_par,scratch_dir,theta_zarr,phi_zarr,az_chunk_size)\n\n2023-11-05 23:33:43 - logging_args - INFO - running function: de_load_gamma_look_vector\n2023-11-05 23:33:43 - logging_args - INFO - fetching args:\n2023-11-05 23:33:43 - logging_args - INFO - theta = '../../data/gamma/geocoding/20210802.lv_theta'\n2023-11-05 23:33:43 - logging_args - INFO - phi = '../../data/gamma/geocoding/20210802.lv_phi'\n2023-11-05 23:33:43 - logging_args - INFO - lt = '../../data/gamma/geocoding/20210802.lt_fine'\n2023-11-05 23:33:43 - logging_args - INFO - rslc_par = '../../data/gamma/rslc/20220620.rslc.par'\n2023-11-05 23:33:43 - logging_args - INFO - dem_par = '../../data/gamma/DEM/dem_seg_par'\n2023-11-05 23:33:43 - logging_args - INFO - scratch_dir = './raw/scratch'\n2023-11-05 23:33:43 - logging_args - INFO - theta_zarr = './raw/theta.zarr'\n2023-11-05 23:33:43 - logging_args - INFO - phi_zarr = './raw/phi.zarr'\n2023-11-05 23:33:43 - logging_args - INFO - az_chunk_size = 1000\n2023-11-05 23:33:43 - logging_args - INFO - r_chunk_size = None\n2023-11-05 23:33:43 - logging_args - INFO - fetching args done.\n2023-11-05 23:33:43 - de_load_gamma_look_vector - INFO - image shape: (2500,1834)\n2023-11-05 23:33:43 - de_load_gamma_look_vector - INFO - raw/scratch/theta_rdc exists. skip runing geocode ../../data/gamma/geocoding/20210802.lt_fine ../../data/gamma/geocoding/20210802.lv_theta 5741 raw/scratch/theta_rdc 1834 2500 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:43 - de_load_gamma_look_vector - INFO - writing data.\n2023-11-05 23:33:43 - de_load_gamma_look_vector - INFO - raw/scratch/phi_rdc exists. skip runing geocode ../../data/gamma/geocoding/20210802.lt_fine ../../data/gamma/geocoding/20210802.lv_phi 5741 raw/scratch/phi_rdc 1834 2500 &gt;&gt; raw/scratch/gamma.log\n2023-11-05 23:33:43 - de_load_gamma_look_vector - INFO - writing data.\n2023-11-05 23:33:43 - de_load_gamma_look_vector - INFO - Done.\n\n\n\ntheta_data = zarr.open(theta_zarr,mode='r')[:]\nphi_data = zarr.open(phi_zarr,mode='r')[:]\ntheta_data[theta_data==0] = np.nan\nphi_data[phi_data==0] = np.nan\n\n\nfig,axes = plt.subplots(1,2,figsize=(11,5))\nim0 = axes[0].imshow(np.rad2deg(theta_data))\naxes[0].set_title('Elevation angle')\nfig.colorbar(im0, ax=axes[0])\nim1 = axes[1].imshow(np.rad2deg(phi_data))\naxes[1].set_title('Orientation anlge')\nfig.colorbar(im1, ax=axes[1])\nfig.show()\n\n\n\n\n\n\n\n\n\nsource\n\n\nde_load_gamma_range\n\n de_load_gamma_range (rslc_par:str, range_zarr:str,\n                      az_chunk_size:int=None, r_chunk_size:int=None)\n\nGenerate slant range distance and save to zarr.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc_par\nstr\n\npar file of one rslc\n\n\nrange_zarr\nstr\n\noutput, range distance zarr\n\n\naz_chunk_size\nint\nNone\nazimuth chunk size, default (height)\n\n\nr_chunk_size\nint\nNone\nrange chunk size, default (width)\n\n\n\nAn example:\n\nrslc_par = '../../data/gamma/rslc/20220620.rslc.par'\nrange_zarr = './raw/range.zarr'\naz_chunk_size = 1000\n\n\nde_load_gamma_range(rslc_par,range_zarr,az_chunk_size)\n\n2023-11-05 23:33:44 - logging_args - INFO - running function: de_load_gamma_range\n2023-11-05 23:33:44 - logging_args - INFO - fetching args:\n2023-11-05 23:33:44 - logging_args - INFO - rslc_par = '../../data/gamma/rslc/20220620.rslc.par'\n2023-11-05 23:33:44 - logging_args - INFO - range_zarr = './raw/range.zarr'\n2023-11-05 23:33:44 - logging_args - INFO - az_chunk_size = 1000\n2023-11-05 23:33:44 - logging_args - INFO - r_chunk_size = None\n2023-11-05 23:33:44 - logging_args - INFO - fetching args done.\n2023-11-05 23:33:44 - de_load_gamma_range - INFO - image shape: (2500,1834)\n2023-11-05 23:33:44 - de_load_gamma_range - INFO - Calculating slant range distance.\n2023-11-05 23:33:44 - de_load_gamma_range - INFO - writing data.\n2023-11-05 23:33:44 - de_load_gamma_range - INFO - Done.\n\n\n\nrange_data = zarr.open(range_zarr,mode='r')[:]\nrange_data[range_data==0] = np.nan\nplt.imshow(range_data)\nplt.colorbar()\nplt.title(\"Slant range distance\")\nplt.show()\n\n\n\n\n\n\n\n\n\nsource\n\n\nde_load_gamma_metadata\n\n de_load_gamma_metadata (rslc_dir:str, reference:str, meta_file:str)\n\nLoad necessary metadata into a toml file.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nrslc_dir\nstr\n# gamma rslc directory, the name of the rslc and their par files should be ‘????????.rslc’ and ‘????????.rslc.par’\n\n\nreference\nstr\nreference date, eg: ‘20200202’\n\n\nmeta_file\nstr\ntext toml file for meta data\n\n\n\nAn example:\n\nrslc_dir = '../../data/gamma/rslc'\nreference = '20220620'\nmeta_file = './raw/meta.toml'\n\n\nde_load_gamma_metadata(rslc_dir,reference,meta_file)\n\n2023-11-05 23:33:45 - logging_args - INFO - running function: de_load_gamma_metadata\n2023-11-05 23:33:45 - logging_args - INFO - fetching args:\n2023-11-05 23:33:45 - logging_args - INFO - rslc_dir = '../../data/gamma/rslc'\n2023-11-05 23:33:45 - logging_args - INFO - reference = '20220620'\n2023-11-05 23:33:45 - logging_args - INFO - meta_file = './raw/meta.toml'\n2023-11-05 23:33:45 - logging_args - INFO - fetching args done.\n2023-11-05 23:33:45 - de_load_gamma_metadata - INFO - Fetching heading angle\n2023-11-05 23:33:45 - de_load_gamma_metadata - INFO - Fetching range pixel spacing\n2023-11-05 23:33:45 - de_load_gamma_metadata - INFO - fetching azimuth pixel spacing\n2023-11-05 23:33:45 - de_load_gamma_metadata - INFO - Fetching randar wavelength\n2023-11-05 23:33:45 - de_load_gamma_metadata - INFO - Run gamma command to calculate baseline:\n2023-11-05 23:33:45 - de_load_gamma_metadata - INFO - run command: base_calc /tmp/tmpgro9gjnc/slc_tab ../../data/gamma/rslc/20220620.rslc.par /tmp/tmpgro9gjnc/bperp /tmp/tmpgro9gjnc/itab - &gt; /tmp/tmpgro9gjnc/log\n2023-11-05 23:33:45 - de_load_gamma_metadata - INFO - gamma command finished.\n2023-11-05 23:33:45 - de_load_gamma_metadata - INFO - All meta data: \ndates = [ \"20210802\", \"20210816\", \"20210830\", \"20210913\", \"20211011\", \"20211025\", \"20220606\", \"20220620\", \"20220704\", \"20220718\", \"20220801\", \"20220815\", \"20220829\", \"20220912\", \"20220926\", \"20221010\", \"20221024\",]\nradar_wavelength = 0.24245249210715603\nrange_pixel_spacing = 4.29054\nazimuth_pixel_spacing = 3.740105\nperpendicular_baseline = [ -97.61360168457031, -45.58580017089844, 17.86680030822754, -26.258899688720703, -63.72420120239258, -56.363399505615234, 64.75759887695312, 0.0, -9.043999671936035, -13.02869987487793, -112.94960021972656, -86.09490203857422, -129.9635009765625, -127.6594009399414, -182.29519653320312, -129.735107421875, -184.31100463867188,]\n\n2023-11-05 23:33:45 - de_load_gamma_metadata - INFO - writing data in toml file.\n2023-11-05 23:33:45 - de_load_gamma_metadata - INFO - Done.\n\n\n\nwith open(meta_file,'r') as f:\n    meta_read = toml.load(f)\n\n\nmeta_read\n\n{'dates': ['20210802',\n  '20210816',\n  '20210830',\n  '20210913',\n  '20211011',\n  '20211025',\n  '20220606',\n  '20220620',\n  '20220704',\n  '20220718',\n  '20220801',\n  '20220815',\n  '20220829',\n  '20220912',\n  '20220926',\n  '20221010',\n  '20221024'],\n 'radar_wavelength': 0.24245249210715603,\n 'range_pixel_spacing': 4.29054,\n 'azimuth_pixel_spacing': 3.740105,\n 'perpendicular_baseline': [-97.61360168457031,\n  -45.58580017089844,\n  17.86680030822754,\n  -26.258899688720703,\n  -63.72420120239258,\n  -56.363399505615234,\n  64.75759887695312,\n  0.0,\n  -9.043999671936035,\n  -13.02869987487793,\n  -112.94960021972656,\n  -86.09490203857422,\n  -129.9635009765625,\n  -127.6594009399414,\n  -182.29519653320312,\n  -129.735107421875,\n  -184.31100463867188]}",
    "crumbs": [
      "CLI",
      "load"
    ]
  },
  {
    "objectID": "CLI/utils/appconfig.html",
    "href": "CLI/utils/appconfig.html",
    "title": "appconfig",
    "section": "",
    "text": "source\n\nget_config\n\n get_config (appname='decorrelation')"
  },
  {
    "objectID": "CLI/utils/chunk_size.html",
    "href": "CLI/utils/chunk_size.html",
    "title": "chunk_size",
    "section": "",
    "text": "source\n\nget_pc_chunk_size_from_n_pc_chunk\n\n get_pc_chunk_size_from_n_pc_chunk (in_pc_name, out_pc_name, n_pc_in,\n                                    pc_chunk_size_in, n_pc,\n                                    pc_chunk_size=None, n_pc_chunk=None)\n\nIf no specified chunk information, the n_pc_chunk of output is same as the input.\n\nsource\n\n\nget_pc_chunk_size_from_pc_chunk_size\n\n get_pc_chunk_size_from_pc_chunk_size (in_pc_name, out_pc_name,\n                                       pc_chunk_size_in, n_pc,\n                                       pc_chunk_size=None,\n                                       n_pc_chunk=None)\n\nif no specified chunk information, the pc_chunk_size of output is same as the input.\n\nsource\n\n\nget_pc_chunk_size_from_n_ras_chunk\n\n get_pc_chunk_size_from_n_ras_chunk (ras_name, pc_name, nlines, width,\n                                     az_chunk_size_in, r_chunk_size_in,\n                                     n_pc, pc_chunk_size=None,\n                                     n_pc_chunk=None)\n\n\nsource\n\n\nget_ras_chunk_size_from_n_pc_chunk\n\n get_ras_chunk_size_from_n_pc_chunk (pc_name, ras_name, n_pc,\n                                     pc_chunk_size, nlines, width,\n                                     az_chunk_size=None, n_az_chunk=None,\n                                     r_chunk_size=None, n_r_chunk=None)\n\n\nsource\n\n\nget_ras_chunk_size_from_ras_chunk_size\n\n get_ras_chunk_size_from_ras_chunk_size (in_ras_name, out_ras_name,\n                                         nlines, width, az_chunk_size_in,\n                                         r_chunk_size_in,\n                                         az_chunk_size=None,\n                                         n_az_chunk=None,\n                                         r_chunk_size=None,\n                                         n_r_chunk=None)"
  },
  {
    "objectID": "CLI/utils/logging.html",
    "href": "CLI/utils/logging.html",
    "title": "logging",
    "section": "",
    "text": "source\n\nDeLogger\n\n DeLogger (name, level=0)\n\nInstances of the Logger class represent a single logging channel. A “logging channel” indicates an area of an application. Exactly how an “area” is defined is up to the application developer. Since an application can have any number of areas, logging channels are identified by a unique string. Application areas can be nested (e.g. an area of “input processing” might include sub-areas “read CSV files”, “read XLS files” and “read Gnumeric files”). To cater for this natural nesting, channel names are organized into a namespace hierarchy where levels are separated by periods, much like the Java or Python package namespace. So in the instance given above, channel names might be “input” for the upper level, and “input.csv”, “input.xls” and “input.gnu” for the sub-levels. There is no arbitrary limit to the depth of nesting.\n\nsource\n\n\nde_logger\n\n de_logger (func)\n\n\nsource\n\n\nlog_args\n\n log_args (func)\n\n\nsource\n\n\nget_logger\n\n get_logger (logfile:str=None)\n\nget logger for decorrelation cli application\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlogfile\nstr\nNone\nlogfile, optional. default: no logfile"
  },
  {
    "objectID": "CLI/ps.html",
    "href": "CLI/ps.html",
    "title": "ps",
    "section": "",
    "text": "import zarr\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport colorcet\nfrom decorrelation.cli.utils.logging import get_logger\n\n\nsource\n\nde_amp_disp\n\n de_amp_disp (rslc:str, adi:str, az_chunk_size:str=None,\n              n_az_chunk:str=None, r_chunk_size:int=None,\n              n_r_chunk:int=None)\n\ncalculation the amplitude dispersion index from SLC stack.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc\nstr\n\nrslc stack\n\n\nadi\nstr\n\noutput, amplitude dispersion index\n\n\naz_chunk_size\nstr\nNone\nazimuth chunk size\n\n\nn_az_chunk\nstr\nNone\nnumber of azimuth chunks\n\n\nr_chunk_size\nint\nNone\noutput range chunk size\n\n\nn_r_chunk\nint\nNone\noutput number of range chunks\n\n\n\nUsing amplitude dispersion index (ADI) to identify persistent scatterers is first used in (Ferretti, Prati, and Rocca Jan./2001).\n\nFerretti, A., C. Prati, and F. Rocca. Jan./2001. “Permanent Scatterers in SAR Interferometry.” IEEE Transactions on Geoscience and Remote Sensing 39 (1): 8–20. https://doi.org/10.1109/36.898661.\nUsage:\n\nrslc = '../../data/rslc.zarr'\nadi = './ps/adi.zarr'\n\n\nlogger = get_logger()\n\n\nde_amp_disp(rslc,adi)\n\n2023-11-05 02:48:57 - logging_args - INFO - running function: de_amp_disp\n2023-11-05 02:48:57 - logging_args - INFO - fetching args:\n2023-11-05 02:48:57 - logging_args - INFO - rslc = '../../data/rslc.zarr'\n2023-11-05 02:48:57 - logging_args - INFO - adi = './ps/adi.zarr'\n2023-11-05 02:48:57 - logging_args - INFO - az_chunk_size = None\n2023-11-05 02:48:57 - logging_args - INFO - n_az_chunk = None\n2023-11-05 02:48:57 - logging_args - INFO - r_chunk_size = None\n2023-11-05 02:48:57 - logging_args - INFO - n_r_chunk = None\n2023-11-05 02:48:57 - logging_args - INFO - fetching args done.\n2023-11-05 02:48:57 - zarr_info - INFO - ../../data/rslc.zarr zarray shape: (2500, 1834, 17)\n2023-11-05 02:48:57 - zarr_info - INFO - ../../data/rslc.zarr zarray chunks: (1000, 1000, 17)\n2023-11-05 02:48:57 - zarr_info - INFO - ../../data/rslc.zarr zarray dtype: complex64\n2023-11-05 02:48:57 - get_ras_chunk_size_from_ras_chunk_size - INFO - automatically determine az_chunk_size from \n            az_chunk_size of rslc\n2023-11-05 02:48:57 - get_ras_chunk_size_from_ras_chunk_size - INFO - az_chunk_size for adi: 1000\n2023-11-05 02:48:57 - get_ras_chunk_size_from_ras_chunk_size - INFO - automatically determine r_chunk_size from\n            r_chunk_size of rslc\n2023-11-05 02:48:57 - get_ras_chunk_size_from_ras_chunk_size - INFO - r_chunk_size for adi: 1000\n2023-11-05 02:48:57 - de_amp_disp - INFO - starting dask CUDA local cluster.\n2023-11-05 02:49:03 - de_amp_disp - INFO - dask local CUDA cluster started.\n2023-11-05 02:49:03 - darr_info - INFO - rslc dask array shape: (2500, 1834, 17)\n2023-11-05 02:49:03 - darr_info - INFO - rslc dask array chunksize: (1000, 1000, 17)\n2023-11-05 02:49:03 - darr_info - INFO - rslc dask array dtype: complex64\n2023-11-05 02:49:03 - de_amp_disp - INFO - calculate amplitude dispersion index.\n2023-11-05 02:49:04 - de_amp_disp - INFO - got amplitude dispersion index.\n2023-11-05 02:49:04 - darr_info - INFO - adi dask array shape: (2500, 1834)\n2023-11-05 02:49:04 - darr_info - INFO - adi dask array chunksize: (1000, 1000)\n2023-11-05 02:49:04 - darr_info - INFO - adi dask array dtype: float32\n2023-11-05 02:49:04 - de_amp_disp - INFO - saving adi.\n2023-11-05 02:49:04 - de_amp_disp - INFO - computing graph setted. doing all the computing.\n2023-11-05 02:49:05 - de_amp_disp - INFO - computing finished. 0.9s\n2023-11-05 02:49:07 - de_amp_disp - INFO - dask cluster closed.\n\n\n\nadi = zarr.open('./ps/adi.zarr/','r')[:]\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(adi,vmin=0,vmax=1)\nax.set(title='Amplitude Dispersion Index',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\n\n\n\nWe can then select PS candidate according to adi:\n\nps_can_idx = './ps/ps_can_idx.zarr'\nde_pc_logic_ras('./ps/adi.zarr/',ps_can_idx,'(ras&gt;=0)&(ras&lt;=0.3)')\n\n2023-11-05 02:49:07 - logging_args - INFO - running function: de_pc_logic_ras\n2023-11-05 02:49:07 - logging_args - INFO - fetching args:\n2023-11-05 02:49:07 - logging_args - INFO - ras = './ps/adi.zarr/'\n2023-11-05 02:49:07 - logging_args - INFO - idx = './ps/ps_can_idx.zarr'\n2023-11-05 02:49:07 - logging_args - INFO - operation = '(ras&gt;=0)&(ras&lt;=0.3)'\n2023-11-05 02:49:07 - logging_args - INFO - pc_chunk_size = None\n2023-11-05 02:49:07 - logging_args - INFO - n_pc_chunk = None\n2023-11-05 02:49:07 - logging_args - INFO - fetching args done.\n2023-11-05 02:49:07 - zarr_info - INFO - ./ps/adi.zarr/ zarray shape: (2500, 1834)\n2023-11-05 02:49:07 - zarr_info - INFO - ./ps/adi.zarr/ zarray chunks: (1000, 1000)\n2023-11-05 02:49:07 - zarr_info - INFO - ./ps/adi.zarr/ zarray dtype: float32\n2023-11-05 02:49:07 - de_pc_logic_ras - INFO - loading ras into memory.\n2023-11-05 02:49:07 - de_pc_logic_ras - INFO - select pc based on operation: (ras&gt;=0)&(ras&lt;=0.3)\n2023-11-05 02:49:08 - de_pc_logic_ras - INFO - number of selected pixels: 44018.\n2023-11-05 02:49:08 - get_pc_chunk_size_from_n_ras_chunk - INFO - automatically determine pc_chunk_size from\n            n_pc of idx and n_ras_chunk of ras\n2023-11-05 02:49:08 - get_pc_chunk_size_from_n_ras_chunk - INFO - n_ras_chunk of ras: 6\n2023-11-05 02:49:08 - get_pc_chunk_size_from_n_ras_chunk - INFO - pc_chunk_size for idx: 7337\n2023-11-05 02:49:08 - de_pc_logic_ras - INFO - writing idx.\n2023-11-05 02:49:08 - de_pc_logic_ras - INFO - write done."
  }
]